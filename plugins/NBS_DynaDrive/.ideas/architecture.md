# DSP Architecture: NBS_DynaDrive

**CRITICAL CONTRACT:** This specification is immutable during Stages 1-4 implementation. Stage 1 Planning cannot proceed without this file. Stage 3 (DSP) implements this exact architecture.

**Generated by:** Stage 0 Research (research-planning-agent)
**Date:** 2026-02-27
**Referenced by:** Stage 1 (Planning), Stage 3 (DSP Implementation)
**Purpose:** DSP specification defining processing components, signal flow, and JUCE module usage

---

## Core Components

### Input Gain Stage
- **JUCE Class:** `juce::dsp::Gain<float>` (inside `juce::dsp::ProcessorChain`)
- **Purpose:** Apply pre-processing gain before any dynamics or saturation stage
- **Parameters Affected:** input (-48 to +10 dB)
- **Configuration:**
  - Maps dB parameter to linear gain: `linearGain = juce::Decibels::decibelsToGain(inputDb)`
  - Uses `juce::LinearSmoothedValue<float>` for click-free gain changes (5ms smoothing)
  - Stereo: same gain applied to both channels (before M/S split if active)

### M/S Matrix Encoder
- **JUCE Class:** Custom implementation — no dedicated JUCE class
- **Purpose:** Encode left/right stereo to mid/side representation when M/S mode is active
- **Parameters Affected:** ms_enable (bool), mid_drive, side_drive
- **Configuration:**
  - When ms_enable == false: signal passes through unchanged (stereo L/R)
  - When ms_enable == true:
    - Mid = (Left + Right) * 0.5
    - Side = (Left - Right) * 0.5
  - Encoded signals held in two separate buffers: midBuffer and sideBuffer
  - Standard gain-corrected M/S matrix: factor 0.5 prevents loudness increase on encoding
  - Only the saturation stage uses mid_drive and side_drive separately

### M/S Matrix Decoder
- **JUCE Class:** Custom implementation — no dedicated JUCE class
- **Purpose:** Decode mid/side back to left/right after M/S processing
- **Parameters Affected:** ms_enable (bool)
- **Configuration:**
  - When ms_enable == true:
    - Left = Mid + Side
    - Right = Mid - Side
  - Must be applied after the entire saturation + dynamics chain in M/S mode
  - Decoding is the inverse of encoding — no gain correction needed (already done at encode)
  - If ms_enable is false, decoder stage is bypassed

### ADAA Waveshaping Engine (Saturation)
- **JUCE Class:** Custom implementation — no JUCE class for ADAA
- **Purpose:** Anti-aliased saturation via Antiderivative Anti-Aliasing. Eliminates aliasing at 1x sample rate without oversampling. Implements transformer-style harmonic character with even/odd harmonic control and variable curve shape.
- **Parameters Affected:** drive, even, odd, h_curve, mid_drive (M/S), side_drive (M/S)
- **Configuration:**
  - **Core ADAA formula (first-order):**
    - `y[n] = (F1(x[n]) - F1(x[n-1])) / (x[n] - x[n-1])`
    - Where `F1` is the antiderivative of the waveshaping function `f`
    - For small delta (|x[n] - x[n-1]| < epsilon ~1e-5): fallback to `y[n] = f(x[n])` to avoid division by near-zero
  - **Base waveshaper: softclipper with variable knee (h_curve)**
    - h_curve = 0% (Soft): `f(x) = tanh(x)` — gradual onset
    - h_curve = 50% (Medium): Blended polynomial with moderate knee
    - h_curve = 100% (Hard): `f(x) = clip(x, -1, 1)` — hard clipping (approached as limit of higher-gain tanh)
    - Implementation: Morph between tanh and hard-clip via a blending parameter alpha:
      - `alpha = h_curve / 100.0`
      - Soft shape: `f_soft(x) = tanh(gain * x) / tanh(gain)` — unity-gain normalized
      - Hard shape: Polynomial approximation: `f_hard(x) = 1.5*x - 0.5*x^3` (cubic soft clipper with variable gain)
      - Blended: `f(x) = (1 - alpha) * f_soft(x) + alpha * f_hard(x)`
    - Each shape variant must have analytically computed antiderivative F1(x) for ADAA
  - **Even harmonics enhancement (even parameter):**
    - Even harmonics = 2nd, 4th order: require asymmetric transfer function
    - Implementation: Add a DC-offset bias before waveshaping: `x_biased = x + bias`
    - bias = even * 0.15 (max bias 0.15 — subtle asymmetry)
    - After waveshaping: remove DC via highpass at 5Hz (`juce::dsp::IIR::Filter<float>` with HPF coefficients)
    - Asymmetric waveshaping produces even-order harmonics naturally
    - The ADAA formula is applied to the asymmetric waveshaper including the DC bias
  - **Odd harmonics enhancement (odd parameter):**
    - Odd harmonics = 3rd, 5th order: symmetric transfer function naturally produces these
    - Implementation: Add polynomial distortion pre-stage: `x_odd = x + odd_gain * x^3`
    - odd_gain = odd * 0.05 (max cubic addition 0.05 — preserves ADAA-tractable curve)
    - The cubic pre-distortion shifts the waveshaper toward more aggressive odd harmonic production
  - **Drive parameter:**
    - drive (0-100%) maps to input gain before waveshaping: `inputGain = 1.0 + (drive / 100.0) * 15.0`
    - Range: 1x (0%) to 16x (100%) gain into the waveshaper
    - After waveshaping, compensate gain so output ≈ input level: `outputCompensation = 1.0 / inputGain`
    - Net effect: heavier saturation at high drive without massive level increase
  - **M/S mode:**
    - When ms_enable: mid_drive replaces drive for mid channel, side_drive for side channel
    - Each channel processed through independent ADAA instance with its own x[n-1] state
    - Allows different saturation characters for mid (dense, punchy) vs. side (wider, lighter)
  - **Previous sample state:** One float per channel stored for ADAA (x[n-1])
  - **DC blocking:** Post-waveshaper highpass at ~5Hz on each channel (addresses DC from even bias)

### Post-Saturation Tilt Filter
- **JUCE Class:** `juce::dsp::ProcessorDuplicator<juce::dsp::IIR::Filter<float>, juce::dsp::IIR::Coefficients<float>>` — two instances (low shelf + high shelf)
- **Purpose:** Tilt EQ placed immediately after saturation. Allows shaping of harmonic content before dynamics stage.
- **Parameters Affected:** sat_tilt_freq (100-10000 Hz), sat_tilt_slope (-6 to +6 dB/oct)
- **Configuration:**
  - Tilt EQ = simultaneous low shelf + high shelf with complementary gains
  - At sat_tilt_slope = 0: both shelves bypass (unity gain), filter is inactive
  - At sat_tilt_slope > 0 (bright): high shelf boost + low shelf cut at sat_tilt_freq
  - At sat_tilt_slope < 0 (dark): low shelf boost + high shelf cut at sat_tilt_freq
  - Shelf gain calculation:
    - highShelfGain_dB = sat_tilt_slope * 6.0 (maps -6 to +6 dB/oct → -36 to +36 dB, capped at ±12 dB practical)
    - lowShelfGain_dB = -sat_tilt_slope * 6.0 (complementary)
    - Practical cap: limit to ±12 dB per shelf to prevent extreme settings from destroying signal
  - Low shelf: `juce::dsp::IIR::Coefficients<float>::makeLowShelf(sampleRate, freq, Q, gainLinear)`
  - High shelf: `juce::dsp::IIR::Coefficients<float>::makeHighShelf(sampleRate, freq, Q, gainLinear)`
  - Q = 0.707 (Butterworth, maximally flat in passband)
  - Coefficients updated whenever sat_tilt_freq or sat_tilt_slope changes (not per-sample — use atomic flag)
  - When slope == 0: bypass flag set, processing skipped (zero CPU when flat)

### Dynamics Engine (Upward + Downward Compressor)
- **JUCE Class:** Custom implementation — `juce::dsp::Compressor<float>` covers downward only; upward requires custom expander logic
- **Purpose:** Program-dependent dual compressor. Downward compression reduces peaks (glue, control). Upward compression raises quiet signals (density, sustain, energy). Combined via macro dynamics parameter.
- **Parameters Affected:** dynamics, up, down, threshold, ratio, attack_time, release_time
- **Configuration:**

  **Level Detection (shared):**
  - Detector type: RMS with 10ms window (smooth detection, musical response)
  - `levelDb = 20.0 * log10(rmsLevel)` — converts to dB for threshold comparison
  - Ballistics:
    - Attack coefficient: `a_att = exp(-1.0 / (attack_time_ms * 0.001 * sampleRate))`
    - Release coefficient: `a_rel = exp(-1.0 / (release_time_ms * 0.001 * sampleRate))`
    - Smooth detector: `level[n] = max(level_peak, a_att * level[n-1] + (1-a_att) * |x[n]|^2)`

  **Program-Dependent Ballistics Override:**
  - Crest factor = peak / RMS over 50ms window
  - High crest factor (transient-rich, e.g., drums): attack shortened by up to 50%, release shortened by up to 30%
  - Low crest factor (sustained, e.g., pads): attack and release use manual values unmodified
  - Crest factor measured per 50ms analysis block; smoothed with 200ms time constant to avoid jitter
  - Implementation: `effectiveAttack = attack_time * lerp(1.0, 0.5, clamp(crestFactor - 1.0, 0, 1))`

  **Downward Compression:**
  - Classic soft-knee compressor
  - When levelDb > threshold: gain reduction = (threshold + (levelDb - threshold) / ratio) - levelDb
  - Soft knee: 6 dB knee width around threshold, blends linearly into full ratio
  - `down` parameter (0-100%) scales the amount of gain reduction: `gainReduction *= (down / 100.0)`
  - `dynamics` parameter (0-100%) acts as a global macro: `gainReduction *= (dynamics / 100.0)`

  **Upward Compression:**
  - Targets signals BELOW threshold (raises the floor)
  - When levelDb < threshold: upward gain = threshold - levelDb (bring quiet signal up toward threshold)
  - Gain applied: `upwardGain = (threshold - levelDb) * (up / 100.0) * upwardRatio`
  - upwardRatio fixed at 0.3 (gentle — doesn't fully compress the floor, just lifts it)
  - `dynamics` parameter scales upward compression as well: `upwardGain *= (dynamics / 100.0)`
  - Critical: upward compression applies GAIN (signals get louder), not attenuation

  **Gain Application:**
  - Combined gain: `totalGain = downwardGain + upwardGain` (additive in dB, converted to linear)
  - Gain smoothing: 1-pole IIR filter with ballistic coefficients (no zipper noise)
  - Applied to all channels equally (linked stereo detection, not independent channels)

  **M/S mode:**
  - When ms_enable: compressor processes mid and side channels independently
  - Independent level detectors and gain computers per channel (2 instances)
  - threshold/ratio/attack/release apply to both channels (no per-channel control)

### Post-Dynamics Tilt Filter
- **JUCE Class:** `juce::dsp::ProcessorDuplicator<juce::dsp::IIR::Filter<float>, juce::dsp::IIR::Coefficients<float>>` — two instances (low shelf + high shelf)
- **Purpose:** Tilt EQ placed after dynamics stage. Final tonal shaping of the output character.
- **Parameters Affected:** dyn_tilt_freq (100-10000 Hz), dyn_tilt_slope (-6 to +6 dB/oct)
- **Configuration:**
  - Identical architecture to Post-Saturation Tilt Filter
  - Same shelf implementation using `juce::dsp::IIR::Coefficients<float>::makeLowShelf/makeHighShelf`
  - Independent pivot frequency (dyn_tilt_freq) and slope (dyn_tilt_slope)
  - Same bypass logic: when slope == 0, bypass processing (zero CPU overhead)
  - Coefficient updates gated by change detection — not recomputed every sample

### Dry/Wet Mixer
- **JUCE Class:** `juce::dsp::DryWetMixer<float>`
- **Purpose:** Blend dry (unprocessed) signal with wet (processed) signal. Captures dry before processing chain and blends at output.
- **Parameters Affected:** mix (0-100%)
- **Configuration:**
  - Dry signal captured immediately after input gain (before dynamics and saturation)
  - mix = 100%: fully wet (only processed signal)
  - mix = 0%: fully dry (only original signal)
  - `juce::dsp::DryWetMixer` handles latency compensation automatically if processing introduces latency
  - mix (0-100%) maps to normalised wet ratio (0.0-1.0)
  - `DryWetMixingRule::balanced` — maintains constant power during blend

### Output Gain Stage
- **JUCE Class:** `juce::dsp::Gain<float>`
- **Purpose:** Final output / makeup gain after full processing chain
- **Parameters Affected:** output (-48 to +10 dB)
- **Configuration:**
  - Same implementation as Input Gain Stage
  - `juce::Decibels::decibelsToGain(outputDb)` conversion
  - `juce::LinearSmoothedValue<float>` for click-free adjustments (5ms smoothing)
  - Applied as final stage before output

---

## Processing Chain

The signal chain has two modes controlled by pre_post. Both share the same set of stages but differ in the relative order of Dynamics and Saturation:

**DYN→SAT mode (pre_post == false, default):**
```
Input
  |
  v
[Input Gain] (input, -48 to +10 dB)
  |
  +-----> [Dry capture to DryWetMixer buffer] (mix parameter)
  |
  v
[M/S Encoder (if ms_enable)] ← ms_enable, encodes L/R to Mid/Side
  |
  v
[Dynamics Engine] (dynamics, up, down, threshold, ratio, attack_time, release_time)
  |
  v
[ADAA Saturation Engine] (drive, even, odd, h_curve; mid_drive/side_drive in M/S)
  |
  v
[Post-Saturation Tilt] (sat_tilt_freq, sat_tilt_slope)
  |
  v
[M/S Decoder (if ms_enable)] ← reconstructs L/R from Mid/Side
  |
  v
[Post-Dynamics Tilt] (dyn_tilt_freq, dyn_tilt_slope)
  |
  v
[DryWetMixer blend] ← mix (0-100%)
  |
  v
[Output Gain] (output, -48 to +10 dB)
  |
  v
Output
```

**SAT→DYN mode (pre_post == true):**
```
Input
  |
  v
[Input Gain]
  |
  +-----> [Dry capture to DryWetMixer buffer]
  |
  v
[M/S Encoder (if ms_enable)]
  |
  v
[ADAA Saturation Engine] (drive, even, odd, h_curve; mid_drive/side_drive in M/S)
  |
  v
[Post-Saturation Tilt] (sat_tilt_freq, sat_tilt_slope)
  |
  v
[Dynamics Engine] (dynamics, up, down, threshold, ratio, attack_time, release_time)
  |
  v
[M/S Decoder (if ms_enable)]
  |
  v
[Post-Dynamics Tilt] (dyn_tilt_freq, dyn_tilt_slope)
  |
  v
[DryWetMixer blend] ← mix (0-100%)
  |
  v
[Output Gain]
  |
  v
Output
```

**Routing notes:**
- `pre_post` toggles processing order at processBlock time — both stages always prepared
- M/S encoding/decoding wraps both saturation and dynamics stages (both process in M/S simultaneously)
- Post-Saturation Tilt position is FIXED (always after saturation regardless of pre_post mode)
- Post-Dynamics Tilt position is FIXED (always after dynamics stage, before mix blend)
- DryWetMixer dry capture is ALWAYS post-input-gain, pre-everything-else
- Conditional bypasses for tilt filters when slope == 0 (no zero-crossing clicks — slope is smooth)

---

## System Architecture

### State Persistence

**What state is saved:**
- All 22 APVTS parameters (automatic via AudioProcessorValueTreeState)
- No custom non-APVTS state required (no folder paths, no file loading, no lock buttons)

**Serialization format:**
- APVTS parameters: Automatic XML via ValueTree

**JUCE classes:**
- `juce::AudioProcessorValueTreeState` - All parameter persistence (automatic)

**Save/restore methods (standard):**
- `getStateInformation(MemoryBlock& destData)` — copies APVTS state to XML binary
- `setStateInformation(const void* data, int sizeInBytes)` — restores from XML binary

**Restore behavior:**
- All parameters have defined defaults (in APVTS layout) — no missing state issues
- No file paths to validate
- On corrupted state: defaults loaded (standard APVTS behavior)

---

## Parameter Mapping

| Parameter ID    | Type  | Range              | Default | DSP Component              | Usage                                          |
|-----------------|-------|--------------------|---------|----------------------------|------------------------------------------------|
| drive           | Float | 0-100%             | 20      | ADAA Waveshaper            | Input gain into waveshaper (1x to 16x)         |
| even            | Float | 0-100%             | 0       | ADAA Waveshaper            | DC bias pre-waveshaper for even harmonics      |
| odd             | Float | 0-100%             | 0       | ADAA Waveshaper            | Cubic pre-distortion for odd harmonics         |
| h_curve         | Float | 0-100%             | 50      | ADAA Waveshaper            | Waveshaper curve morph (tanh → hard clip)      |
| pre_post        | Bool  | false/true         | false   | Routing Logic              | Signal flow: DYN→SAT (false) or SAT→DYN (true)|
| input           | Float | -48 to +10 dB      | 0       | Input Gain                 | Pre-chain gain stage                           |
| mix             | Float | 0-100%             | 100     | DryWetMixer                | Parallel dry/wet blend                         |
| output          | Float | -48 to +10 dB      | 0       | Output Gain                | Post-chain makeup gain                         |
| sat_tilt_freq   | Float | 100-10000 Hz       | 1000    | Post-Sat Tilt Filter       | Tilt pivot frequency after saturation          |
| sat_tilt_slope  | Float | -6 to +6 dB/oct    | 0       | Post-Sat Tilt Filter       | Tilt slope (0 = bypass)                        |
| dynamics        | Float | 0-100%             | 30      | Dynamics Engine            | Global dynamics amount macro                   |
| up              | Float | 0-100%             | 0       | Dynamics Engine            | Upward compression depth                       |
| down            | Float | 0-100%             | 50      | Dynamics Engine            | Downward compression depth                     |
| threshold       | Float | -40 to 0 dB        | -18     | Dynamics Engine            | Compressor threshold                           |
| ratio           | Float | 1-10:1             | 4       | Dynamics Engine            | Compression ratio                              |
| attack_time     | Float | 0.1-100 ms         | 10      | Dynamics Engine            | Compressor attack time                         |
| release_time    | Float | 10-1000 ms         | 100     | Dynamics Engine            | Compressor release time                        |
| dyn_tilt_freq   | Float | 100-10000 Hz       | 1000    | Post-Dyn Tilt Filter       | Tilt pivot frequency after dynamics            |
| dyn_tilt_slope  | Float | -6 to +6 dB/oct    | 0       | Post-Dyn Tilt Filter       | Tilt slope (0 = bypass)                        |
| ms_enable       | Bool  | false/true         | false   | M/S Matrix                 | Enable mid/side processing mode                |
| mid_drive       | Float | 0-100%             | 50      | ADAA Waveshaper (M/S)      | Mid channel saturation drive in M/S mode       |
| side_drive      | Float | 0-100%             | 50      | ADAA Waveshaper (M/S)      | Side channel saturation drive in M/S mode      |

---

## Algorithm Details

### ADAA Waveshaping (First-Order)

**Algorithm:** Antiderivative Anti-Aliasing for memoryless nonlinear waveshaping

**Core formula:**
- Let `f(x)` be the waveshaping function, `F1(x)` be its antiderivative
- For each sample: `y[n] = (F1(x[n]) - F1(x[n-1])) / (x[n] - x[n-1])`
- When |x[n] - x[n-1]| < 1e-5 (near-equal inputs): use `y[n] = f(x[n])` directly (fallback)
- Store `x[n-1]` per-channel (stateful between samples)

**Waveshaper variants with antiderivatives:**

For the tanh-based soft clipper (h_curve = 0-50%):
- `f_soft(x) = tanh(k * x)` where k = drive gain
- `F1_soft(x) = log(cosh(k * x)) / k`
- Note: `log(cosh(x))` can be computed as `log(0.5 * (e^x + e^-x))` for numerical stability

For the polynomial hard clipper (h_curve = 50-100%):
- `f_hard(x) = 1.5*x - 0.5*x^3` (cubic approximation — smooth analytical antiderivative)
- `F1_hard(x) = 0.75*x^2 - 0.125*x^4`
- For |x| >= 1: `f_hard(x) = sign(x)`, `F1_hard(x) = |x| - 0.375` (constant slope at clip)
- This avoids the `tanh` antiderivative dilogarithm complexity while still enabling ADAA

**Morphing (h_curve alpha parameter):**
- alpha = h_curve / 100.0 (0.0 = soft, 1.0 = hard)
- Blended waveshaper: `f_blend(x) = (1 - alpha) * f_soft(x) + alpha * f_hard(x)`
- Blended antiderivative: `F1_blend(x) = (1 - alpha) * F1_soft(x) + alpha * F1_hard(x)`
- Since antiderivative is linear: blending F1 is valid and produces correct ADAA for blended function

**Even harmonics (bias technique):**
- `x_in = x + bias` where `bias = (even / 100.0) * 0.15`
- Apply ADAA to `f_blend(x_in)` — asymmetric operating point creates even harmonics
- Apply 5Hz highpass post-waveshaper to remove DC: `juce::dsp::IIR::Coefficients<float>::makeHighPass(sampleRate, 5.0)`
- Previous-sample state tracks biased x[n-1]: `xPrev = x_in` (not unbiased x)

**Odd harmonics (cubic pre-distortion):**
- `x_in = x + (odd / 100.0) * 0.05 * x^3`
- This increases cubic content, which after waveshaping produces stronger 3rd/5th harmonics
- Applied before the bias: `x_full = x_odd + bias`

**Per-channel state:**
- `float xPrev[2]` — one per stereo channel, reset to 0 on prepareToPlay
- In M/S mode: `float xPrevMid`, `float xPrevSide` — independent states per M/S channel

**Implementation notes:**
- All per-sample math using `std::exp`, `std::log`, `std::cosh` — avoid JUCE SIMD for clarity first, optimize later
- The fallback condition (near-equal samples) must use `std::abs(delta) < 1e-5f` — not exact equality
- Drive gain normalization: output is divided by `tanh(driveGain)` for unity-reference soft clipper
- Use `juce::ScopedNoDenormals` in processBlock — waveshaping can produce denormals

### Dynamics Engine (Upward + Downward)

**Algorithm:** Dual-path compressor with shared level detector

**Level detection:**
```
// RMS envelope follower (per channel, then max across channels for linked detection)
levelSquared[n] = attackCoeff * levelSquared[n-1] + (1 - attackCoeff) * x[n]^2
level_dB = 10 * log10(levelSquared + 1e-9)  // 1e-9 floor prevents log(0)
```

**Program-dependent ballistics (crest factor):**
```
// Accumulate peak and RMS over 50ms window
crestFactor = peakLevel / (rmsLevel + 1e-9)
// High crest = transient content (attack < manual setting, faster response)
attackModifier = lerp(1.0, 0.5, saturate(crestFactor - 1.0, 0.0, 1.0))
effectiveAttack = manualAttack_ms * attackModifier
effectiveRelease = manualRelease_ms * lerp(1.0, 0.8, attackModifier)
attackCoeff = exp(-1.0 / (effectiveAttack * 0.001 * sampleRate))
releaseCoeff = exp(-1.0 / (effectiveRelease * 0.001 * sampleRate))
```

**Gain computer (downward):**
```
// Soft knee with 6dB knee width
halfKnee = 3.0  // dB
if (level_dB < threshold - halfKnee):
    gainReduction_dB = 0
elif (level_dB < threshold + halfKnee):
    // Soft knee blend
    gainReduction_dB = (1.0/ratio - 1.0) * (level_dB - threshold + halfKnee)^2 / (4.0 * halfKnee)
else:
    gainReduction_dB = (level_dB - threshold) * (1.0/ratio - 1.0)

// Scale by down and dynamics macro
gainReduction_dB *= (down / 100.0) * (dynamics / 100.0)
```

**Gain computer (upward):**
```
// Raises signals below threshold
if (level_dB < threshold):
    upwardGain_dB = (threshold - level_dB) * 0.3 * (up / 100.0) * (dynamics / 100.0)
else:
    upwardGain_dB = 0
```

**Gain smoothing:**
```
// One-pole ballistic smoother on gain value
targetGain_dB = gainReduction_dB + upwardGain_dB
if (targetGain_dB < currentGain_dB):
    currentGain_dB = attackCoeff * currentGain_dB + (1 - attackCoeff) * targetGain_dB
else:
    currentGain_dB = releaseCoeff * currentGain_dB + (1 - releaseCoeff) * targetGain_dB
appliedGain = Decibels::decibelsToGain(currentGain_dB)
```

### Tilt Filter (Post-Sat + Post-Dyn)

**Algorithm:** Complementary low/high shelving filter pair

**Implementation:**
```
// High shelf (brighter above pivot)
highGain_dB = slope * 6.0   // +/-6 dB/oct maps to +/-36dB shelf, clamp to +/-12dB
lowGain_dB = -slope * 6.0   // complementary, opposite polarity

// JUCE IIR shelf creation
highShelfCoeffs = juce::dsp::IIR::Coefficients<float>::makeHighShelf(
    sampleRate, freq, 0.707f, Decibels::decibelsToGain(highGain_dB));
lowShelfCoeffs = juce::dsp::IIR::Coefficients<float>::makeLowShelf(
    sampleRate, freq, 0.707f, Decibels::decibelsToGain(lowGain_dB));

// Apply: lowShelf then highShelf in series
```

**Bypass condition:** `if (std::abs(slope) < 0.01f) { bypass = true; }`

**Coefficient update policy:** Update on parameter change only (use `std::atomic<bool> needsCoeffUpdate` flag, set from message thread, read in audio thread)

### M/S Matrix

**Algorithm:** Standard sum-and-difference matrix

**Encoding (L/R → M/S):**
```
mid  = (left + right) * 0.5f;
side = (left - right) * 0.5f;
```

**Decoding (M/S → L/R):**
```
left  = mid + side;
right = mid - side;
```

Note: Factor of 0.5 at encoding ensures decoded L/R has same amplitude as original. This is the gain-corrected version (some implementations use factor 1.0 at encode and 0.5 at decode — equivalent).

---

## Integration Points

### Feature Dependencies

- Input Gain → M/S Encoder: Input gain applied first before any channel splitting
- M/S Encoder → Saturation: When M/S active, saturation receives mid/side channels (not L/R)
- M/S Encoder → Dynamics: When M/S active, dynamics receives mid/side channels
- Saturation → Post-Sat Tilt: Tilt filters process the saturated signal (always, regardless of pre_post)
- Dynamics → Post-Dyn Tilt: Tilt filters process the compressed signal (always, after dynamics)
- Pre_Post Toggle → Processing Order: Controls whether Dynamics or Saturation executes first
- Post-Dyn Tilt → DryWetMixer: Tilt output feeds the wet side of the dry/wet mix
- DryWetMixer → Output Gain: Final output gain applied after blend
- All stages → M/S Decoder: Decoder must execute after complete saturation+dynamics chain in M/S mode

### Parameter Interactions

- `dynamics` macro × `down`/`up`: dynamics scales the effect of both up and down parameters multiplicatively. At dynamics=0, no compression occurs regardless of up/down settings.
- `drive` + `h_curve`: These interact on the waveshaping curve. High drive into hard-clip h_curve produces aggressive hard distortion; high drive into soft h_curve produces heavy but musical saturation.
- `even` + `odd` + ADAA: Both even and odd modifications occur before ADAA processing. Both modifications must maintain ADAA-tractable waveforms (no discontinuities).
- `ms_enable` × `mid_drive`/`side_drive`: mid_drive and side_drive replace the global drive only when ms_enable is active. When ms_enable is false, mid_drive and side_drive have no effect.
- `sat_tilt_slope` near 0: Smooth zero-crossing — no click or mode switch. The tilt simply flattens to unity at slope=0.
- `pre_post` × tilt filter positions: Post-Sat Tilt is always between saturation and the output regardless of pre_post. Post-Dyn Tilt is always after dynamics. Changing pre_post only moves dynamics relative to saturation — tilt filter positions are fixed relative to their named stage.
- `attack_time` + program-dependent: Manual attack_time sets the baseline; program content (crest factor) can shorten it but never lengthen beyond the manual value.

### Processing Order Requirements

**DYN→SAT mode (pre_post == false):**

1. **Input Gain:** Apply first — establishes level before analysis
2. **Dry capture:** Capture post-input-gain signal for dry/wet — must happen before any processing
3. **M/S Encode (if enabled):** Split before both processing stages
4. **Dynamics Engine:** Analyzes and compresses signal — shapes what hits saturation
5. **ADAA Saturation:** Operates on compressed signal
6. **Post-Saturation Tilt:** Colors harmonic content after saturation
7. **M/S Decode (if enabled):** Reconstruct stereo after both stages complete
8. **Post-Dynamics Tilt:** Final tone shaping (placed after dynamics, so always after decode)
9. **DryWetMixer blend:** Blend with captured dry signal
10. **Output Gain:** Final level adjustment

**SAT→DYN mode (pre_post == true):**

1. Input Gain
2. Dry capture
3. M/S Encode (if enabled)
4. **ADAA Saturation** (moved before dynamics)
5. **Post-Saturation Tilt** (still after saturation)
6. **Dynamics Engine** (moved after saturation + tilt)
7. M/S Decode (if enabled)
8. Post-Dynamics Tilt
9. DryWetMixer blend
10. Output Gain

**Note on M/S decode timing:** In both modes, M/S decode happens after the second processing stage completes. This ensures both saturation and dynamics have processed M/S channels independently.

**Parallel processing:**
- Dynamics Engine and ADAA Saturation run sequentially (not parallel) — pre_post determines order
- Post-Sat Tilt and Post-Dyn Tilt could theoretically run in parallel but sequential is simpler and correct

### Thread Boundaries

**Audio thread (processBlock):**
- All DSP computation: input gain, M/S matrix, ADAA waveshaping, dynamics, tilt filters, dry/wet mix, output gain
- ADAA state reads/writes: `xPrev[channel]` (per-sample, audio thread only)
- Dynamics state reads/writes: `levelSquared`, `currentGain_dB`, `crestFactor` buffers
- Parameter reads: `parameters.getRawParameterValue("X")->load()` (atomic reads)
- Tilt coefficient check: `needsCoeffUpdate.load()` — if true, recompute and clear flag

**Message thread (UI callbacks):**
- APVTS parameter writes from WebView controls
- Parameter change notification triggers coeff update flags (not recomputed here)
- `needsSatTiltUpdate.store(true)` — set when sat_tilt_freq/slope change
- `needsDynTiltUpdate.store(true)` — set when dyn_tilt_freq/slope change

**No background thread:**
- No file I/O (no samples, no presets, no folder scanning)
- All operations are real-time compatible

**Communication mechanisms:**
- APVTS parameters: Atomic reads (audio thread) / atomic writes (message thread)
- Tilt coefficient update flags: `std::atomic<bool> needsSatTiltUpdate`, `std::atomic<bool> needsDynTiltUpdate`
- ADAA state: Audio thread private (no cross-thread access)
- Dynamics state: Audio thread private (no cross-thread access)

**Safety guarantees:**
- No allocations in processBlock (all buffers pre-allocated in prepareToPlay)
- No locks in processBlock
- Tilt coefficient update is read-then-write on audio thread (single thread for state mutation)
- IIR filter coefficient struct is updated atomically via `ProcessorDuplicator<>::coefficients` pointer

---

## Implementation Risks

### ADAA Waveshaping Engine

**Complexity:** HIGH

**Risk Level:** HIGH

**Risk factors:**
1. ADAA requires analytically correct antiderivative of the waveshaping function — mathematical precision required
2. Near-singularity case (x[n] ≈ x[n-1]) must be handled to prevent division by near-zero producing NaN/Inf
3. Morphing between tanh (soft) and polynomial (hard) shapes must maintain antiderivative validity
4. Even harmonic bias + odd harmonic cubic pre-distortion both alter the input before ADAA — careful composition required
5. DC bias for even harmonics can accumulate over time if highpass isn't correctly implemented
6. Per-channel ADAA state (xPrev) must be correctly reset on prepareToPlay and channel count changes
7. No existing JUCE class — fully custom implementation

**Alternative approaches:**
1. **Simple tanh without ADAA + 2x oversampling:**
   - Complexity: LOW
   - CPU: Approximately 2x higher than ADAA at 1x sample rate
   - Quality: Similar aliasing suppression with 2x OS
   - Tradeoff: Adds ~1-2ms latency from oversampling filter
   - When to use: If ADAA implementation proves too complex

2. **ADAA with only tanh (no polynomial blend):**
   - Complexity: MEDIUM
   - Drop h_curve entirely, use single tanh shape
   - Even/odd parameter independence still implementable via bias
   - Reduces code complexity significantly

3. **Table-lookup ADAA:**
   - Precompute F1(x) in a lookup table, interpolate at runtime
   - Complexity: MEDIUM
   - Avoids analytical antiderivative computation for complex shapes
   - Accuracy slightly lower than analytical but very acceptable

**Fallback architecture:**
- **Primary:** Custom ADAA with tanh-polynomial blend
- **Fallback 1:** If morphing ADAA fails → ADAA with fixed tanh only (drop h_curve, reduce scope)
- **Fallback 2:** If ADAA implementation has stability issues → 2x oversampled tanh (adds latency but simpler)
- **Fallback 3:** If all else fails → Simple polynomial waveshaper without anti-aliasing (academic result but functional)

**Mitigation strategy:**
1. Reference Jatin Chowdhury's ADAA repository (https://github.com/jatinchowdhury18/ADAA) for correct implementation patterns
2. Implement and test ADAA in isolation (unit test with 1kHz sine at high drive, verify no aliasing spikes)
3. Handle near-singularity case with conservative epsilon (1e-5) — test with DC input and slow-sweep sine
4. Validate antiderivative mathematically: `d/dx F1(x) ≈ f(x)` — numerical finite-difference test

### Upward Compression

**Complexity:** HIGH

**Risk Level:** MEDIUM

**Risk factors:**
1. `juce::dsp::Compressor<float>` only covers downward compression — upward requires custom implementation
2. Upward compression can cause pumping artifacts if attack/release too fast
3. Combined upward + downward gain computer must not double-apply macro dynamics
4. Interaction with post-saturation signal: upward compression may amplify noise floor artifacts from saturation

**Alternative approaches:**
1. **Downward-only compression (drop upward):**
   - Complexity: LOW — use `juce::dsp::Compressor<float>` directly
   - Drop the `up` parameter (default to 0 — no behavioral change if up=0)
   - Significantly simpler implementation
   - When to use: If custom upward compression causes artifacts or instability

2. **Upward compression via expansion below threshold:**
   - Implement as a downward expander inverted — expand signals below threshold upward
   - Complexity: MEDIUM
   - Alternative mathematical formulation, same sonic result

**Fallback architecture:**
- **Primary:** Custom dual compressor (upward + downward)
- **Fallback:** Drop upward compression — `up` parameter always 0, document as "reserved for future"
- **Condition:** Fall back if upward compression introduces significant pumping or noise amplification

**Mitigation strategy:**
1. Implement downward compression first and test thoroughly
2. Add upward compression as a separately testable module
3. Set upward compression ratio low (0.3 fixed) to avoid excessive gain
4. Add output limiter at +3dB to prevent clipping from upward compression gain

### Program-Dependent Ballistics

**Complexity:** MEDIUM

**Risk Level:** MEDIUM

**Risk factors:**
1. Crest factor analysis adds per-block computation (50ms window = ~2400 samples at 48kHz)
2. Crest factor smoothing (200ms) adds state that must be managed across prepareToPlay calls
3. Risk of overactive ballistics causing unnatural pumping on musical material

**Alternative approaches:**
1. **Fixed ballistics (drop program-dependent behavior):**
   - Simply use manual attack/release values directly
   - Complexity: LOW
   - Removes the sonic differentiation from program-dependent behavior
   - When to use: If auto-ballistics produces unwanted artifacts

2. **Simpler auto-release only (like LA-2A style):**
   - Fixed attack, variable release based on signal content
   - Complexity: LOW-MEDIUM
   - Historically accurate approach (many hardware compressors do this)

**Fallback architecture:**
- **Primary:** Full program-dependent attack + release
- **Fallback:** Fixed manual ballistics only (attack_time and release_time used directly)
- **Condition:** Fall back if crest factor analysis causes noticeable processing artifacts

### Pre/Post Signal Routing

**Complexity:** MEDIUM

**Risk Level:** LOW

**Risk factors:**
1. Conditional routing at processBlock time requires careful buffer management
2. Both stages (saturation + dynamics) must be prepared/active simultaneously regardless of pre_post
3. M/S encode/decode must correctly wrap both stages in both modes

**Alternative approaches:**
- No alternative — conditional routing is the core feature. Implement as documented.

**Fallback architecture:**
- None needed — routing logic is low-risk boolean switch on processing order

### M/S Processing

**Complexity:** MEDIUM

**Risk Level:** LOW

**Risk factors:**
1. M/S matrix math is simple — low implementation risk
2. Main risk: Forgetting to decode before post-dynamics tilt (incorrect decode placement)
3. Side channel can become very loud if saturation increases side content excessively

**Alternative approaches:**
- Full stereo processing only (drop M/S) — significantly simpler
- When to use: Only if M/S causes severe phase or stereo width artifacts

**Fallback architecture:**
- **Primary:** Full M/S matrix with independent saturation per channel
- **Fallback:** Drop M/S mode entirely (ms_enable always false) — ms_enable, mid_drive, side_drive become no-ops

### Tilt Filters

**Complexity:** LOW

**Risk Level:** LOW

**Risk factors:**
1. IIR coefficient computation must be thread-safe (audio thread updates based on parameter changes)
2. Extreme slope values (+/-6 dB/oct) with broad shelves may interact unexpectedly with program material

**Alternative approaches:**
- None needed — tilt filter implementation is standard and well-understood

**Fallback architecture:**
- Remove both tilt filters entirely (always bypass) — no behavioral change if slope=0 default

### Overall Project Risk

**Overall complexity:** HIGH
- ADAA custom implementation (HIGH) + dual compression (HIGH) + M/S processing (MEDIUM) + conditional routing (MEDIUM) = significant engineering challenge

**Highest risk component:** ADAA Waveshaping Engine
- Represents approximately 60% of implementation risk
- No JUCE class — fully custom
- Mathematical precision required
- Multiple interacting parameters (drive, even, odd, h_curve)

**Recommended implementation approach:**
1. Phase 1 — Core saturation (ADAA with drive only, no harmonics or curve morph): Validate ADAA correctness
2. Phase 2 — Harmonic controls (even/odd bias): Add on validated ADAA foundation
3. Phase 3 — Curve morph (h_curve): Add polynomial blend with validated antiderivative
4. Phase 4 — Dynamics engine (downward only): Build and test independently
5. Phase 5 — Upward compression + program-dependent ballistics: Add complexity incrementally
6. Phase 6 — Routing, M/S, tilt filters: Lower-risk features added after core DSP validated

---

## Architecture Decisions

### ADAA Over Oversampling

**Decision:** Implement custom ADAA anti-aliasing rather than using JUCE's `juce::dsp::Oversampling`

**Rationale:**
- ADAA is the plugin's core technical differentiator and marketing feature
- ADAA operates at 1x sample rate with no latency overhead
- Oversampling (2x-16x) adds latency and CPU cost — contrary to the creative brief vision
- ADAA was feasible for tanh-polynomial blend class of waveshapers (antiderivatives available)

**Alternatives considered:**
1. **JUCE dsp::Oversampling (2x):**
   - Why rejected: Adds ~0.7ms latency at 48kHz, 2x CPU cost, contradicts product vision
   - When to reconsider: If ADAA proves numerically unstable or too complex to implement correctly

2. **No anti-aliasing:**
   - Why rejected: Audible aliasing artifacts at drive > 30%, especially above 4kHz — not mastering-grade

3. **Band-limited step function (BLEP) based approach:**
   - Why rejected: BLEP is designed for discontinuities (oscillators), not smooth waveshapers — wrong tool

**Tradeoffs accepted:**
- Higher implementation complexity: ADAA requires custom code with precise math vs. `dsp::Oversampling` being a one-liner
- Limited to analytical waveshapers: Cannot use arbitrary lookup table waveshaping without interpolation-based ADAA extension
- Second-order ADAA skipped: First-order provides sufficient aliasing suppression for the target waveshaper shapes

### Polynomial Hard Clip vs. Tanh for Hard Curve

**Decision:** Use cubic polynomial `f(x) = 1.5x - 0.5x^3` as the hard-clip shape (not true hard-clip `f(x) = clip(x, -1, 1)`)

**Rationale:**
- True hard-clip has a discontinuous derivative at x = ±1, making ADAA numerically problematic near clipping threshold
- Cubic polynomial is smooth (infinitely differentiable), has an exact analytical antiderivative, ADAA-tractable
- Cubic polynomial sounds nearly identical to hard-clip at high drive but without ADAA edge cases
- At very high gain, the cubic polynomial approximates hard-clip behavior

**Alternatives considered:**
1. **True hard-clip with ADAA:** Requires piecewise antiderivative with careful boundary handling at ±1
   - Why rejected: Implementation complexity and edge case risk at the clipping boundary
   - When to reconsider: If cubic polynomial doesn't satisfy "aggressive hard-clip" sound requirement at 100%

**Tradeoffs accepted:**
- Slightly softer than true hard-clip at extreme settings — acceptable given ADAA requirement
- Users expecting "brick wall" clipping may notice subtle difference — mitigated by high drive gain factor

### Linked Stereo Detection for Dynamics

**Decision:** Use linked stereo level detection (max of L/R channels) rather than independent per-channel detection

**Rationale:**
- Independent L/R detection causes gain differences between channels — creates stereo imbalance (pumping image)
- Linked detection maintains stereo image while still applying dynamics to full signal
- Industry standard for mastering compressors (SSL, Neve console compressors all use linked detection)
- M/S mode already provides independent channel control when needed

**Alternatives considered:**
1. **Dual-mono detection:** Independent gain reduction per channel
   - Why rejected: Stereo image instability — gain differences between L/R cause image wander
   - When to use: Only in M/S mode (where mid and side are intentionally processed independently)

### h_curve as Polynomial Blend (Not Filter-Based Shape)

**Decision:** h_curve morphs between two waveshaper functions via direct algebraic blending

**Rationale:**
- Direct blending of F1 antiderivatives is mathematically valid (antiderivative of blend = blend of antiderivatives, given both are antiderivatives of their respective functions)
- Alternative approach (dynamic gain into a single waveshaper) doesn't give the same knee control
- Blending keeps the ADAA framework intact without special cases

**Alternatives considered:**
1. **Gain-based approach:** Increase input gain to make tanh progressively harder
   - Why rejected: Does not actually change the shape of the knee — just drives deeper into the saturation curve
   - High gain tanh approaches hard-clip asymptotically but the morphing isn't as controlled

---

## Special Considerations

### Thread Safety

- All parameter reads use `parameters.getRawParameterValue("X")->load()` (atomic load)
- ADAA state (`xPrev`) is per-channel, audio thread only — no cross-thread access
- Dynamics state (level detector, gain smoother) is audio thread only — no cross-thread access
- Tilt coefficient updates: `std::atomic<bool>` flags set on message thread, read/cleared on audio thread
- IIR filter coefficient pointers in JUCE `ProcessorDuplicator` are updated atomically

### Performance

Estimated CPU usage at 48kHz, stereo, 512-sample buffer:

| Component            | Estimated CPU |
|----------------------|---------------|
| Input Gain           | < 1%          |
| M/S Matrix           | < 1%          |
| ADAA Waveshaper      | 5-8%          |
| Post-Sat Tilt        | 2-3%          |
| Dynamics Engine      | 4-6%          |
| Post-Dyn Tilt        | 2-3%          |
| DryWetMixer          | < 1%          |
| Output Gain          | < 1%          |
| **Total estimated**  | **~15-25%**   |

- ADAA is the most CPU-intensive custom component (transcendental functions per sample)
- Consider `juce::Approximations::tanh` or lookup-table tanh if CPU proves high
- Tilt filters are standard biquad IIR — very low CPU when coefficients are cached
- Crest factor analysis (crest window accumulation) adds minor per-block overhead

### Denormal Protection

- `juce::ScopedNoDenormals noDenormals` at top of processBlock
- ADAA accumulates small values (xPrev can approach zero) — denormal protection critical
- Dynamics level detector accumulates squared values — can hit denormal range on silence
- Add DC offset floor to dynamics level detector: `levelSquared = max(levelSquared, 1e-9f)`
- All JUCE DSP components (IIR filters, DryWetMixer) handle denormals via their internal reset logic

### Sample Rate Handling

- ADAA state (`xPrev`) reinitialized to 0 in `prepareToPlay` — no sample-rate-dependent calculation
- Dynamics ballistic coefficients recalculated in `prepareToPlay`:
  - `attackCoeff = exp(-1.0 / (attack_ms * 0.001 * sampleRate))`
  - `releaseCoeff = exp(-1.0 / (release_ms * 0.001 * sampleRate))`
- Crest factor window size (in samples) recalculated: `crestWindowSamples = (int)(0.050 * sampleRate)`
- Tilt filter IIR coefficients include sampleRate — must be recomputed in prepareToPlay
- Dry signal delay in DryWetMixer accounts for latency — recomputed in prepareToPlay
- `prepareToPlay` must call `prepare(spec)` on all JUCE DSP components before use

### Latency

- ADAA: Zero added latency (1x sample rate processing, no buffering)
- Dynamics: Zero added latency (single-sample ballistic processing, no lookahead)
- Tilt filters: Zero added latency (IIR filters, no lookahead)
- DryWetMixer: Zero added latency when latency = 0 (no oversampling delay compensation needed)
- **Total reported latency: 0 samples** — `getLatencySamples()` returns 0
- This is a key product feature (no latency compensation required by host)

---

## Research References

### Professional Plugins

1. **FabFilter Saturn 2**
   - Multiband distortion/saturation with transformer, tube, and amp algorithms
   - Three separate transformer saturation types — confirms transformer harmonic character is viable and valued
   - Even/odd harmonic distinction implemented as selectable distortion styles
   - Independent drive per band (multiband) — parallel to M/S independent drive concept

2. **Soundtoys Decapitator (N mode - Neve 1057)**
   - Specific Neve preamp emulation saturation mode
   - Dark, thick harmonic character with even harmonics dominating
   - Drive (Punish) + tone control (Cut) — similar to drive + tilt concept

3. **SSL Fusion (Vintage Drive)**
   - Mastering-grade saturation processor with Drive + Density controls
   - Non-linear harmonic enhancement circuit with "soft compression" character
   - Confirms saturation + dynamics combination is a recognized mastering approach

4. **Kush Omega (Model N)**
   - Dark, thick, harmonically rich Neve-style transformer saturation
   - Even harmonics for warmth, odd for grit — same harmonic separation concept

5. **Waves NLS / Slate VCC (Neve modes)**
   - Console-style transformer saturation for mix glue
   - Smooth distortion that adds harmonic density without dramatic level change

### ADAA Technical References

- **Jatin Chowdhury ADAA repository:** https://github.com/jatinchowdhury18/ADAA
  - Practical C++ implementations of first and second order ADAA
  - tanh + hard-clip implementations with JUCE framework
- **Parker, Zavalishin, Le Bivic (DAFx-16):** "Reducing the Aliasing of Nonlinear Waveshaping Using Continuous-Time Convolution"
  - Original ADAA paper — defines antiderivative formulation
- **CCRMA notebook on ADAA:** https://ccrma.stanford.edu/~jatin/Notebooks/adaa.html
  - Practical implementation considerations, numerical stability tips
- **Apulsoft blog on tanh antiderivatives:** https://apulsoft.ch/blog/tanh-antiderivatives/
  - Numerical stability considerations for log(cosh(x)) computation
- **DAFx 2023 paper on piecewise polynomial ADAA:** https://dafx.de/paper-archive/2023/DAFx23_paper_61.pdf
  - Polynomial waveshaping with ADAA — directly applicable to h_curve polynomial blend

### Dynamics References

- **JUCE forum: Program-dependent compressor:** https://forum.juce.com/t/programm-dependent-attack-and-release-time-compressor/23842
- **CTAGDRC GitHub (JUCE compressor reference):** https://github.com/p-hlp/CTAGDRC
  - Open-source JUCE compressor with complete implementation (RMS detection, attack/release ballistics)

### Tilt Filter References

- **Musicdsp.org tilt equalizer:** https://www.musicdsp.org/en/latest/Filters/267-simple-tilt-equalizer.html
  - Simple complementary shelf implementation
- **JUCE DSP IIR Coefficient helpers:** `juce::dsp::IIR::Coefficients<float>::makeLowShelf/makeHighShelf`

### JUCE Documentation
- **juce::dsp::IIR::Filter** — Biquad filter (juce_dsp module)
- **juce::dsp::IIR::Coefficients** — Coefficient factory with shelf helpers (juce_dsp module)
- **juce::dsp::DryWetMixer** — Parallel dry/wet blend with latency compensation (juce_dsp module)
- **juce::dsp::Gain** — Smoothed gain stage (juce_dsp module)
- **juce::LinearSmoothedValue** — Smooth parameter value changes (juce_audio_basics module)
- **juce::dsp::ProcessorDuplicator** — Applies processor to each channel (juce_dsp module)
- **juce::ScopedNoDenormals** — Denormal protection in audio thread (juce_audio_basics module)

---

## JUCE Module Dependencies

| Component                    | JUCE Class / API                               | Module Required      |
|------------------------------|------------------------------------------------|----------------------|
| Input/Output Gain            | `juce::dsp::Gain<float>`                       | `juce_dsp`           |
| ADAA (custom)                | `std::exp`, `std::log`, `std::cosh`, math only | No JUCE DSP needed   |
| DC Highpass                  | `juce::dsp::IIR::Filter<float>`                | `juce_dsp`           |
| Tilt Filters (x2 per stage)  | `juce::dsp::IIR::Coefficients<float>`          | `juce_dsp`           |
| Tilt Filters (stereo)        | `juce::dsp::ProcessorDuplicator`               | `juce_dsp`           |
| DryWetMixer                  | `juce::dsp::DryWetMixer<float>`                | `juce_dsp`           |
| Smoothed Values              | `juce::LinearSmoothedValue<float>`             | `juce_audio_basics`  |
| Denormal protection          | `juce::ScopedNoDenormals`                      | `juce_audio_basics`  |
| Parameter state              | `juce::AudioProcessorValueTreeState`           | `juce_audio_processors` |
| Bus config                   | `BusesProperties`                              | `juce_audio_processors` |
| WebView UI                   | `juce::WebBrowserComponent`                    | `juce_gui_extra`     |
| Parameter relays             | `juce::WebSliderRelay`, `juce::WebToggleButtonRelay` | `juce_gui_extra` |

**Required CMake modules:**
```cmake
target_link_libraries(NBS_DynaDrive
    PRIVATE
        juce::juce_audio_processors
        juce::juce_audio_basics
        juce::juce_dsp
        juce::juce_gui_extra
        NBS_DynaDrive_UIResources
)
```

---

## Notes

- The v8-integration-checklist.md in mockups/ provides the GUI integration checklist including WebView relay setup for all 22 parameters. The template PluginEditor.h and PluginEditor.cpp files are already present in mockups/.
- The `WebToggleButtonRelay` + `WebToggleButtonParameterAttachment` pattern must be used for `pre_post` and `ms_enable` (bool parameters) — not WebSliderRelay.
- `sat_tilt_freq` and `dyn_tilt_freq` should use NormalisableRange with logarithmic skew in APVTS for perceptually linear knob feel.
- `attack_time` and `release_time` should use NormalisableRange with logarithmic skew for perceptually linear response.
- The ADAA `xPrev` state must be reset to 0 in prepareToPlay — NOT in the constructor (prepareToPlay may be called multiple times with different configurations).
- If `pre_post` changes mid-playback, the dynamics and saturation states continue from their current values — no reset needed (continuity is correct and avoids clicks).
- M/S enable changes mid-playback: M/S state transition is handled gracefully because M/S encoding/decoding is stateless (no per-sample state in matrix math).
