<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>LushPad UI Mockup v1</title>

  <style>
    /* CRITICAL: WebView constraints */
    html, body {
      height: 100%;  /* REQUIRED - replaces viewport units */
      margin: 0;
      padding: 0;
    }

    *, *::before, *::after {
      box-sizing: border-box;
    }

    body {
      /* Native application feel */
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      -webkit-touch-callout: none;
      cursor: default;
      overflow: hidden;

      /* Warm cream gradient background */
      background: linear-gradient(135deg, #d4c4b0 0%, #b8a690 100%);

      /* Typography */
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      color: #6b5846;
    }

    .container {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    /* Plugin title */
    .title {
      position: absolute;
      top: 25px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 20px;
      font-weight: 300;
      letter-spacing: 0.5px;
      color: #6b5846;
    }

    /* Controls container */
    .controls {
      display: flex;
      gap: 48px;
      align-items: center;
      justify-content: center;
      margin-top: 20px;
    }

    /* Knob container */
    .knob-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
      position: relative;
    }

    /* Modulation glow (behind knob) */
    .modulation-glow {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 120px;
      height: 120px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(165, 136, 112, 0.3) 0%, rgba(165, 136, 112, 0) 70%);
      animation: pulse 3s ease-in-out infinite;
      pointer-events: none;
      z-index: 0;
    }

    @keyframes pulse {
      0%, 100% {
        opacity: 0.4;
        transform: translate(-50%, -50%) scale(1);
      }
      50% {
        opacity: 0.7;
        transform: translate(-50%, -50%) scale(1.1);
      }
    }

    /* Knob wrapper (neomorphic effect) */
    .knob-wrapper {
      position: relative;
      width: 100px;
      height: 100px;
      border-radius: 50%;
      background: linear-gradient(145deg, #e8dcc8, #d9cbb5);
      box-shadow:
        6px 6px 12px rgba(0, 0, 0, 0.15),
        -6px -6px 12px rgba(255, 255, 255, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 200ms ease-out;
      z-index: 1;
    }

    .knob-wrapper:active {
      transform: scale(0.95);
      box-shadow:
        3px 3px 6px rgba(0, 0, 0, 0.15),
        -3px -3px 6px rgba(255, 255, 255, 0.5);
    }

    /* Knob inner (rotary control) */
    .knob {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: linear-gradient(145deg, #d4c2ae, #c4b19d);
      box-shadow:
        inset 4px 4px 8px rgba(0, 0, 0, 0.15),
        inset -4px -4px 8px rgba(255, 255, 255, 0.5);
      position: relative;
      cursor: pointer;
      transition: transform 50ms ease-out;
    }

    /* Knob indicator (shows rotation) */
    .knob-indicator {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      width: 3px;
      height: 15px;
      background: linear-gradient(180deg, #8c6d54, #a58870);
      border-radius: 2px;
    }

    /* Label below knob */
    .knob-label {
      font-size: 14px;
      font-weight: 300;
      letter-spacing: 0.5px;
      color: #7a6652;
      text-align: center;
    }

    /* Value display (hidden in final design, shown for testing) */
    .knob-value {
      font-size: 11px;
      font-weight: 400;
      color: #8c6d54;
      text-align: center;
      margin-top: -5px;
      opacity: 0.6;
    }

    /* Texture overlay (minimal) */
    .texture-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: repeating-linear-gradient(
        45deg,
        transparent,
        transparent 2px,
        rgba(0, 0, 0, 0.03) 2px,
        rgba(0, 0, 0, 0.03) 4px
      );
      pointer-events: none;
      z-index: 10;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="texture-overlay"></div>

    <div class="title">LushPad</div>

    <div class="controls">
      <!-- Timbre Knob -->
      <div class="knob-container">
        <div class="modulation-glow"></div>
        <div class="knob-wrapper">
          <div class="knob" id="timbre" data-value="0.35" data-min="0" data-max="1">
            <div class="knob-indicator"></div>
          </div>
        </div>
        <div class="knob-label">Timbre</div>
        <div class="knob-value" id="timbre-value">0.35</div>
      </div>

      <!-- Filter Cutoff Knob -->
      <div class="knob-container">
        <div class="modulation-glow"></div>
        <div class="knob-wrapper">
          <div class="knob" id="filter_cutoff" data-value="2000" data-min="20" data-max="20000">
            <div class="knob-indicator"></div>
          </div>
        </div>
        <div class="knob-label">Filter Cutoff</div>
        <div class="knob-value" id="filter_cutoff-value">2000 Hz</div>
      </div>

      <!-- Reverb Amount Knob -->
      <div class="knob-container">
        <div class="modulation-glow"></div>
        <div class="knob-wrapper">
          <div class="knob" id="reverb_amount" data-value="0.4" data-min="0" data-max="1">
            <div class="knob-indicator"></div>
          </div>
        </div>
        <div class="knob-label">Reverb Amount</div>
        <div class="knob-value" id="reverb_amount-value">0.40</div>
      </div>
    </div>
  </div>

  <script>
    // Mock JUCE backend for browser testing
    window.Juce = {
      getSliderState: (id) => ({
        normalisedValue: 0.5,
        valueChangedEvent: {
          addListener: (fn) => console.log(`[JUCE] Listener added for ${id}`)
        },
        setNormalisedValue: (value) => console.log(`[JUCE] ${id} set to ${value}`)
      })
    };

    // Disable context menu (REQUIRED)
    document.addEventListener("contextmenu", (e) => {
      e.preventDefault();
      return false;
    });

    // Disable drag behaviors
    document.addEventListener("dragstart", (e) => {
      e.preventDefault();
    });

    // Knob interaction logic
    document.addEventListener("DOMContentLoaded", () => {
      const knobs = document.querySelectorAll(".knob");

      knobs.forEach((knob) => {
        const id = knob.id;
        const min = parseFloat(knob.dataset.min);
        const max = parseFloat(knob.dataset.max);
        const initialValue = parseFloat(knob.dataset.value);
        const indicator = knob.querySelector(".knob-indicator");
        const valueDisplay = document.getElementById(`${id}-value`);

        let isDragging = false;
        let startY = 0;
        let startValue = initialValue;

        // Get normalized value (0-1)
        const getNormalized = (value) => {
          return (value - min) / (max - min);
        };

        // Get actual value from normalized (0-1)
        const getActualValue = (normalized) => {
          return min + normalized * (max - min);
        };

        // Update knob rotation and display
        const updateKnob = (value) => {
          const normalized = getNormalized(value);
          const degrees = -135 + (normalized * 270); // -135Â° to +135Â° range
          indicator.style.transform = `translateX(-50%) rotate(${degrees}deg)`;
          indicator.style.transformOrigin = "center bottom";

          // Update value display
          if (id === "filter_cutoff") {
            valueDisplay.textContent = `${Math.round(value)} Hz`;
          } else {
            valueDisplay.textContent = value.toFixed(2);
          }

          knob.dataset.value = value;
        };

        // Initialize knob position
        updateKnob(initialValue);

        // Mouse down
        knob.addEventListener("mousedown", (e) => {
          isDragging = true;
          startY = e.clientY;
          startValue = parseFloat(knob.dataset.value);
          console.log(`[UI] Started dragging ${id}`);
        });

        // Mouse move
        document.addEventListener("mousemove", (e) => {
          if (!isDragging) return;

          const deltaY = startY - e.clientY; // Inverted (up = increase)
          const sensitivity = 0.005;
          const normalizedDelta = deltaY * sensitivity;

          let newNormalized = getNormalized(startValue) + normalizedDelta;
          newNormalized = Math.max(0, Math.min(1, newNormalized)); // Clamp 0-1

          const newValue = getActualValue(newNormalized);
          updateKnob(newValue);

          // Notify mock JUCE backend
          const state = Juce.getSliderState(id);
          state.setNormalisedValue(newNormalized);
        });

        // Mouse up
        document.addEventListener("mouseup", () => {
          if (isDragging) {
            console.log(`[UI] Stopped dragging ${id} at ${knob.dataset.value}`);
            isDragging = false;
          }
        });

        // Bind to JUCE backend (for automation/preset recall)
        const state = Juce.getSliderState(id);
        state.valueChangedEvent.addListener((newNormalized) => {
          const newValue = getActualValue(newNormalized);
          updateKnob(newValue);
          console.log(`[JUCE â†’ UI] ${id} updated to ${newValue}`);
        });
      });

      console.log("âœ… LushPad UI mockup v1 initialized");
      console.log("ðŸ’¡ Drag knobs vertically to adjust values");
      console.log("ðŸŽ¨ Neomorphic design with subtle modulation glow");
    });
  </script>
</body>
</html>
