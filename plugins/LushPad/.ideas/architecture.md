# DSP Architecture: LushPad

**CRITICAL CONTRACT:** This specification is immutable during Stages 2-5 implementation. Stage 1 Planning cannot proceed without this file. Stage 3 (DSP) implements this exact architecture.

**Generated by:** Stage 0 Research (research-planning-agent)
**Generated date:** 2025-11-13
**Referenced by:** Stage 1 (Planning), Stage 3 (DSP Implementation)
**Purpose:** DSP specification defining processing components, signal flow, and JUCE module usage

---

## Core Components

### Voice Management System
- **JUCE Class:** Custom implementation
- **Purpose:** Manage 8 polyphonic voices with MIDI note allocation
- **Parameters Affected:** All (via voice-level processing)
- **Configuration:**
  - 8 simultaneous voices maximum
  - Note-on triggers voice allocation (oldest-note-stealing if all busy)
  - Note-off triggers envelope release
  - Each voice maintains independent state: oscillator phases, envelope state, filter state, LFO phases

### Oscillator Bank (Per Voice)
- **JUCE Class:** `juce::dsp::Oscillator<float>` or custom `std::sin(phase)`
- **Purpose:** Generate 3 detuned sine waves per voice for lush, chorused texture
- **Parameters Affected:** None directly (MIDI note determines pitch)
- **Configuration:**
  - 3 sine oscillators per voice (24 total oscillators for 8 voices)
  - Detuning: Oscillator 1 at base frequency, Oscillator 2 at +7 cents, Oscillator 3 at -7 cents
  - Cent-to-frequency ratio: `2^(cents/1200)` → +7 cents ≈ 1.00407, -7 cents ≈ 0.99593
  - MIDI note to frequency: `f = 440 * 2^((note - 69) / 12)`
  - Phase accumulation: `phase += (frequency * 2π) / sampleRate`

### FM Feedback Processor (Per Oscillator)
- **JUCE Class:** Custom implementation
- **Purpose:** Add subtle harmonics and timbral richness through phase modulation
- **Parameters Affected:** timbre (controls feedback depth)
- **Configuration:**
  - Formula: `output = sin(phase + feedback_depth * delayed_output)`
  - Delay: 1 sample (previous output)
  - Feedback depth range: 0.0 (no modulation) to 0.4 (rich harmonics, tuned to stay musical)
  - timbre parameter (0.0-1.0) maps linearly to feedback depth (0.0-0.4)
  - Applied per-oscillator before summing

### Harmonic Saturation
- **JUCE Class:** Custom implementation (tanh waveshaping)
- **Purpose:** Add warmth and harmonic complexity
- **Parameters Affected:** timbre (controls saturation amount)
- **Configuration:**
  - Transfer function: `output = tanh(gain * input)`
  - Gain range: 1.0 (no saturation) to 3.0 (warm saturation)
  - timbre parameter (0.0-1.0) maps to gain (1.0-3.0)
  - Applied per-voice after oscillator summing
  - NOTE: timbre controls BOTH FM feedback AND saturation simultaneously

### Low-Pass Filter (Per Voice)
- **JUCE Class:** `juce::dsp::IIR::Filter<float>` with `juce::dsp::IIR::Coefficients<float>::makeLowPass()`
- **Purpose:** Shape harmonic content and add movement via velocity
- **Parameters Affected:** filter_cutoff, MIDI velocity
- **Configuration:**
  - Type: 12dB/octave (2-pole, single biquad)
  - Resonance: Fixed at 0.35 (Q factor, adds character without ringing)
  - Cutoff range: 20 Hz - 20000 Hz (parameter range)
  - Velocity scaling: `actual_cutoff = filter_cutoff * (0.5 + 0.5 * velocity_normalized)`
    - Soft notes (velocity 0): cutoff reduced by 50%
    - Hard notes (velocity 127): cutoff at parameter value
  - Per-voice filtering prevents zipper noise and allows velocity-per-note

### ADSR Envelope (Per Voice)
- **JUCE Class:** `juce::ADSR`
- **Purpose:** Shape amplitude and provide classic pad fade-in/fade-out behavior
- **Parameters Affected:** None (fixed envelope for pad character)
- **Configuration:**
  - Attack: 300ms (slow fade-in, typical pad behavior)
  - Decay: 200ms (subtle initial shaping)
  - Sustain: 0.8 (80% level while held)
  - Release: 2000ms (long fade-out, lush pad tail)
  - Applied to amplitude per-voice
  - Triggered on note-on, released on note-off

### Random LFO Modulation System (Per Voice)
- **JUCE Class:** Custom implementation using `juce::Random` with smooth interpolation
- **Purpose:** Create generative, constantly evolving texture through nested modulation
- **Parameters Affected:** None directly (hidden modulation system)
- **Configuration:**
  - **Primary LFOs (3 per voice):**
    - LFO 1 → Panning (±30% L/R)
    - LFO 2 → FM feedback depth (±20% around timbre parameter)
    - LFO 3 → Saturation amount (±15% around timbre parameter)
    - Frequency range: 0.05-0.2 Hz (very slow, imperceptible patterns)
  - **Secondary LFOs (3 per voice):**
    - LFO 4 → Modulates speed of LFO 1 (±30% speed variation)
    - LFO 5 → Modulates speed of LFO 2 (±30% speed variation)
    - LFO 6 → Modulates speed of LFO 3 (±30% speed variation)
    - Frequency range: 0.02-0.1 Hz (slower than primary)
  - **Tertiary LFOs (3 per voice):**
    - LFO 7 → Modulates depth of LFO 1 (±40% depth variation)
    - LFO 8 → Modulates depth of LFO 2 (±40% depth variation)
    - LFO 9 → Modulates depth of LFO 3 (±40% depth variation)
    - Frequency range: 0.01-0.05 Hz (slowest layer)
  - Smooth interpolation: Low-pass filter random values (cutoff ~0.5 Hz) to prevent sudden jumps
  - Total: 9 random LFOs per voice, 72 LFOs across 8 voices

### Reverb Engine (Global)
- **JUCE Class:** `juce::dsp::Reverb`
- **Purpose:** Add spaciousness and lush, expansive character
- **Parameters Affected:** reverb_amount (dry/wet mix)
- **Configuration:**
  - Algorithm: Large hall reverb
  - Room size: 0.9 (90%, large space)
  - Damping: 0.4 (moderate high-frequency rolloff, keeps lush without muddiness)
  - Width: 1.0 (full stereo width)
  - Decay time: 2.5 seconds (achieved via roomSize + damping combination)
  - Pre-delay: 30ms (adds spatial depth)
  - Wet/dry mix: Controlled by reverb_amount parameter (0.0 = dry, 1.0 = 100% wet)
  - Applied globally to mixed output of all voices
  - **CRITICAL:** Use modern juce::dsp API with `prepare(ProcessSpec)` and `process(ProcessContext)`, NOT old `setSampleRate()` API

---

## Processing Chain

```
MIDI Input
  ↓
Voice Allocation (assign note to voice 0-7)
  ↓
For Each Active Voice:
  ├─ Update Random LFO States (9 LFOs: primary, secondary, tertiary)
  │  └─ Calculate nested modulation (tertiary → secondary → primary)
  │
  ├─ Calculate Modulated Parameters:
  │  ├─ FM feedback depth = timbre + LFO2_modulation
  │  ├─ Saturation gain = timbre + LFO3_modulation
  │  └─ Pan position = center + LFO1_modulation
  │
  ├─ Generate 3 Sine Waves (base, +7 cents, -7 cents)
  │  └─ Apply FM Feedback per oscillator
  │
  ├─ Sum 3 Oscillators
  │
  ├─ Apply Harmonic Saturation (tanh waveshaping)
  │
  ├─ Apply Low-Pass Filter (velocity-scaled cutoff)
  │
  ├─ Apply ADSR Envelope (amplitude shaping)
  │
  ├─ Apply Random Panning (LFO1 modulation)
  │
  └─ Add to Voice Mix Buffer
  ↓
Mix All Active Voices (8 voices → stereo)
  ↓
Apply Global Reverb ← reverb_amount parameter
  ↓
Output (Stereo)
```

**Processing order requirements:**
1. LFO update BEFORE parameter calculation (nested modulation needs fresh values)
2. FM feedback BEFORE oscillator summing (applied per-oscillator)
3. Saturation AFTER oscillator summing (applied to mixed oscillators)
4. Filter AFTER saturation (shapes saturated harmonics)
5. Envelope AFTER filter (amplitude shaping last in per-voice chain)
6. Panning AFTER envelope (final per-voice processing)
7. Reverb AFTER voice mixing (global effect on mixed output)

---

## System Architecture

### MIDI Input Handling

**Input handling:** Omni mode (responds to all MIDI channels)

**Note mapping:**
- All MIDI notes supported (0-127)
- Note-on → Trigger voice allocation, calculate frequency, start ADSR attack
- Note-off → Release ADSR envelope (voice fades out over 2s release time)
- Velocity → Affects amplitude (0-127 → 0.0-1.0 gain) AND filter cutoff (scaling factor)

**JUCE classes:**
- `juce::MidiBuffer` - Iterate MIDI events in processBlock
- `juce::MidiMessage::getNoteNumber()` - Extract note number
- `juce::MidiMessage::getVelocity()` - Extract velocity
- `juce::MidiMessage::isNoteOn()` / `isNoteOff()` - Event type detection

**Processing:**
```cpp
for (const auto metadata : midiMessages)
{
    auto message = metadata.getMessage();
    if (message.isNoteOn())
    {
        int note = message.getNoteNumber();
        float velocity = message.getVelocity() / 127.0f;
        allocateVoice(note, velocity);
    }
    else if (message.isNoteOff())
    {
        int note = message.getNoteNumber();
        releaseVoice(note);
    }
}
```

### Voice Allocation Strategy

**Algorithm:** Oldest-note-stealing polyphony

**Strategy:**
1. Search for inactive voice (ADSR not active)
2. If all voices busy, find oldest active voice (by timestamp or counter)
3. Steal oldest voice: force ADSR release, reassign to new note
4. Prevents audible pops: ADSR release on stolen voice fades out gracefully

**Edge cases:**
- Rapid note triggering: Voices cycle through round-robin
- All voices sustained: Oldest note gets stolen (standard polyphonic behavior)
- Note-off for non-active note: Ignored (no-op)

### State Persistence

**What state is saved:**
- APVTS parameters: timbre, filter_cutoff, reverb_amount (automatic)
- No custom state needed (no folder paths, no lock buttons, no user preferences beyond parameters)

**Serialization format:**
- APVTS parameters: Automatic via `AudioProcessorValueTreeState`

**JUCE classes:**
- `juce::AudioProcessorValueTreeState` - Parameter persistence (automatic)

**Restore behavior:**
- All state is parameter-based: Standard JUCE restoration
- No custom getStateInformation/setStateInformation needed

---

## Parameter Mapping

| Parameter ID | Type | Range | DSP Component | Usage |
|-------------|------|-------|---------------|-------|
| timbre | Float | 0.0-1.0 | FM Feedback + Saturation | Maps to FM feedback depth (0.0-0.4) AND saturation gain (1.0-3.0) simultaneously. Subject to ±20% (FM) and ±15% (saturation) random modulation via LFO2 and LFO3. |
| filter_cutoff | Float | 20-20000 Hz | IIR Low-Pass Filter | Cutoff frequency with logarithmic scaling (skew 0.3). Scaled by velocity: `actual_cutoff = filter_cutoff * (0.5 + 0.5 * velocity)`. Soft notes → darker, hard notes → brighter. |
| reverb_amount | Float | 0.0-1.0 | Reverb Dry/Wet Mix | 0.0 = fully dry (no reverb), 1.0 = fully wet (100% reverb). Applied to mixed output of all voices. |

---

## Algorithm Details

### FM Feedback (Phase Modulation)

**Algorithm:** Sine wave phase modulated by its own delayed output

**Implementation notes:**
- Formula: `output = sin(phase + feedback_depth * previous_output)`
- Phase calculation: `phase += (frequency * 2π) / sampleRate`, wrapped to [0, 2π]
- Feedback depth: Controlled by timbre parameter (0.0-0.4 range)
- Maximum depth tuned to 0.4 to stay musical (higher values become harsh/chaotic)
- Applied per-oscillator (each of 3 oscillators has independent feedback)
- Random modulation: LFO2 adds ±20% variation around timbre setting

### Detuning Algorithm

**Algorithm:** Frequency ratio based on cents

**Implementation notes:**
- Cents to frequency ratio: `ratio = 2^(cents/1200)`
- +7 cents: `ratio = 2^(7/1200) ≈ 1.00407`
- -7 cents: `ratio = 2^(-7/1200) ≈ 0.99593`
- Base frequency from MIDI note: `f_base = 440 * 2^((note - 69) / 12)`
- Three oscillator frequencies:
  - Osc 1: `f_base`
  - Osc 2: `f_base * 1.00407`
  - Osc 3: `f_base * 0.99593`
- Subtle chorus-like thickening without obvious beating

### Nested Random Modulation

**Algorithm:** Three-layer LFO system with cross-modulation

**Implementation notes:**
- **Layer 1 (Primary LFOs):** Generate smooth random values targeting panning, FM depth, saturation
  - Frequency: 0.05-0.2 Hz (12-120 second cycles, imperceptible)
  - Waveform: Low-pass filtered noise (cutoff ~0.5 Hz for smoothness)
  - Output: Bipolar (-1 to +1) modulation signal

- **Layer 2 (Secondary LFOs):** Modulate the frequency of primary LFOs
  - Frequency: 0.02-0.1 Hz (slower than primary)
  - Modulation depth: ±30% of primary LFO frequency
  - Effect: Primary LFO speed varies organically over time

- **Layer 3 (Tertiary LFOs):** Modulate the depth of primary LFOs
  - Frequency: 0.01-0.05 Hz (slowest layer)
  - Modulation depth: ±40% of primary LFO depth
  - Effect: Primary LFO modulation amount varies organically

- **Calculation order:**
  1. Update tertiary LFO phases and generate values
  2. Calculate modulated primary LFO depths: `depth = base_depth * (1.0 + tertiary_value * 0.4)`
  3. Update secondary LFO phases and generate values
  4. Calculate modulated primary LFO frequencies: `freq = base_freq * (1.0 + secondary_value * 0.3)`
  5. Update primary LFO phases with modulated frequency
  6. Generate primary LFO output with modulated depth
  7. Apply to target parameters (panning, FM feedback, saturation)

- **Smooth interpolation:** Use `juce::Random::nextFloat()` + one-pole low-pass filter
  - Filter formula: `smoothed += (target - smoothed) * 0.01` (at audio rate)
  - Prevents sudden jumps and clicks

### Velocity Scaling

**Algorithm:** Velocity affects amplitude and filter cutoff

**Implementation notes:**
- Amplitude scaling: `gain = velocity / 127.0` (linear, 0.0-1.0)
- Filter cutoff scaling: `actual_cutoff = filter_cutoff * (0.5 + 0.5 * velocity_normalized)`
  - Velocity 0 (softest): Cutoff reduced to 50% of parameter value
  - Velocity 127 (hardest): Cutoff at 100% of parameter value
  - Provides dynamic expression: Soft notes are darker, hard notes are brighter
- Applied per-voice (velocity is per-note)

---

## Integration Points

### Feature Dependencies

- MIDI input → Voice allocation (MIDI note-on triggers voice assignment)
- Voice allocation → Oscillator generation (assigned voice generates audio)
- Oscillator generation → FM feedback (phase modulation applied per oscillator)
- FM feedback → Saturation (saturated harmonics from FM feedback)
- Saturation → Filtering (filter shapes saturated spectrum)
- Filtering → Envelope (amplitude shaped by ADSR)
- Envelope → Voice output (final per-voice processing)
- All voices → Reverb (mixed voices sent to global reverb)
- Random LFOs → FM feedback depth (LFO2 modulates timbre parameter)
- Random LFOs → Saturation amount (LFO3 modulates timbre parameter)
- Random LFOs → Panning (LFO1 modulates stereo position)
- Nested LFOs → Primary LFO speed/depth (secondary and tertiary layers modulate primary)

### Parameter Interactions

- **timbre parameter dual influence:** Controls BOTH FM feedback depth AND saturation gain
  - FM feedback depth = timbre * 0.4 (scaled to 0.0-0.4)
  - Saturation gain = 1.0 + timbre * 2.0 (scaled to 1.0-3.0)
  - Random modulation: LFO2 adds ±20% to FM depth, LFO3 adds ±15% to saturation gain

- **filter_cutoff + velocity interaction:**
  - Actual cutoff = filter_cutoff * (0.5 + 0.5 * velocity_normalized)
  - Both parameter and velocity influence final cutoff frequency
  - Velocity provides per-note dynamic expression

- **reverb_amount is independent:** No interactions with other parameters

### Processing Order Requirements

**Sequential processing order (REQUIRED):**

1. **Parse MIDI buffer:** Extract note-on/note-off events
   - Must happen first (MIDI timing is sample-accurate)

2. **Update voice allocation:** Trigger/release voices based on MIDI
   - Must happen before audio generation

3. **For each active voice:**

   a. **Update all LFO states (nested):**
      - Tertiary LFOs first (slowest layer)
      - Secondary LFOs second (modulated by tertiary)
      - Primary LFOs third (modulated by secondary and tertiary)
      - Must happen before using LFO values

   b. **Calculate modulated parameters:**
      - FM feedback depth (timbre + LFO2 modulation)
      - Saturation gain (timbre + LFO3 modulation)
      - Pan position (center + LFO1 modulation)
      - Must happen before DSP processing

   c. **Generate 3 sine waves with FM feedback:**
      - Each oscillator: sin(phase + feedback * previous_output)
      - FM feedback must be applied per-oscillator BEFORE summing

   d. **Sum 3 oscillators:**
      - Add together for chorused sine wave
      - Must happen before saturation

   e. **Apply harmonic saturation:**
      - tanh(gain * summed_oscillators)
      - Must happen after oscillator summing, before filtering

   f. **Apply low-pass filter:**
      - Shapes saturated spectrum
      - Must happen after saturation, before envelope

   g. **Apply ADSR envelope:**
      - Amplitude shaping
      - Must happen after filter (final per-voice processing)

   h. **Apply random panning:**
      - Stereo positioning with LFO1 modulation
      - Must happen after envelope (last per-voice step)

   i. **Add to voice mix buffer:**
      - Accumulate voice output
      - Must happen after all per-voice processing

4. **Mix all voices:**
   - Sum 8 voice outputs into stereo buffer
   - Must happen before reverb

5. **Apply global reverb:**
   - Reverb processes mixed output
   - Must happen last (global effect)

**Why order matters:**
- FM feedback before summing: Creates chorused FM harmonics, not FM on chorused signal
- Saturation after summing: Saturates the mixed oscillator output (richer harmonics)
- Filter after saturation: Shapes the saturated spectrum
- Envelope after filter: Amplitude shaping is final per-voice processing
- Reverb after mixing: Global effect on combined voices (not per-voice reverb)

### Thread Boundaries

**Audio thread:**
- All DSP processing (oscillators, FM feedback, saturation, filtering, envelopes, LFOs, reverb)
- MIDI message parsing and voice allocation
- Parameter reads via `APVTS::getRawParameterValue()->load()` (atomic)
- Sample-by-sample processing in processBlock()

**Message thread:**
- Parameter updates from UI via APVTS (atomic writes)
- Preset loading/saving
- UI repaints

**No background thread needed:**
- No file I/O
- No long-running operations
- All processing is real-time compatible

**Communication:**
- APVTS parameters: Atomic reads (audio thread) / atomic writes (message thread)
- No custom thread communication needed (APVTS handles it)

---

## Implementation Risks

### Nested Random LFO System

**Complexity:** HIGH

**Risk Level:** MEDIUM-HIGH

**Risk factors:**
1. Creating natural-sounding, non-repeating modulation is algorithmically complex
   - 9 LFOs per voice (72 total for 8 voices) requires careful state management
   - Tuning frequency ranges to avoid perceivable patterns is experimental
2. Smooth interpolation critical to prevent clicks and audible stepping
   - Low-pass filtering random values adds CPU cost
3. Cross-modulation between LFO layers requires correct calculation order
   - Tertiary → secondary → primary dependency chain
4. CPU cost: 72 LFO phase accumulators + smooth random generation + cross-modulation

**Alternative approaches:**
1. **Single-layer random modulation:**
   - Complexity: LOW
   - Quality: Good but less evolving (simpler, more perceivable patterns)
   - CPU: ~30% reduction
   - Best for: If nested modulation proves too CPU-intensive or difficult to tune

2. **Pre-computed smooth random curves:**
   - Complexity: MEDIUM
   - Quality: Good (can be carefully designed for smoothness)
   - CPU: Lower (table lookup vs. real-time generation)
   - Best for: If real-time generation too expensive

3. **Two-layer nesting (skip tertiary):**
   - Complexity: MEDIUM
   - Quality: Still evolving but less complex
   - CPU: ~30% reduction
   - Best for: If three layers overkill or too hard to tune

**Fallback architecture:**
- **Primary:** Three-layer nested LFO system (highest quality, most generative)
- **Fallback 1:** Two-layer nesting (secondary modulates primary speed/depth only)
- **Fallback 2:** Single-layer random LFO (no nesting, direct modulation of panning/FM/saturation)
- **Fallback 3:** Fixed modulation curves (pre-computed, no real-time randomness)

**Mitigation strategy:**
1. Start with single-layer random LFO to validate smoothness and parameter ranges
2. Add second layer (speed modulation) and test for organic feel
3. Add third layer (depth modulation) incrementally
4. Profile CPU usage after each layer (if >60% single core, fall back)
5. Extensive listening tests to ensure modulation is imperceptible but effective

---

### FM Feedback Stability

**Complexity:** MEDIUM

**Risk Level:** MEDIUM

**Risk factors:**
1. Feedback can become unstable or harsh at high settings
   - Feedback depth >0.5 often leads to chaotic, non-musical tones
   - Need to limit maximum to stay musical
2. Interaction with timbre parameter: User could set timbre to 1.0 expecting subtle effect
   - Maximum feedback depth tuned to 0.4 (when timbre = 1.0) to prevent harshness
3. Random modulation adds ±20% variation
   - Could push feedback into unstable range if not carefully limited
4. Per-oscillator feedback (3 per voice) could interact unpredictably when summed

**Alternative approaches:**
1. **Fixed maximum feedback (no user control):**
   - Complexity: LOW
   - Quality: Consistent but less flexible
   - Best for: If user control proves too risky

2. **Soft limiting on feedback depth:**
   - Complexity: LOW
   - Add tanh limiting to feedback signal before phase modulation
   - Prevents runaway feedback
   - Best for: Additional safety on top of parameter limiting

3. **Reduce random modulation range:**
   - Change ±20% to ±10% for safer modulation
   - Less evolving but more stable
   - Best for: If feedback instability occurs with current ranges

**Fallback architecture:**
- **Primary:** User-controlled timbre (0.0-1.0) maps to feedback depth (0.0-0.4) with ±20% LFO modulation
- **Fallback 1:** Reduce maximum feedback depth to 0.3 (even safer)
- **Fallback 2:** Reduce LFO modulation to ±10% (less variation, more stable)
- **Fallback 3:** Add soft limiting to feedback signal (tanh clipping)
- **Fallback 4:** Fixed feedback depth with no modulation (simplest, least interesting)

**Mitigation strategy:**
1. Test feedback stability with maximum timbre (1.0) and maximum LFO modulation (+20%)
2. Listen for harshness, distortion, or chaotic behavior
3. Reduce maximum depth if instability detected
4. Add soft limiting as safety measure
5. Extensive testing across note ranges (low notes more prone to feedback issues)

---

### Voice Allocation and Polyphony Management

**Complexity:** MEDIUM

**Risk Level:** LOW-MEDIUM

**Risk factors:**
1. Edge cases: All voices busy, rapid note retriggering, voice stealing glitches
2. Oldest-note-stealing requires tracking voice age (timestamp or counter)
3. Popping when stealing active notes if ADSR not handled correctly
4. Race conditions if MIDI events processed incorrectly

**Alternative approaches:**
1. **Round-robin allocation (ignore notes when full):**
   - Complexity: LOW
   - Simplest implementation: Cycle through voices 0-7
   - Downside: Notes ignored when all voices busy (not professional behavior)
   - Best for: Initial prototype

2. **Lowest-priority note stealing:**
   - Steal lowest or highest pitch instead of oldest
   - Complexity: LOW
   - Requires tracking note pitch per voice
   - Best for: Musical applications where bass/treble priority matters

**Fallback architecture:**
- **Primary:** Oldest-note-stealing (professional, standard polyphonic behavior)
- **Fallback 1:** Round-robin with note ignoring (simpler, less professional)
- **Fallback 2:** Fixed 8-voice limit with no stealing (notes ignored when full)

**Mitigation strategy:**
1. Track voice allocation timestamp or counter per voice
2. Force ADSR release on stolen voice (fade out gracefully, no pops)
3. Test rapid note triggering (fast arpeggios, chords)
4. Test edge cases: 8-note chord held, then 9th note triggered
5. Reference JUCE MPE examples for polyphonic voice management patterns

---

### Overall Project Risk

**Overall complexity:** MEDIUM-HIGH
- Nested LFO system (HIGH complexity) + FM feedback (MEDIUM) + polyphonic voice management (MEDIUM)
- 3 major complexity sources, plus standard components (filters, envelopes, reverb)

**Highest risk component:** Nested Random LFO System
- Represents ~40% of unique project risk
- Most algorithmically complex feature
- Requires tuning and experimentation
- No direct JUCE class (custom implementation)

**Recommended approach:**
1. **Phase 1 - Basic polyphonic synth (LOW risk, 30-40 min):**
   - Voice allocation, MIDI handling, sine oscillators, detuning
   - ADSR envelope, basic filter, reverb
   - Validates architecture and polyphonic framework

2. **Phase 2 - FM feedback (MEDIUM risk, 20-30 min):**
   - Add FM feedback to oscillators with fixed depth
   - Test stability across note ranges
   - Connect to timbre parameter

3. **Phase 3 - Saturation (LOW risk, 10-15 min):**
   - Add tanh waveshaping controlled by timbre
   - Test interaction with FM feedback

4. **Phase 4 - Single-layer random modulation (MEDIUM risk, 20-30 min):**
   - Implement primary LFOs (panning, FM depth, saturation)
   - Test smoothness and parameter ranges
   - Validate that modulation is imperceptible but effective

5. **Phase 5 - Nested modulation layers (HIGH risk, 30-45 min):**
   - Add secondary LFOs (modulate primary speed)
   - Add tertiary LFOs (modulate primary depth)
   - Extensive listening tests for organic, non-repeating character

6. **Phase 6 - Parameter tuning and optimization (20-30 min):**
   - Fine-tune LFO frequency ranges
   - Optimize CPU usage
   - Final polish

**Total estimated time:** 130-200 minutes (2-3.5 hours) including fallback testing

---

## Architecture Decisions

### Timbre Parameter Dual Control (FM + Saturation)

**Decision:** Single timbre parameter controls both FM feedback depth AND harmonic saturation

**Rationale:**
- Creative brief specifies "minimal interface (just 3 knobs)" with "complex generative system underneath"
- FM feedback and saturation both contribute to "timbre" in musical sense
- Combining into single control reduces cognitive load
- Both scale musically together: More timbre = more FM harmonics + more saturation warmth

**Alternatives considered:**
1. **Separate FM and Saturation parameters (5 total parameters):**
   - Why rejected: Violates "simplicity + deliciousness" philosophy of minimal interface
   - When to reconsider: If user testing shows need for independent control

2. **Timbre controls FM only (no saturation):**
   - Why rejected: Saturation adds important warmth and harmonic richness
   - When to reconsider: If saturation proves problematic or CPU-intensive

**Tradeoffs accepted:**
- **Less precise control:** Users cannot independently adjust FM vs. saturation
  - Acceptable because: Target is "effortless" pad creation, not detailed sound design
- **Parameter interaction complexity:** Both FM and saturation respond to timbre + LFO modulation
  - Acceptable because: Interaction is musical (both contribute to timbral richness)

**When to revisit:**
- If users request independent FM/saturation control
- If saturation proves unstable or CPU-intensive (fall back to FM-only)

---

### Three-Layer Nested LFO Modulation

**Decision:** Implement three layers of LFO nesting (primary, secondary modulating speed, tertiary modulating depth)

**Rationale:**
- Creative brief emphasizes "generative" quality and "never repeats exactly"
- Single-layer random modulation can sound repetitive over long periods
- Nested modulation creates complex, evolving patterns that are truly non-repeating
- Professional generative plugins (Omnisphere Orb, Generate by Newfangled Audio) use similar techniques

**Alternatives considered:**
1. **Single-layer random LFO (no nesting):**
   - Why rejected: Less generative, more perceivable patterns over time
   - When to reconsider: If three layers too CPU-intensive or difficult to tune

2. **Two-layer nesting (secondary only):**
   - Why rejected: Less complex evolution than three layers
   - When to reconsider: If tertiary layer proves unnecessary or too subtle

3. **Pre-computed random curves:**
   - Why rejected: Not truly generative (curves repeat after looping)
   - When to reconsider: If real-time generation too CPU-intensive

**Tradeoffs accepted:**
- **Higher CPU usage:** 9 LFOs per voice (72 total) vs. 3 LFOs per voice (24 total)
  - Acceptable because: Pads are not CPU-critical (single instance per project typically)
  - Mitigation: Profile and optimize, fall back to two layers if needed
- **Tuning complexity:** Finding frequency ranges that feel organic requires experimentation
  - Acceptable because: One-time design cost, benefits all users
  - Mitigation: Extensive listening tests, reference professional plugins
- **Difficult to implement:** Cross-modulation calculation order is critical
  - Acceptable because: Complexity is isolated to LFO update function
  - Mitigation: Clear calculation order documented in Architecture

**When to revisit:**
- If CPU usage exceeds 60% single core (fall back to two layers or single layer)
- If tuning proves too difficult (use pre-computed curves)
- If modulation is too subtle to justify complexity (simplify to two layers)

---

### Per-Voice Filtering (Not Global)

**Decision:** Each voice has independent filter state (8 filters total)

**Rationale:**
- Velocity affects filter cutoff per-note (soft notes darker, hard notes brighter)
- Per-voice filtering allows velocity-per-note expression
- Prevents zipper noise when filter cutoff changes (each voice maintains continuous state)
- Standard practice in polyphonic synthesizers

**Alternatives considered:**
1. **Global filter (single filter for all voices):**
   - Why rejected: Cannot apply velocity-per-note to filter cutoff
   - When to reconsider: If per-voice filtering proves CPU-intensive

2. **Velocity affects amplitude only (not filter):**
   - Why rejected: Loses expressive dynamic character (soft = dark, hard = bright)
   - When to reconsider: If per-voice filtering too complex

**Tradeoffs accepted:**
- **Higher CPU usage:** 8 filters vs. 1 filter
  - Acceptable because: IIR filters are cheap (~2-3% CPU per filter)
  - Total cost: ~20% CPU for all filters (manageable)
- **More state to manage:** Each voice has filter coefficients and state
  - Acceptable because: JUCE IIR::Filter class handles state internally

**When to revisit:**
- If CPU usage too high (fall back to global filter)
- If velocity-to-filter expression proves unnecessary (simplify to amplitude-only)

---

### Fixed ADSR Envelope (Not User-Controllable)

**Decision:** ADSR envelope has fixed values (300ms attack, 2000ms release) with no user parameters

**Rationale:**
- Creative brief specifies "just 3 knobs" for minimal interface
- Pad envelopes have standard characteristics (slow attack, long release)
- Target use case is "effortless, constantly evolving textures" not detailed envelope shaping
- Reducing parameters from 3 to 3+4 (ADSR) would contradict "simplicity" philosophy

**Alternatives considered:**
1. **User-controllable ADSR (7 total parameters):**
   - Why rejected: Violates minimal interface philosophy
   - When to reconsider: If user testing shows need for envelope control

2. **Attack and Release only (5 total parameters):**
   - Why rejected: Still adds complexity, decay/sustain are less critical for pads
   - When to reconsider: If fixed envelope too limiting

**Tradeoffs accepted:**
- **Less flexibility:** Users cannot adjust envelope shape
  - Acceptable because: Fixed envelope is optimized for lush pads (target use case)
  - Mitigation: Values chosen for broad applicability (300ms attack, 2s release)
- **Not suitable for all sounds:** Fast attack plucks or short decays not possible
  - Acceptable because: Plugin is specifically a "pad synthesizer" not general-purpose synth

**When to revisit:**
- If users request envelope control
- If fixed envelope proves too limiting for target use cases
- Consider adding Attack and Release as bonus parameters in future version (v1.1+)

---

## Special Considerations

### Thread Safety

- All parameter reads use atomic `getRawParameterValue()->load()` (APVTS pattern)
- Voice state is per-voice (no shared state between voices, safe for parallel processing)
- LFO phase state is per-voice (no cross-voice dependencies)
- Filter state is per-voice (juce::dsp::IIR::Filter manages internal state)
- Reverb is global but only accessed by audio thread (no contention)
- No manual synchronization needed (APVTS handles parameter thread safety)

### Performance

**Estimated CPU usage per component (single voice):**
- 3 sine oscillators with FM feedback: ~8% CPU
- Harmonic saturation (tanh): ~2% CPU
- IIR filter (2-pole): ~3% CPU
- ADSR envelope: ~1% CPU
- 9 random LFOs (nested): ~5% CPU
- **Per-voice total:** ~19% CPU

**Total for 8 voices:** ~152% CPU (requires multi-core or optimization)

**Global components:**
- Reverb: ~25-30% CPU
- Voice mixing: ~2% CPU

**Overall estimated:** ~180% single core → Requires ~2 cores for 8 voices

**Optimization opportunities:**
- SIMD for oscillator bank (process 3 oscillators with SIMD)
- Simplify LFO system (fall back to two layers or single layer)
- Reduce polyphony to 6 voices (saves ~38% CPU)
- Use juce::dsp::Oscillator instead of custom sine (may be optimized)

**Hot paths:**
- Oscillator generation with FM feedback (called 24 times per sample for 8 voices)
- LFO update and cross-modulation (called 72 times per block)

**Buffer size sensitivity:**
- LFO updates happen per-block (not per-sample) to reduce cost
- Smaller buffer sizes increase LFO update frequency (minor CPU impact)

### Denormal Protection

- Use `juce::ScopedNoDenormals` in `processBlock()` (standard JUCE pattern)
- All JUCE DSP components (IIR::Filter, Reverb, ADSR) handle denormals internally
- Custom oscillator phase wrapping prevents denormals (phase stays in [0, 2π])
- LFO phase wrapping prevents denormals (phase stays in [0, 2π])
- FM feedback uses previous output (never zero) preventing denormal propagation

### Sample Rate Handling

**Sample rate dependent calculations:**
- Oscillator phase increment: `(frequency * 2π) / sampleRate`
- LFO phase increment: `(lfo_frequency * 2π) / sampleRate`
- Filter coefficients: Recalculated in `prepareToPlay()` via `makeLowPass(sampleRate, cutoff, Q)`
- ADSR time constants: JUCE ADSR handles sample rate internally
- Reverb: Reinitialize in `prepareToPlay()` with new sample rate

**prepareToPlay requirements:**
```cpp
void prepareToPlay(double sampleRate, int samplesPerBlock) override
{
    // Store sample rate for oscillator/LFO phase increments
    currentSampleRate = sampleRate;

    // Prepare reverb with ProcessSpec
    juce::dsp::ProcessSpec spec;
    spec.sampleRate = sampleRate;
    spec.maximumBlockSize = static_cast<juce::uint32>(samplesPerBlock);
    spec.numChannels = 2; // Stereo output

    reverb.prepare(spec);
    reverb.reset();

    // Prepare filters (per-voice)
    for (auto& voice : voices)
    {
        voice.filter.prepare(spec);
        voice.filter.reset();
    }

    // Reset all voice states
    for (auto& voice : voices)
    {
        voice.reset();
    }
}
```

### Latency

**Processing latency sources:**
- FM feedback: 1 sample delay (previous output feedback)
- IIR filter: ~1 sample group delay
- Reverb: 30ms pre-delay + ~20ms internal processing = ~50ms total
- **Total latency:** ~50ms (2400 samples @ 48kHz)

**Host compensation:**
- Report latency via `getLatencySamples()`:
  ```cpp
  int getLatencySamples() const override
  {
      return static_cast<int>(0.05 * getSampleRate()); // 50ms
  }
  ```
- Host will compensate for reverb latency in multi-track playback

**Latency not critical:**
- Pads are typically sustained notes (not percussive attacks)
- 50ms latency is acceptable for lush, spacious character
- Reverb pre-delay contributes to spatial depth (not a bug, a feature)

---

## Research References

### Professional Plugins

1. **Spectrasonics Omnisphere 3**
   - Generative "Orb" modulation system with nested LFO routing
   - Multiple oscillators per voice with drift and detuning
   - FM modulation capabilities for evolving timbres
   - Observed: Nested modulation creates truly evolving, non-repeating textures

2. **Newfangled Audio Generate**
   - Chaotic oscillators with extensive modulation routing
   - "Modulating modulators" feature (up to 1440 simultaneous modulation routings)
   - Designed for generative, evolving pads and textures
   - Observed: Deep modulation systems create organic, unpredictable evolution

3. **Native Instruments Massive / Massive X**
   - Complex modulation matrix with LFO cross-modulation
   - Pad presets often use sine waves with FM and multiple LFOs
   - Observed: Professional pads use subtle detuning and slow modulation

4. **Valhalla VintageVerb**
   - Large hall settings typical for pads
   - Pre-delay 20-50ms standard for spatial depth
   - Damping controls brightness without muddiness
   - Observed: Reverb decay 1-3 seconds typical for lush pads

5. **U-he Diva / Repro**
   - Multiple oscillator architectures including FM
   - Subtle detuning (5-10 cents) creates chorus-like thickness
   - Per-voice filtering standard in polyphonic mode
   - Observed: 3 oscillators per voice is industry standard for thick pads

### JUCE Documentation

- **juce::dsp::Oscillator<float>:** Sine wave generation with phase accumulation
- **juce::dsp::IIR::Filter<float>:** Biquad filtering with coefficient helpers
  - `juce::dsp::IIR::Coefficients<float>::makeLowPass(sampleRate, cutoff, Q)` for low-pass design
- **juce::ADSR:** Envelope generator with attack, decay, sustain, release parameters
  - Handles sample rate internally, provides `getNextSample()` for per-sample output
- **juce::dsp::Reverb:** Modern DSP reverb algorithm
  - **CRITICAL:** Use `prepare(ProcessSpec)` and `process(ProcessContextReplacing)`, NOT old API
  - Parameters: roomSize, damping, wetLevel, dryLevel, width, freezeMode
- **juce::MidiBuffer:** MIDI event storage and iteration in processBlock
- **juce::MidiMessage:** MIDI message parsing (getNoteNumber, getVelocity, isNoteOn, isNoteOff)
- **juce::Random:** Random number generation
  - `nextFloat()` returns random float in [0, 1]
  - Use for random LFO generation with low-pass filtering for smoothness

### Technical Resources

- **Generative music concepts:** Brian Eno-style evolving systems (modulation of modulators)
- **FM synthesis theory:** Phase modulation creates harmonics proportional to modulation depth
- **Detuning and chorusing:** Small frequency offsets (5-10 cents) create beating/chorus effect
- **Polyphonic synthesis patterns:** Oldest-note-stealing, per-voice state management
- **Thread safety in audio plugins:** APVTS for atomic parameter access, no locks in audio thread

---

## Notes

- Timbre parameter dual control (FM + saturation) is intentional design choice for minimal interface
- Nested LFO system is highest complexity feature but core to "generative" character
- Per-voice filtering allows velocity expression (soft = dark, hard = bright)
- Fixed ADSR envelope optimized for pad use case (no user parameters needed)
- Reverb latency (50ms) is acceptable and contributes to lush, spacious character
- CPU usage estimate assumes 8 voices active simultaneously (worst case)
- Fallback architectures documented for all high-risk features (nested LFOs, FM feedback)
- Professional reference plugins (Omnisphere, Generate) validate nested modulation approach
- JUCE 8 modern DSP API required (ProcessSpec, AudioBlock, ProcessContext)
