# DSP Architecture: FlutterVerb

**CRITICAL CONTRACT:** This specification is immutable during Stages 2-5 implementation. Stage 1 Planning cannot proceed without this file. Stage 4 (DSP) implements this exact architecture.

**Generated by:** Stage 0 Research
**Referenced by:** Stage 1 (Planning), Stage 4 (DSP Implementation)
**Purpose:** DSP specification defining processing components, signal flow, and JUCE module usage

## Core Components

### Reverb Engine
- **JUCE Class:** `juce::dsp::Reverb`
- **Purpose:** Generate plate-style reverb with controllable size and decay characteristics
- **Parameters Affected:** SIZE, DECAY
- **Configuration:**
  - SIZE (0-100%) maps to roomSize parameter (0.0-1.0)
  - DECAY (0.1-10s) maps to combined roomSize + damping for decay time control
  - Width fixed at 1.0 (full stereo)
  - freezeMode disabled

### Wow LFO Generator
- **JUCE Class:** Custom implementation (manual phase accumulation)
- **Purpose:** Slow pitch modulation for tape wow character
- **Parameters Affected:** AGE
- **Configuration:**
  - Frequency: 0.5-1.5 Hz (scaled by AGE)
  - Waveform: Sine wave
  - Per-channel phase tracking
  - Phase increment: `(frequency * 2π) / sampleRate`

### Flutter LFO Generator
- **JUCE Class:** Custom implementation (manual phase accumulation)
- **Purpose:** Fast pitch modulation for tape flutter character
- **Parameters Affected:** AGE
- **Configuration:**
  - Frequency: 4-8 Hz (scaled by AGE)
  - Waveform: Sine wave
  - Per-channel phase tracking
  - Independent phase from Wow LFO

### Pitch Modulation Delay Line
- **JUCE Class:** `juce::dsp::DelayLine<float, juce::dsp::DelayLineInterpolationTypes::Lagrange3rd>`
- **Purpose:** Apply pitch-shifting modulation using variable delay with interpolation
- **Parameters Affected:** AGE, MOD_MODE
- **Configuration:**
  - Base delay: 50ms (center point)
  - Max delay: 200ms buffer size
  - Modulation depth: ±20% at AGE=100% (more extreme than TapeAge's ±10 cents)
  - Lagrange 3rd-order interpolation for smooth modulation
  - Routing: Wet-only by default, optionally Wet+Dry when MOD_MODE enabled

### Tape Saturation
- **JUCE Class:** Custom waveshaper (manual tanh implementation)
- **Purpose:** Add harmonic warmth and analog saturation to reverb tail
- **Parameters Affected:** DRIVE
- **Configuration:**
  - Transfer function: `tanh(gain * sample)`
  - Gain curve: Linear 1.0-10.0 based on DRIVE (0-100%)
  - Formula: `gain = 1.0 + (drive * 9.0)` where drive is 0.0-1.0
  - No oversampling (plate reverb already has natural high-frequency rolloff)

### DJ-Style Filter
- **JUCE Class:** `juce::dsp::ProcessorDuplicator<juce::dsp::IIR::Filter<float>, juce::dsp::IIR::Coefficients<float>>`
- **Purpose:** Tonal shaping with exponential low-pass/high-pass crossfade
- **Parameters Affected:** TONE
- **Configuration:**
  - Negative values (-100% to 0%): Low-pass filter
    - Cutoff range: 200Hz to 20kHz (exponential)
    - Formula: `cutoffHz = 20000.0f * pow(10.0f, -normalizedValue * log10(100.0f))`
  - Positive values (0% to +100%): High-pass filter
    - Cutoff range: 20Hz to 10kHz (exponential)
    - Formula: `cutoffHz = 20.0f * pow(10.0f, normalizedValue * log10(500.0f))`
  - Center bypass zone: |TONE| <= 0.5%
  - Filter type: 2nd-order Butterworth (Q = 0.707)
  - State reset on filter type transitions (prevent bursts)
  - Reference: GainKnob implementation (PluginProcessor.cpp:86-130)

### Dry/Wet Mixer
- **JUCE Class:** `juce::dsp::DryWetMixer<float>`
- **Purpose:** Blend processed reverb signal with dry input
- **Parameters Affected:** MIX
- **Configuration:**
  - MIX (0-100%) maps to wet proportion (0.0-1.0)
  - pushDrySamples() before processing chain
  - setWetMixProportion() for blend control
  - mixDrySamples() after processing

## Processing Chain

```
Input
  ↓
Dry/Wet Mixer (capture dry) ← MIX
  ↓
Plate Reverb ← SIZE, DECAY
  ↓
[MOD_MODE Routing]
  ↓
┌─────────────────────────────────┐
│ Wet Path (always processed):   │
│                                 │
│ Wow LFO (sine, 0.5-1.5Hz)      │ ← AGE
│      ↓                          │
│ Flutter LFO (sine, 4-8Hz)      │ ← AGE
│      ↓                          │
│ Combined Modulation             │
│      ↓                          │
│ Delay Line (pitch shift)       │
│      ↓                          │
│ Tape Saturation (tanh)         │ ← DRIVE
│      ↓                          │
│ DJ Filter (LP/HP)               │ ← TONE
└─────────────────────────────────┘
  ↓
Dry/Wet Mixer (blend) ← MIX
  ↓
Output

MOD_MODE Toggle:
- WET ONLY (0): Modulation applied only to reverb wet signal
- WET+DRY (1): Modulation applied to both wet and dry paths (requires dual delay line or pre-mixer routing)
```

## Parameter Mapping

| Parameter ID | DSP Component | Usage Description |
|--------------|---------------|-------------------|
| SIZE | Reverb Engine | Controls roomSize parameter (0.0-1.0), affects early reflection density and perceived room dimensions |
| DECAY | Reverb Engine | Maps to decay time via roomSize + damping combination (0.1-10 seconds) |
| MIX | Dry/Wet Mixer | Controls wet mix proportion (0.0-1.0), blends processed signal with dry input |
| AGE | Wow/Flutter LFOs + Delay Line | Controls modulation depth (0-100%), scales both wow and flutter LFO amplitudes |
| DRIVE | Tape Saturation | Controls input gain into tanh() waveshaper (1.0-10.0 gain multiplier) |
| TONE | DJ Filter | Controls filter cutoff frequency with exponential mapping, negative=LP, positive=HP, center=bypass |
| MOD_MODE | Signal Routing | Boolean routing switch: 0=wet-only modulation, 1=wet+dry modulation |

## Algorithm Details

**Plate Reverb:**
- Implementation approach: Use juce::dsp::Reverb (Freeverb-based algorithm)
- SIZE → roomSize (direct 0-100% to 0.0-1.0 mapping)
- DECAY → Combined roomSize and damping adjustment
  - Short decays (0.1-2s): Lower roomSize, higher damping
  - Long decays (2-10s): Higher roomSize, lower damping
  - Empirical tuning during Stage 4
- Key considerations: Width=1.0 for full stereo, freezeMode=false
- JUCE helpers available: juce::dsp::Reverb, juce::Reverb::Parameters

**Wow and Flutter Modulation:**
- Implementation approach: Dual independent LFOs modulating delay line read position
- Wow: Slow sine wave (0.5-1.5 Hz), depth scaled by AGE
- Flutter: Fast sine wave (4-8 Hz), depth scaled by AGE
- Combined modulation: `totalModulation = wowLFO + flutterLFO`
- Max depth at AGE=100%: ±20% of base delay (±10ms with 50ms base = 40-60ms range)
- Key considerations: Per-channel phase tracking, smooth phase wrapping
- JUCE helpers available: juce::dsp::DelayLine with Lagrange3rd interpolation

**Tape Saturation:**
- Implementation approach: Manual tanh() soft-clipping with adjustable drive
- Transfer function: `output = tanh(gain * input)` where gain = 1.0 + (DRIVE * 9.0)
- No asymmetry (symmetric tanh for warm character)
- No oversampling required (reverb tail has natural HF rolloff)
- Key considerations: Denormal protection via juce::ScopedNoDenormals
- JUCE helpers available: std::tanh()

**DJ-Style Filter:**
- Implementation approach: Exponential cutoff mapping with Butterworth IIR filters
- Low-pass (TONE < 0): Exponential sweep from 20kHz (center) to 200Hz (extreme)
- High-pass (TONE > 0): Exponential sweep from 20Hz (center) to 10kHz (extreme)
- State reset on filter type change prevents burst artifacts
- Key considerations: Bypass zone at |TONE| <= 0.5%, thread-safe coefficient updates
- JUCE helpers available: juce::dsp::IIR::Coefficients::makeLowPass/makeHighPass

**MOD_MODE Routing:**
- Implementation approach: Conditional signal path selection
- WET ONLY (0): Apply delay line only to reverb output (after reverb, before mixer)
- WET+DRY (1): Apply delay line to both paths (requires processing before dry/wet split OR dual delay line instances)
- Recommended: Use pre-reverb modulation for Wet+Dry mode (simpler routing)
- Key considerations: Avoid discontinuities when toggling, may need crossfade

## Special Considerations

**Thread Safety:**
- All parameter reads use `getRawParameterValue()->load()` for atomic access
- Filter coefficient updates in audio thread (no allocations)
- LFO phase state is per-channel (no shared state between channels)
- Delay line writes/reads are sequential (no thread contention)

**Performance:**
- Reverb is most expensive component (~30% CPU)
- Delay line interpolation adds ~10% CPU overhead
- Filter coefficient calculation only on parameter change
- LFO phase accumulation is lightweight
- Total estimated CPU: ~50% of single core at 48kHz

**Denormal Protection:**
- Use juce::ScopedNoDenormals in processBlock()
- Delay line automatically handles denormals via JUCE implementation
- Reverb engine has internal denormal protection
- Tanh() naturally avoids denormals (bounded output)

**Sample Rate Handling:**
- Reverb: No sample rate compensation needed (JUCE handles internally)
- Delay line: Size calculation based on `sampleRate * maxDelaySeconds`
- LFO phase increment: `(frequency * 2π) / sampleRate`
- Filter coefficients: Recalculate on sample rate change via prepareToPlay()
- All components use `currentSampleRate` from processor state

**Latency:**
- Base delay line: 50ms (2400 samples at 48kHz)
- Reverb: Variable latency (typically 20-50ms internal)
- Total reported latency: 50ms + reverb latency
- Report via `getLatencySamples()` for host compensation

## Research References

**JUCE Documentation:**
- juce::dsp::Reverb class: https://docs.juce.com/master/classdsp_1_1Reverb.html
- juce::Reverb::Parameters struct: https://docs.juce.com/master/structReverb_1_1Parameters.html
- juce::dsp::DelayLine with interpolation: https://docs.juce.com/master/structdsp_1_1DelayLineInterpolationTypes_1_1Lagrange3rd.html
- juce::dsp::WaveShaper tutorial: https://docs.juce.com/master/tutorial_dsp_convolution.html

**Professional Examples:**
- **Soundtoys Little Plate** - Decay up to infinity, pre-delay 0-500ms, width control
- **UAD Pure Plate** - Multiple plate types, extensive filtering, dynamics control
- **LiquidSonics Lustrous Plates** - 100+ parameters in advanced mode, modulation rate/depth
- **Valhalla Plate** - Size and decay independent controls, simple interface
- Industry standard decay ranges: 0.5s (tight spaces) to 10s (ambient washes)

**Technical Resources:**
- JUCE Forum: "Applying wow/flutter effect to delay" - https://forum.juce.com/t/applying-a-wow-flutter-effect-to-a-delay/66691
- JUCE Forum: "Pitch Shifting Delay artifacts and Doppler Effect" - https://forum.juce.com/t/pitch-shifting-delay-smoothing-artifacts-and-the-doppler-effect/41488
- GitHub: anotherdelay - Tape delay with flutter, wow, saturation (JUCE implementation) - https://github.com/dllim/anotherdelay
- GitHub: JUCE_VDL_Pitch-Shifter - Variable delay line pitch shifter - https://github.com/MartinTownley/JUCE_VDL_Pitch-Shifter
- DSP Stack Exchange: "How to model Tape Saturation" - https://dsp.stackexchange.com/questions/17526/how-to-model-tape-saturation-audio-dsp

**Codebase References:**
- TapeAge saturation implementation: `plugins/TapeAge/Source/PluginProcessor.cpp:118-164` (tanh with progressive gain curve, 2x oversampling)
- TapeAge wow/flutter: `plugins/TapeAge/Source/PluginProcessor.cpp:166-214` (single LFO, delay line modulation, ±10 cents)
- GainKnob DJ filter: `plugins/GainKnob/Source/PluginProcessor.cpp:86-130` (exponential cutoff mapping, state reset on type change)

**Key Findings:**
- Freeverb-based reverb (juce::dsp::Reverb) is suitable for plate emulation with proper parameter tuning
- Dual LFOs (wow + flutter) create more complex modulation than single LFO
- Lagrange 3rd-order interpolation is essential for smooth pitch modulation without artifacts
- Tape saturation doesn't require oversampling when applied to reverb tails (natural HF rolloff)
- MOD_MODE routing adds creative flexibility (wet-only for traditional use, wet+dry for extreme warbling)
- State reset on filter type change (GainKnob pattern) prevents burst artifacts
- Base delay of 50ms is sufficient for ±20% modulation depth without buffer underrun
