# DSP Architecture: DriveVerb

**CRITICAL CONTRACT:** This specification is immutable during Stages 2-5 implementation. Stage 1 Planning cannot proceed without this file. Stage 4 (DSP) implements this exact architecture.

**Generated by:** Stage 0 Research
**Referenced by:** Stage 1 (Planning), Stage 4 (DSP Implementation)
**Purpose:** DSP specification defining processing components, signal flow, and JUCE module usage

## Core Components

### Reverb Engine
- **JUCE Class:** `juce::dsp::Reverb`
- **Purpose:** Algorithmic reverb with independent size and decay control
- **Parameters Affected:** `size`, `decay`
- **Configuration:**
  - Size parameter (0-100%) → roomSize (0.0-1.0)
  - Decay parameter (0.5-10s) → damping (0.0-1.0) using logarithmic mapping
  - Width: 1.0 (full stereo)
  - DryLevel: 0.0 (dry signal handled separately for pre/post routing)
  - WetLevel: 1.0 (controlled by dryWet parameter in final mix stage)
  - FreezeMode: 0.0 (disabled)

### DJ-Style Filter
- **JUCE Class:** `juce::dsp::IIR::Filter<float>`
- **Purpose:** Musical frequency shaping with center bypass (DJ-style control)
- **Parameters Affected:** `filter`
- **Configuration:**
  - **Center position (0%):** Filter bypassed (no processing)
  - **Negative values (-1% to -100%):** Low-pass filter
    - Cutoff: 200Hz at -100% → 20kHz at 0% (exponential mapping)
    - Q: 0.707 (Butterworth response)
    - Order: 2nd order (12dB/octave)
  - **Positive values (+1% to +100%):** High-pass filter
    - Cutoff: 20Hz at 0% → 10kHz at +100% (exponential mapping)
    - Q: 0.707 (Butterworth response)
    - Order: 2nd order (12dB/octave)
  - Filter state reset on bypass entry/exit and filter type transitions to prevent residual energy

### Drive Saturation
- **JUCE Class:** `juce::dsp::WaveShaper<float>` with custom transfer function
- **Purpose:** Warm tape saturation (even harmonics) applied ONLY to wet signal
- **Parameters Affected:** `drive`
- **Configuration:**
  - Transfer function: `tanh(x * gain)` for soft clipping with even harmonic content
  - Gain range: 0-24dB → linear gain (1.0 to ~15.85)
  - Applied only to reverb output (dry signal bypasses this stage completely)
  - Output compensated to maintain perceived loudness consistency

### Dry/Wet Mixer
- **JUCE Class:** `juce::dsp::DryWetMixer<float>`
- **Purpose:** Equal-power blend between dry (unprocessed) and wet (processed) signals
- **Parameters Affected:** `dryWet`
- **Configuration:**
  - Mix parameter: 0-100% → 0.0-1.0 (linear mapping)
  - Equal-power crossfade curve for smooth transitions
  - Dry signal: original input (unprocessed)
  - Wet signal: output of PRE/POST routing chain (reverb → filter → drive or reverb → drive → filter)

### Signal Router
- **JUCE Class:** Custom conditional routing logic (not a JUCE class)
- **Purpose:** Route wet signal through filter and drive in different orders
- **Parameters Affected:** `filterPosition`
- **Configuration:**
  - PRE mode (filterPosition == false / 0.0): Reverb → Filter → Drive
  - POST mode (filterPosition == true / 1.0): Reverb → Drive → Filter
  - Switching handled in processBlock with conditional branching

## Processing Chain

### PRE Mode (Filter Position = PRE / 0.0)
```
Input (Dry)
  ↓
  ├─────────────────────────────────────────┐
  ↓                                         ↓
Reverb Engine ← size, decay            (Dry Path: bypassed)
  ↓
DJ-Style Filter ← filter
  ↓
Drive Saturation ← drive
  ↓
(Wet Signal)                              (Dry Signal)
  └─────────────────────────────────────────┘
                    ↓
            Dry/Wet Mixer ← dryWet
                    ↓
                 Output
```

### POST Mode (Filter Position = POST / 1.0)
```
Input (Dry)
  ↓
  ├─────────────────────────────────────────┐
  ↓                                         ↓
Reverb Engine ← size, decay            (Dry Path: bypassed)
  ↓
Drive Saturation ← drive
  ↓
DJ-Style Filter ← filter
  ↓
(Wet Signal)                              (Dry Signal)
  └─────────────────────────────────────────┘
                    ↓
            Dry/Wet Mixer ← dryWet
                    ↓
                 Output
```

## Parameter Mapping

| Parameter ID | DSP Component | Usage Description |
|--------------|---------------|-------------------|
| `size` | Reverb Engine | Room dimensions (0-100% → roomSize 0.0-1.0) - affects early reflection density and spatial character |
| `decay` | Reverb Engine | Reverb tail length (0.5-10s → damping 0.0-1.0) - logarithmic mapping with skew 0.3 for more resolution in short times |
| `dryWet` | Dry/Wet Mixer | Blend between dry and wet (0-100% → 0.0-1.0) - equal-power crossfade |
| `drive` | Drive Saturation | Tape saturation amount (0-24dB → gain 1.0-15.85) - applied only to wet signal |
| `filter` | DJ-Style Filter | Frequency shaping (-100% to +100%) - negative=low-pass, positive=high-pass, 0%=bypass |
| `filterPosition` | Signal Router | Routing switch (0.0=PRE, 1.0=POST) - determines filter placement relative to drive stage |

## Algorithm Details

### Reverb Algorithm
- **Implementation approach:** Use `juce::dsp::Reverb` with parameters mapped from size/decay
- **Key considerations:**
  - Size parameter is linear (0-100%) but maps to roomSize (0.0-1.0) for JUCE API
  - Decay parameter (0.5-10s) requires conversion to damping coefficient (0.0-1.0) using logarithmic mapping to match skew factor 0.3
  - Stereo width fixed at 1.0 for full stereo image
  - DryLevel set to 0.0 (dry signal handled separately for routing flexibility)
- **JUCE helpers available:**
  - `juce::dsp::Reverb::Parameters` struct for configuration
  - `setParameters()` method for runtime updates
  - `process()` method for audio processing

### DJ-Style Filter Algorithm
- **Implementation approach:** Use `juce::dsp::IIR::Filter<float>` with dynamic coefficient generation
- **Key considerations:**
  - Center position (filter == 0.0) completely bypasses IIR processing (no filtering)
  - Exponential frequency mapping for musical sweep (reference GainKnob implementation lines 86-130)
  - Filter type switches between low-pass and high-pass based on parameter sign
  - Filter state (delay buffers) reset on bypass entry/exit and type transitions to prevent clicks/pops
  - Butterworth response (Q=0.707) provides flat passband and smooth rolloff
- **JUCE helpers available:**
  - `juce::dsp::IIR::Coefficients<float>::makeLowPass()` for low-pass coefficients
  - `juce::dsp::IIR::Coefficients<float>::makeHighPass()` for high-pass coefficients
  - `prepare()` method for sample rate/block size setup
  - `reset()` method for clearing filter state

### Drive Saturation Algorithm
- **Implementation approach:** Use `juce::dsp::WaveShaper<float>` with `tanh()` transfer function for soft clipping
- **Key considerations:**
  - Even harmonic saturation for warm, tape-like character
  - 0-24dB gain range provides subtle to aggressive saturation
  - Applied ONLY to wet signal (dry signal bypasses this stage)
  - Output gain compensation to maintain consistent perceived loudness
  - Transfer function: `y = tanh(x * dB_to_gain(drive))`
- **JUCE helpers available:**
  - `juce::dsp::WaveShaper<float>` with custom function callback
  - `functionToUse` parameter for setting transfer function
  - `Decibels::decibelsToGain()` for dB → linear gain conversion

### Dry/Wet Mixing Algorithm
- **Implementation approach:** Use `juce::dsp::DryWetMixer<float>` for equal-power crossfade
- **Key considerations:**
  - Equal-power crossfade prevents perceived volume dip at 50% mix
  - Linear parameter (0-100%) maps to 0.0-1.0 for JUCE API
  - Dry signal: original unprocessed input
  - Wet signal: output of routing chain (reverb → filter → drive or reverb → drive → filter)
- **JUCE helpers available:**
  - `pushDrySamples()` to store dry signal before processing
  - `mixWetSamples()` to blend processed signal with stored dry signal
  - `setWetMixProportion()` for runtime mix ratio updates

## Special Considerations

### Thread Safety
- All parameters read atomically using `juce::AudioProcessorValueTreeState`
- Parameter updates occur only in `prepareToPlay()` or `processBlock()`, never during audio callback interruptions
- Filter coefficient generation happens in audio thread (fast enough for real-time with IIR)
- No heap allocations in audio thread

### Performance
- Reverb is CPU-intensive - monitor performance with large buffer sizes
- Filter bypassed completely when `filter == 0.0` (no IIR processing overhead)
- Drive stage uses simple `tanh()` function (CPU-efficient waveshaping)
- Dry/Wet mixer uses JUCE-optimized equal-power crossfade
- No oversampling implemented (trading aliasing for performance) - consider adding in v2 if aliasing audible

### Denormal Protection
- JUCE `ScopedNoDenormals` used in `processBlock()` to prevent CPU spikes
- Reverb output checked for denormals before drive stage
- Filter state reset on bypass prevents denormal accumulation in delay buffers

### Sample Rate Handling
- All DSP components call `prepare(spec)` in `prepareToPlay()` with correct sample rate
- Filter cutoff frequencies scale with sample rate (20Hz-20kHz valid for 44.1kHz and above)
- Reverb decay time independent of sample rate (handled internally by `juce::dsp::Reverb`)
- Parameter smoothing uses sample rate for time-based ramps

## Research References

### JUCE Documentation
- **dsp::Reverb:** https://docs.juce.com/master/classdsp_1_1Reverb.html
  - Algorithmic reverb processor with room size, damping, width controls
  - Used by many JUCE community projects (simple-reverb, RSAlgorithmicVerb)
- **dsp::IIR::Filter:** https://docs.juce.com/master/classdsp_1_1IIR_1_1Filter.html
  - IIR filtering with Transposed Direct Form II structure
  - Butterworth coefficient generation via `FilterDesign` class
- **dsp::WaveShaper:** https://docs.juce.com/master/structdsp_1_1WaveShaper.html
  - Applies waveshaping transfer functions for distortion/saturation
  - Tutorial: "Add distortion through waveshaping and convolution"
- **dsp::DryWetMixer:** Standard JUCE DSP helper for equal-power mixing

### Professional Examples
- **Valhalla Room** - Industry-standard algorithmic reverb
  - Decay range: 0.1s - 70s (we use 0.5s - 10s for musical applications)
  - Room size: Continuous scale from small to cathedral (we use 0-100%)
- **FabFilter Pro-R** - Modern algorithmic reverb with drive/character
  - Character control adds harmonic content (similar to our drive parameter)
  - Space control similar to our size parameter
- **UAD Galaxy Tape Echo** - Tape saturation reference
  - Even harmonic saturation using `tanh()` waveshaping (we use same approach)
  - 0-24dB drive range typical for tape emulations
- **Xfer Records LFO Tool** - DJ-style filter reference
  - Center position bypass, negative=low-pass, positive=high-pass (same as our design)
  - Exponential frequency mapping for musical sweep

### Technical Resources
- **JUCE Forum - "Add odd/even harmonics to a signal through distortion"**
  - Discussion on `tanh()` vs polynomial waveshapers for harmonic control
  - Even harmonics achieved with symmetric transfer functions
- **ADC17 - "Fifty Shades of Distortion"**
  - Comprehensive talk on waveshaper implementations in JUCE
  - Code samples for `tanh()` and other transfer functions
- **JUCE Tutorial - "Introduction to DSP"**
  - Overview of `dsp::ProcessorChain` for chaining reverb, filter, waveshaper
  - Best practices for `prepare()`, `process()`, and parameter updates
- **GainKnob Filter Implementation (PluginProcessor.cpp:86-130)**
  - Reference for DJ-style filter with exponential frequency mapping
  - Filter state reset strategy to prevent clicks/pops

### Key Findings
- **JUCE Reverb Limitations:** `juce::dsp::Reverb` is simple algorithmic reverb (not plate/hall specific) - sufficient for DriveVerb but consider custom FDN reverb in v2 for more character
- **Filter Performance:** `dsp::StateVariableFilter` recommended for fast modulation, but `dsp::IIR::Filter` sufficient for static/slow parameter changes (our use case)
- **Saturation Character:** `tanh()` provides even harmonics when applied symmetrically - confirmed by JUCE community discussions and ADC17 talk
- **Routing Strategy:** Conditional branching for PRE/POST routing is efficient (no overhead when branch prediction works) - no need for complex graph routing
- **Industry Standards:** Professional reverbs use 0.1s-70s decay range, but 0.5s-10s covers 95% of musical applications (we match parameter spec)
