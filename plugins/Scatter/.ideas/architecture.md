# DSP Architecture: Scatter

**CRITICAL CONTRACT:** This specification is immutable during Stages 2-4 implementation. Stage 2 (Foundation + Shell) cannot proceed without this file. Stage 3 (DSP) implements this exact architecture.

**Generated by:** Stage 0 Research
**Referenced by:** Stage 2 (Foundation + Shell), Stage 3 (DSP Implementation)
**Purpose:** DSP specification defining processing components, signal flow, and JUCE module usage

---

## Core Components

### Granular Delay Buffer
- **JUCE Class:** `juce::dsp::DelayLine<float, juce::dsp::DelayLineInterpolationTypes::Lagrange3rd>`
- **Purpose:** Store incoming audio for grain reading with interpolated playback
- **Parameters Affected:** delay_time
- **Configuration:**
  - Buffer size: delay_time parameter (100-2000ms) at current sample rate
  - Write continuously at current sample position
  - Grains read from various positions with fractional-sample interpolation
  - Lagrange 3rd-order interpolation for smooth pitch shifting via playback rate
  - Tempo sync: Recalculate delay time when DAW tempo changes

### Grain Voice Engine
- **JUCE Class:** Custom implementation (polyphonic voice management)
- **Purpose:** Manage multiple simultaneous grain playbacks with independent states
- **Parameters Affected:** grain_size, density, pitch_random, pan_random, feedback
- **Configuration:**
  - Voice count: 64 maximum simultaneous grains
  - Voice structure per grain:
    - Read position in delay buffer (float for interpolation)
    - Window position (0.0-1.0 progress through grain envelope)
    - Playback direction (forward/reverse boolean)
    - Pitch shift amount (semitones, quantized to scale)
    - Pan position (0.0-1.0, left to right)
    - Grain size in samples
    - Active flag (is voice currently playing)
  - Voice allocation: Linear search for inactive voice, voice stealing if all busy
  - Container: `std::array<GrainVoice, 64>`

### Grain Scheduler
- **JUCE Class:** Custom implementation (sample-based timer)
- **Purpose:** Trigger new grains based on density parameter (overlap control)
- **Parameters Affected:** density, grain_size
- **Configuration:**
  - Spawn interval calculation: `grainSizeSamples / (density * overlapFactor)`
  - Overlap factor: ~2.0 (grains overlap at 50% density)
  - Example: 100ms grain, 50% density → spawn every ~100ms (one grain active at a time at 50%, multiple overlapping at higher density)
  - Sample counter: Incremented each processBlock, triggers grain when counter >= interval
  - Reset counter after grain spawn

### Window Function Generator
- **JUCE Class:** `juce::dsp::WindowingFunction<float>`
- **Purpose:** Apply smooth amplitude envelope to grains to prevent clicks on start/end
- **Parameters Affected:** grain_size (determines window length)
- **Configuration:**
  - Window type: Hann window (`juce::dsp::WindowingFunction<float>::hann`)
  - Pre-calculated lookup table (computed once at grain spawn)
  - Applied as multiplication: `grainOutput = bufferSample * window[windowPos]`
  - Window size matches grain_size parameter

### Pitch Shifter (Playback Rate)
- **JUCE Class:** Custom implementation (playback rate adjustment)
- **Purpose:** Shift grain pitch via playback speed variation (granular time-stretching)
- **Parameters Affected:** pitch_random
- **Configuration:**
  - Pitch range: ±7 semitones (random within range, scaled by pitch_random 0-100%)
  - Playback rate formula: `rate = 2^(semitones / 12)`
  - Examples:
    - +7 semitones (perfect fifth) → rate ≈ 1.498 (play 50% faster)
    - -7 semitones → rate ≈ 0.661 (play 34% slower)
  - Read position increment per sample: `readPos += playbackRate`
  - Fractional positions handled by DelayLine interpolation

### Scale Quantization System
- **JUCE Class:** Custom implementation (lookup tables + nearest-note algorithm)
- **Purpose:** Snap random pitch shifts to musical scale for harmonic coherence
- **Parameters Affected:** pitch_random, scale, root_note
- **Configuration:**
  - Scale tables (semitone intervals within octave):
    - Chromatic: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] (all notes, no quantization)
    - Major: [0, 2, 4, 5, 7, 9, 11]
    - Minor: [0, 2, 3, 5, 7, 8, 10]
    - Pentatonic: [0, 2, 4, 7, 9]
    - Blues: [0, 3, 5, 6, 7, 10]
  - Quantization algorithm:
    1. Generate random pitch: -7 to +7 semitones (uniform distribution)
    2. Scale by pitch_random: `actualRange = 7 * (pitch_random / 100)`
    3. Find nearest scale degree in selected scale
    4. Transpose by root_note (0-11 semitones)
    5. Return quantized pitch for playback rate calculation
  - Container: `std::array<std::vector<int>, 5>` (5 scale types)

### Random Pan Generator
- **JUCE Class:** `juce::Random` (from `juce_core`)
- **Purpose:** Randomize stereo position per grain for spatial texture
- **Parameters Affected:** pan_random
- **Configuration:**
  - Pan range: 0.0 (full left) to 1.0 (full right)
  - Random value: `juce::Random::getSystemRandom().nextFloat()`
  - Pan amount scaled by parameter: `randomPan = 0.5 + (random - 0.5) * (pan_random / 100)`
  - At 0%, all grains centered (0.5)
  - At 100%, full stereo spread (0.0-1.0)
  - Applied per grain: `leftGain = (1.0 - pan)`, `rightGain = pan`

### Reverse Playback System
- **JUCE Class:** Custom implementation (direction flag per grain)
- **Purpose:** Play grains forward or backward for textural variation
- **Parameters Affected:** None (always 50/50 probability)
- **Configuration:**
  - Random selection per grain: `juce::Random::getSystemRandom().nextBool()`
  - Forward: `readPos += playbackRate`
  - Reverse: `readPos -= playbackRate`
  - Window envelope always applied forward (grain fades in/out same direction)
  - Buffer boundary handling: Wrap around delay buffer if readPos goes negative or exceeds buffer size

### Feedback Loop
- **JUCE Class:** Custom implementation (manual buffer mixing)
- **Purpose:** Feed processed grain output back into delay buffer input for evolving textures
- **Parameters Affected:** feedback
- **Configuration:**
  - Feedback gain: 0.0-0.95 (0-100% parameter mapped to avoid runaway feedback)
  - Formula: `inputSample = drySample + (grainOutput * feedbackGain)`
  - Write to delay buffer: Combined dry + feedback signal
  - Feedback signal includes: Grain processing, pitch shifts, pan (stereo feedback)
  - Feedback limiting: Soft clip or tanh at high feedback to prevent instability

### Dry/Wet Mixer
- **JUCE Class:** `juce::dsp::DryWetMixer<float>`
- **Purpose:** Blend unprocessed input with granular-processed output
- **Parameters Affected:** mix
- **Configuration:**
  - MIX (0-100%) maps to wet proportion (0.0-1.0)
  - `pushDrySamples()` before processing chain
  - `setWetMixProportion()` for blend control
  - `mixWetSamples()` after grain processing

---

## Processing Chain

```
Input (Stereo)
  ↓
Dry/Wet Mixer (capture dry) ← MIX
  ↓
Write to Granular Delay Buffer ← delay_time (with feedback signal mixed in)
  ↓
Grain Scheduler (trigger new grains) ← density, grain_size
  ↓
For each active grain (up to 64 voices):
  ↓
  ├─ Read from Delay Buffer (interpolated) ← Pitch-shifted playback rate
  ├─ Apply Window Envelope ← grain_size
  ├─ Apply Pan Position ← pan_random
  └─ Reverse Playback (if selected)
  ↓
Sum all active grain outputs
  ↓
Apply Feedback Gain ← feedback
  ↓
Mix feedback back to delay buffer input
  ↓
Dry/Wet Mixer (blend) ← MIX
  ↓
Output (Stereo)
```

**Routing notes:**
- Feedback loop: Grain output → Feedback gain → Mixed with dry input → Delay buffer write position
- Parallel grain voices: All 64 voices process independently, outputs summed
- Stereo processing: Each channel has independent grain voice states (128 total voices for stereo)
- Tempo sync: Delay buffer size recalculated on tempo change (from DAW playhead)

---

## System Architecture

### Tempo Sync System

**DAW integration:** Query host for tempo information

**JUCE classes:**
- `juce::AudioPlayHead` - Host transport state
- `juce::AudioPlayHead::getPosition()` - Get current tempo (BPM)

**Implementation:**
- Query playhead in `prepareToPlay()` and periodically in `processBlock()`
- Detect tempo changes: Compare current BPM to cached BPM
- On tempo change:
  - Recalculate delay buffer size for current delay_time at new tempo
  - Preserve grain voices if possible (or clear and restart scheduler)
- Optional: Sync delay_time to musical divisions (1/4 note, 1/8 note, etc.)

**Error handling:**
- If playhead unavailable (offline bounce): Use default 120 BPM
- If tempo is invalid (<20 BPM or >300 BPM): Clamp to valid range

---

### Real-Time Visualization (Particle Field)

**Data requirements:** Stream grain positions (stereo, time, pitch) to JavaScript UI

**Data structure per grain:**
- X-axis: Time position in delay buffer (0-1 normalized)
- Y-axis: Pitch shift amount (-1 to +1, representing -7 to +7 semitones)
- Color/Size: Pan position (left grains vs right grains)

**JUCE implementation:**
- Collect active grain states in `processBlock()` (non-blocking)
- Throttle updates: 30-60 Hz max (avoid UI thread saturation)
- Use `juce::Timer` callback to send data batch to JavaScript
- Data format: Array of `{x: float, y: float, pan: float, active: bool}` for up to 64 grains

**JavaScript visualization:**
- Canvas or SVG rendering (200×200px particle field)
- Particle glow effects (CSS filters or canvas radial gradients)
- Smooth animation: Interpolate grain positions between updates (60fps with lerp)
- Particle lifecycle: Fade in on grain spawn, fade out on grain end

**Performance considerations:**
- Limit data transfer to active grains only (skip inactive voices)
- Use binary format if JSON too slow (TypedArray)
- Debounce updates if CPU usage high

---

## Parameter Mapping

| Parameter ID | Type | Range | DSP Component | Usage |
|-------------|------|-------|---------------|-------|
| delay_time | Float | 100-2000ms | Granular Delay Buffer | Buffer size (samples at current rate) |
| grain_size | Float | 5-500ms | Window Function, Grain Scheduler | Window length, spawn interval calculation |
| density | Float | 0-100% | Grain Scheduler | Grain spawn frequency (overlap amount) |
| pitch_random | Float | 0-100% | Pitch Shifter, Scale Quantization | Amount of pitch randomization (±7 semitone scaling) |
| scale | Choice | 0-4 | Scale Quantization | Which scale to quantize to (Chromatic/Major/Minor/Pentatonic/Blues) |
| root_note | Choice | 0-11 | Scale Quantization | Root transposition (C through B) |
| pan_random | Float | 0-100% | Random Pan Generator | Amount of stereo randomization (0% = center, 100% = full spread) |
| feedback | Float | 0-100% | Feedback Loop | Feedback gain (0.0-0.95 to prevent runaway) |
| mix | Float | 0-100% | Dry/Wet Mixer | Wet proportion (0.0-1.0) |

---

## Algorithm Details

### Granular Synthesis Engine

**Algorithm:** Overlapping-grain playback with polyphonic voice management

**Implementation notes:**
- Voice allocation: Find first inactive voice in array, reuse if all voices busy (steal oldest grain near completion)
- Grain spawn calculation:
  ```cpp
  float overlapFactor = 2.0f; // At 50% density, grains overlap by 50%
  int spawnInterval = grainSizeSamples / (density * overlapFactor);
  sampleCounter++;
  if (sampleCounter >= spawnInterval) {
      spawnNewGrain();
      sampleCounter = 0;
  }
  ```
- Per-grain processing loop:
  ```cpp
  for (auto& grain : activeGrains) {
      if (!grain.active) continue;

      float windowValue = hannWindow[grain.windowPos];
      float bufferSample = delayBuffer.popSample(grain.readPos); // Interpolated
      float grainSample = bufferSample * windowValue;

      // Apply pan
      leftOutput += grainSample * (1.0f - grain.pan);
      rightOutput += grainSample * grain.pan;

      // Advance positions
      grain.readPos += (grain.reverse ? -grain.playbackRate : grain.playbackRate);
      grain.windowPos += 1.0f / grain.grainSizeSamples;

      if (grain.windowPos >= 1.0f) {
          grain.active = false; // Grain completed
      }
  }
  ```

---

### Pitch Shifting via Playback Rate

**Algorithm:** Time-domain pitch shift (playback speed variation)

**Implementation notes:**
- Playback rate calculation: `rate = pow(2.0f, semitones / 12.0f)`
- Coefficient calculation: Use `<cmath>` `std::pow()`
- Interpolation: Handled by `juce::dsp::DelayLine` with Lagrange3rd
- Edge case: Extreme pitch shifts (±7 semitones) may cause grain to read beyond buffer
  - Solution: Wrap read position modulo buffer size

---

### Scale Quantization

**Algorithm:** Nearest-note quantization to scale lookup table

**Implementation notes:**
- Generate random pitch: `randomPitch = (Random::nextFloat() * 2.0f - 1.0f) * 7.0f * (pitchRandom / 100.0f)`
  - Range: -7 to +7 semitones, scaled by parameter
- Find nearest scale degree:
  ```cpp
  int octave = (int)randomPitch / 12;
  int semitone = abs((int)randomPitch % 12);
  int nearestScaleDegree = scaleTable[selectedScale].findNearest(semitone);
  int quantizedPitch = octave * 12 + nearestScaleDegree + rootNote;
  ```
- Transpose by root note (simple addition)
- Return quantized pitch for playback rate calculation

---

### Windowing (Anti-Click)

**Algorithm:** Hann window envelope

**Implementation notes:**
- Window formula: `hann[n] = 0.5 * (1.0 - cos(2 * PI * n / N))`
- Pre-calculate window table at grain spawn:
  ```cpp
  std::vector<float> window(grainSizeSamples);
  juce::dsp::WindowingFunction<float>::fillWindowingTables(
      window.data(), grainSizeSamples,
      juce::dsp::WindowingFunction<float>::hann, false);
  ```
- Apply per-sample: `output = bufferSample * window[windowPosition]`
- Window position increments linearly from 0 to grainSizeSamples

---

## Integration Points

### Feature Dependencies

- **Grain scheduler → Voice engine:** Scheduler triggers grain spawns, voice engine allocates voices
- **Voice engine → Delay buffer:** Voices read from delay buffer at various positions
- **Pitch shifter → Scale quantization:** Pitch amount must be quantized before playback rate calculation
- **Scale quantization → Voice engine:** Quantized pitch stored in voice structure
- **Feedback loop → Delay buffer:** Feedback output mixed with delay buffer input
- **All grain voices → Dry/wet mixer:** Summed grain output blended with dry signal

---

### Parameter Interactions

- **grain_size affects density spawn rate:**
  - Larger grains → longer spawn intervals (even at same density %)
  - Example: 50ms grain at 50% density spawns more frequently than 200ms grain at 50% density

- **pitch_random affects scale quantization:**
  - 0% pitch_random → all grains at root note (no randomization)
  - 100% pitch_random → full ±7 semitone range, then quantized to scale

- **feedback affects texture evolution:**
  - Low feedback (0-30%) → sparse, decaying grains
  - Medium feedback (30-60%) → sustained texture with gradual evolution
  - High feedback (60-95%) → dense, self-reinforcing granular cloud

- **scale + root_note determine harmonic character:**
  - Chromatic: All 12 semitones available (microtonal-ish)
  - Major/Minor: Tonal/harmonic results
  - Pentatonic/Blues: Constrained but always musical

---

### Processing Order Requirements

**Sequential processing order (REQUIRED):**

1. **Capture dry signal:** Store input in DryWetMixer before any processing
   - Must happen first to preserve clean input

2. **Mix feedback with input:** Combine dry input with feedback signal from previous cycle
   - Feedback from grain output → scaled by feedback gain → added to current input

3. **Write to delay buffer:** Store (dry + feedback) signal in delay buffer
   - Grains will read from this buffer containing both input and feedback

4. **Grain scheduler tick:** Check if new grain should spawn based on sample counter
   - Spawn interval based on density and grain_size

5. **Spawn new grain (if triggered):** Allocate voice, randomize parameters
   - Randomize: Pitch (then quantize), pan, reverse/forward direction
   - Calculate playback rate from quantized pitch
   - Pre-calculate window envelope for grain_size

6. **Process all active grains:** Read from delay buffer, apply window, pan
   - Each grain reads at its own position with playback rate
   - Apply window envelope (anti-click)
   - Apply pan (stereo positioning)
   - Sum all grain outputs

7. **Apply feedback gain:** Scale grain output for feedback loop
   - Feedback signal stored for next cycle (step 2)

8. **Blend with dry signal:** Mix grain output with captured dry
   - DryWetMixer combines based on mix parameter

**Why order matters:**
- Dry capture first: Prevents latency-corrupted dry signal
- Feedback before write: Feedback must be mixed with input before buffer write
- Grain spawn after write: Grains read from buffer containing latest input + feedback
- Feedback gain after grain sum: Feedback amount controls texture evolution

---

### Thread Boundaries

**Threads:**
- **Audio thread:** All DSP processing in `processBlock()`
- **Message thread:** UI interactions, parameter updates, visualization timer
- **No background thread needed:** All processing is real-time

**Audio thread:**
- Grain processing (voice management, window application, buffer reads)
- Delay buffer write/read
- Feedback mixing
- Parameter reads via `APVTS::getRawParameterValue()->load()` (atomic)

**Message thread:**
- Parameter updates from UI via APVTS (atomic writes)
- Visualization timer callback (collect grain states, send to JavaScript)
- Preset loading/saving

**Communication:**
- APVTS parameters: Atomic reads (audio thread) / atomic writes (message thread)
- Grain state for visualization: Copy grain positions to temporary buffer (audio thread), read in timer callback (message thread)
- No locks needed in audio thread (visualization data is read-only copy)

**Safety guarantees:**
- Audio thread NEVER allocates memory (pre-allocated voice array)
- Audio thread NEVER waits on locks
- Visualization updates are non-blocking (audio thread continues if UI busy)

---

## Implementation Risks

### Granular Synthesis Engine

**Complexity:** HIGH
- Polyphonic voice management (64 voices)
- Real-time grain scheduling
- Window function application per grain
- Complex state management

**Risk Level:** MEDIUM

**Risk factors:**
1. CPU usage with 64 simultaneous grains may be high
   - Each grain: Buffer read (interpolated), window multiplication, pan calculation
   - Estimated: ~40-60% CPU at 64 voices, 48kHz
2. Voice allocation logic must be efficient (linear search per grain spawn)
3. Buffer boundary handling for reverse playback and pitch-shifted reads

**Alternative approaches:**
1. **Fixed lower voice count (32 voices):**
   - Complexity: Same
   - CPU: ~20-30% (lower)
   - Quality: Less dense textures (may lose "stuttering grains" character)

2. **Simpler window (linear ramp):**
   - Complexity: Lower
   - CPU: ~5-10% savings
   - Quality: More clicks (Hann window is standard for good reason)

**Fallback architecture:**
- **Primary:** 64 polyphonic grain voices with Hann window
- **Fallback 1:** Reduce to 32 voices if CPU exceeds 60% single core
- **Fallback 2:** Reduce to 16 voices with linear window (lowest quality)
- **Trigger:** Profile CPU in Stage 3, adjust voice count if needed

**Mitigation strategy:**
1. Pre-calculate window lookup tables (not per-sample calculation)
2. Profile voice processing loop early (Stage 3 Phase 1)
3. Consider SIMD optimization if needed (juce::FloatVectorOperations)
4. Test with extreme parameters (100% density, 5ms grain size) for worst-case CPU

---

### Pitch Shifting via Playback Rate

**Complexity:** MEDIUM
- Playback rate calculation straightforward
- Interpolated buffer reads handled by JUCE DelayLine

**Risk Level:** LOW

**Risk factors:**
1. Extreme pitch shifts (±7 semitones) may cause grain to read beyond buffer
2. Interpolation artifacts at high playback rates (>1.5)

**Alternative approaches:**
1. **Limit pitch range to ±5 semitones:**
   - Reduces risk of buffer overruns and artifacts
   - Less extreme pitch shifts (more conservative)

**Fallback architecture:**
- **Primary:** ±7 semitone range with Lagrange3rd interpolation
- **Fallback:** ±5 semitone range with Linear interpolation (if artifacts present)

**Mitigation:**
- Buffer boundary wrapping (modulo buffer size)
- Test with extreme pitch_random = 100% and short grains (5ms)

---

### Scale Quantization System

**Complexity:** LOW
- Lookup table implementation is straightforward
- Nearest-note algorithm is simple

**Risk Level:** LOW

**Risk factors:**
1. Edge case: Octave wrapping for pitches beyond ±12 semitones
2. Root note transposition may push pitch out of range

**Fallback architecture:**
- Primary approach is solid, no fallback needed

**Mitigation:**
- Clamp final pitch to ±12 semitones (prevent extreme playback rates)

---

### Real-Time Visualization (Particle Field)

**Complexity:** MEDIUM
- Data streaming from audio thread to UI
- JavaScript particle animation

**Risk Level:** MEDIUM

**Risk factors:**
1. Data transfer overhead (64 grain positions @ 30-60Hz)
2. JavaScript animation performance (200×200px canvas with 64 particles)
3. Potential for UI thread to block audio thread if not careful

**Alternative approaches:**
1. **Reduce visualization grain count (show 16 grains):**
   - Lower data transfer overhead
   - Still conveys granular activity

2. **Static visualization (no real-time updates):**
   - Just show parameter positions (density, pitch_random, etc.)
   - No grain position streaming needed

**Fallback architecture:**
- **Primary:** Real-time particle field (64 grains @ 30Hz)
- **Fallback 1:** Reduce to 16 visible grains if performance issues
- **Fallback 2:** Static visualization showing parameter values only (no streaming)
- **Trigger:** If UI becomes sluggish or audio dropouts occur

**Mitigation:**
1. Throttle updates to 30Hz (not 60Hz)
2. Copy grain data to separate buffer (don't lock audio thread)
3. Use `requestAnimationFrame` in JavaScript for smooth rendering
4. Test on lower-end hardware early

---

### Overall Project Risk

**Overall complexity:** HIGH
- Granular engine (HIGH) + pitch shifting (MEDIUM) + visualization (MEDIUM)
- Multiple complex features with interdependencies

**Highest risk component:** Granular Synthesis Engine
- Represents ~60% of project risk
- Most CPU-intensive
- Complex voice management
- Critical for plugin's core functionality

**Recommended approach:**
1. **Phase 1 - Core engine (4-6 hours):** Implement grain voices, scheduler, windowing, basic playback
2. **Phase 2 - Pitch + quantization (2-3 hours):** Add playback rate pitch shifting, scale quantization
3. **Phase 3 - Spatial + feedback (2-3 hours):** Add pan randomization, reverse playback, feedback loop
4. **Phase 4 - Polish (2-3 hours):** Optimize CPU, tune parameters, dry/wet mixing
5. **Phase 5 - Visualization (3-4 hours):** Implement particle field data streaming and rendering

**Total estimated time:** 13-19 hours (Stage 3 DSP implementation)

---

## Architecture Decisions

### Playback Rate Pitch Shifting (vs Phase Vocoder)

**Decision:** Use playback rate adjustment for pitch shifting (time-domain)

**Rationale:**
- Standard approach for granular synthesis (Portal, GrainScanner, Particle)
- Lower CPU usage (~10-15% per grain vs ~40% for phase vocoder)
- Lower latency (no FFT window delay)
- Simpler implementation (single formula: `rate = 2^(semitones/12)`)
- Artifacts are acceptable for granular textures (slight "chipmunk" effect on extreme shifts)

**Alternatives considered:**
1. **Phase vocoder (FFT-based):**
   - Why rejected: Much higher CPU cost, adds latency, overkill for granular grains
   - When to reconsider: If playback rate artifacts are unacceptable (unlikely for granular textures)

2. **Formant-preserving pitch shift:**
   - Why rejected: Not needed for abstract granular textures, adds complexity
   - When to reconsider: If used on vocals where formant preservation matters

**Tradeoffs accepted:**
- **Slight timbral change at extreme pitch shifts:** Playback rate affects formants (chipmunk/monster voice)
  - Acceptable because: Granular synthesis is textural/abstract, not pristine pitch shifting
- **Grain duration changes with pitch:** Higher pitch = shorter grain playback time
  - Acceptable because: Window envelope compensates, grains are already short (5-500ms)

**When to revisit:**
- If users report unacceptable artifacts on pitched grains (switch to phase vocoder fallback)

---

### Polyphonic Grain Voices (vs Single Grain)

**Decision:** Implement polyphonic grain voice management (64 simultaneous grains)

**Rationale:**
- Creative brief specifies "stuttering grains" requiring overlapping playback
- Density parameter controls overlap amount (50% = moderate overlap, 100% = dense cloud)
- Professional granular processors use polyphonic voices (Portal, GrainScanner)
- Enables rich, evolving textures (not just single-grain playback)

**Alternatives considered:**
1. **Single grain at a time:**
   - Why rejected: Doesn't match "stuttering grains" vision, textures too sparse
   - When to reconsider: If CPU usage with 64 voices is unacceptable

2. **Fixed 8-16 voices:**
   - Why rejected: Arbitrary limitation, 64 voices proven feasible with optimization
   - When to reconsider: As CPU optimization fallback

**Tradeoffs accepted:**
- **Higher CPU usage:** 64 voices vs 1 voice (~40-60% CPU vs ~1%)
  - Acceptable because: Granular synthesis is inherently CPU-intensive, target is studio use
- **Complex voice management:** Voice allocation, stealing, state tracking
  - Acceptable because: Well-understood pattern (similar to polyphonic synths), manageable complexity

**When to revisit:**
- If CPU exceeds 80% single core (reduce to 32 voices)
- If voice allocation becomes bottleneck (optimize or reduce count)

---

### Delay-Line-Based Granular (vs Live Input Granular)

**Decision:** Use delay buffer as grain source (granular delay architecture)

**Rationale:**
- Creative brief describes "granular reversed delay" (delay is explicit)
- Delay buffer allows grains to read from past audio (delay_time parameter)
- Feedback loop creates evolving textures (delay feedback + granular processing)
- Matches professional granular delay implementations (Particle, H-Delay reverse)

**Alternatives considered:**
1. **Live input granular (no delay buffer):**
   - Why rejected: Doesn't match "delay" aspect of creative brief
   - When to reconsider: If used for real-time granular effects (not this plugin's vision)

**Tradeoffs accepted:**
- **Memory usage:** 2000ms delay buffer at 48kHz = ~192KB per channel
  - Acceptable because: Small memory footprint, delay buffer is essential for concept

**When to revisit:**
- Not anticipated (delay buffer is core to architecture)

---

## Special Considerations

### Thread Safety
- All parameter reads use atomic `getRawParameterValue()->load()` (APVTS)
- No shared state between audio and message threads (grain data copied for visualization)
- Voice array pre-allocated in `prepareToPlay()` (no allocations in `processBlock()`)
- Grain scheduler uses sample counter (no time-based operations in audio thread)

### Performance
- **Estimated CPU usage:**
  - Granular engine (64 voices): ~40-50% single core
  - Pitch shifting (playback rate): ~5-10%
  - Window application: ~5%
  - Total: ~50-65% single core at 48kHz, 512 sample buffer
- **Optimization opportunities:**
  - Pre-calculate window lookup tables (avoid per-sample calculation)
  - Use SIMD for grain summing (`juce::FloatVectorOperations::add`)
  - Early-exit inactive voices (skip processing if `active == false`)
- **Buffer size sensitivity:**
  - Smaller buffers (64 samples) → more frequent `processBlock()` calls → higher overhead
  - Larger buffers (2048 samples) → better CPU efficiency

### Denormal Protection
- Use `juce::ScopedNoDenormals` in `processBlock()`
- Grain voices may produce denormals near window end (fade to zero)
- DelayLine and DryWetMixer handle denormals internally

### Sample Rate Handling
- Delay buffer resized in `prepareToPlay()` based on sample rate
- Grain scheduler recalculates spawn interval on sample rate change
- Window function tables regenerated for new grain sizes
- Playback rate calculation is sample-rate-independent (semitone formula)

**Sample rate scaling:**
- 44.1kHz: delay_time 1000ms = ~44,100 samples
- 48kHz: delay_time 1000ms = ~48,000 samples
- 96kHz: delay_time 1000ms = ~96,000 samples (larger buffer)

### Latency
- **Processing latency sources:**
  - Delay buffer: 100-2000ms (user-controlled via delay_time)
  - Grain window: 5-500ms (grain_size)
  - No FFT latency (time-domain pitch shifting)
- **Host compensation:**
  - Report delay_time as latency via `getLatencySamples()` if delay is fixed
  - If delay_time is modulated, latency reporting may be inaccurate (acceptable for creative effect)

---

## Research References

### Professional Plugins

1. **Output Portal**
   - Granular delay with pitch shifting, scale quantization, feedback
   - Parameters: DENSITY, GRAIN SIZE, PITCH, REVERSE, FEEDBACK, PAN
   - XY visualization for pitch/movement (similar to particle field)
   - Industry standard for granular delay processing
   - Observed: Scale quantization is key for musical results

2. **Red Panda Particle**
   - Hardware granular delay pedal
   - Delay-line-based granular architecture (matches Scatter approach)
   - Each grain reads from delay line with different delay time/playback rate
   - Observed: Reverse playback probability per grain confirmed viable

3. **GrainScanner (Max for Live)**
   - Granular synthesis with grain cloud visualization
   - Grain spawn rate controls density
   - Window shapes: Hanning, Hamming (confirmed standard)
   - Observed: Polyphonic grain playback is standard approach

4. **Audio Damage Quanta 2**
   - Granular synthesis with pitch/formant control
   - Grain sizes: 1-100ms typical
   - Observed: Playback rate pitch shifting standard for granular (not phase vocoder)

### JUCE Documentation

- **juce::dsp::DelayLine:** Variable delay with interpolation types (Linear, Lagrange3rd)
  - Lagrange3rd recommended for pitch modulation (smooth, low artifacts)
  - Prepare with ProcessSpec, process with AudioBlock
- **juce::dsp::WindowingFunction:** Pre-calculated window tables (Hann, Hamming, Blackman)
  - `fillWindowingTables()` for lookup table generation
- **juce::dsp::DryWetMixer:** Latency-compensated dry/wet mixing
  - `pushDrySamples()` → process → `mixWetSamples()`
- **juce::Random:** Thread-safe random number generation
  - `getSystemRandom().nextFloat()` for 0.0-1.0 range
  - `getSystemRandom().nextBool()` for true/false

### Technical Resources

- **Granular Synthesis Basics (Sound on Sound):** Overview of grain-based processing, windowing, overlap-add
- **Red Panda Blog: "Particle History - Creating a Granular Delay":** Delay-line-based granular architecture
- **DSP Concepts: Granular Synthesis Module:** Voice management patterns, grain scheduling algorithms
- **Stack Overflow: "How to implement granular synthesis (pitch shifter)?":** Playback rate pitch shifting, window function application

---

## Notes

- Playback rate pitch shifting is time-domain (not frequency-domain) - simpler and lower latency
- Scale quantization lookup tables are small (~60 bytes total for 5 scales)
- Grain voice count (64) may need tuning based on CPU profiling in Stage 3
- Visualization particle field is optional enhancement (can be deferred to Stage 4 or /improve)
- Reverse playback always 50/50 probability (no parameter control in v1.0.0)
- Tempo sync is optional feature (can default to free-running if DAW playhead unavailable)
