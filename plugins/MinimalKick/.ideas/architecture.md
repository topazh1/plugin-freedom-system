# DSP Architecture: MinimalKick

**CRITICAL CONTRACT:** This specification is immutable during Stages 2-5 implementation. Stage 1 Planning cannot proceed without this file. Stage 4 (DSP) implements this exact architecture.

**Generated by:** Stage 0 Research (2025-11-12)
**Referenced by:** Stage 1 (Planning), Stage 4 (DSP Implementation)
**Purpose:** DSP specification defining processing components, signal flow, and JUCE module usage

---

## Core Components

### Sine Wave Oscillator
- **JUCE Class:** `juce::dsp::Oscillator<float>`
- **Purpose:** Generate pure sine wave for kick drum fundamental
- **Parameters Affected:** MIDI note (base pitch), sweep (via pitch envelope)
- **Configuration:**
  - Initialize with: `osc.initialise([](float x) { return std::sin(x); }, 128);`
  - 128 = wavetable size (tradeoff: memory vs. CPU)
  - Frequency controlled via MIDI note + pitch envelope modulation
  - Phase reset on note-on for consistent attack

### Pitch Envelope
- **JUCE Class:** Custom implementation (exponential envelope generator)
- **Purpose:** Modulate oscillator frequency from Sweep offset to base pitch
- **Parameters Affected:** sweep, time
- **Configuration:**
  - Start frequency: basePitch + (sweep semitones)
  - Target frequency: basePitch (from MIDI note)
  - Envelope shape: Exponential decay
  - Time parameter: 5-500ms decay time
  - Phase-continuous: No clicks during frequency transition
  - Formula: `currentFreq = baseFreq * pow(2.0, envelopeValue * sweepSemitones / 12.0)`

### Amplitude Envelope
- **JUCE Class:** `juce::ADSR` (configured as AD with sustain=0)
- **Purpose:** Shape amplitude over time (kick drum envelope)
- **Parameters Affected:** attack, decay
- **Configuration:**
  - Attack: 0-50ms (parameter-controlled)
  - Decay: 50-2000ms (parameter-controlled)
  - Sustain: 0.0 (fixed - kick drums have no sustain)
  - Release: 0.0 (not needed - sustain is zero)
  - Trigger on note-on, runs to completion

### Saturation/Drive
- **JUCE Class:** Custom implementation (tanh waveshaping)
- **Purpose:** Add harmonics and warmth to sine wave
- **Parameters Affected:** drive
- **Configuration:**
  - Transfer function: `output = tanh(gain * input)`
  - Gain range: 1.0 to 10.0 (mapped from drive 0-100%)
  - Formula: `gain = 1.0 + (driveNormalized * 9.0)`
  - Symmetric waveshaping: Produces odd harmonics
  - No oversampling required (kick drum bandwidth limited)

---

## Processing Chain

```
MIDI Note Input
    ↓
[Convert MIDI Note → Base Frequency (Hz)]
    ↓
[Pitch Envelope] ← sweep, time parameters
    ↓ (modulated frequency)
[Sine Oscillator] ← modulated frequency
    ↓ (raw sine wave)
[Amplitude Envelope] ← attack, decay parameters
    ↓ (shaped amplitude)
[Saturation/Drive] ← drive parameter
    ↓ (harmonics added)
Output (Stereo)
```

**Routing notes:**
- Monophonic: Single voice, retriggerable
- No parallel processing paths (strictly serial)
- MIDI velocity: Could scale amplitude envelope output (optional enhancement)
- Output is mono source, duplicated to stereo

---

## System Architecture

### MIDI Input Handling

**Input handling:** Omni mode (responds to all MIDI channels)

**Note mapping:**
- MIDI note number → Base frequency for oscillator
- Formula: `frequency = 440.0 * pow(2.0, (midiNote - 69) / 12.0)`
- Built-in JUCE utility: `juce::MidiMessage::getMidiNoteInHertz(midiNote)`
- Typical range: MIDI notes 24-48 (C1-C3) for kick drums

**Velocity handling:**
- MIDI velocity could scale amplitude envelope output
- Range: 0-127 → 0.0-1.0 gain multiplier
- Implementation note: May not be needed for minimal design

**JUCE classes:**
- `juce::MidiBuffer` - MIDI event storage in processBlock
- `juce::MidiMessage` - Parse note-on, note-off, velocity
- `juce::MidiMessage::getMidiNoteInHertz()` - MIDI to Hz conversion

**Processing:**
```cpp
for (const auto metadata : midiMessages)
{
    auto message = metadata.getMessage();
    if (message.isNoteOn())
    {
        int midiNote = message.getNoteNumber();
        float baseFreq = juce::MidiMessage::getMidiNoteInHertz(midiNote);
        triggerNote(baseFreq);  // Start pitch envelope, reset phase
    }
}
```

### Voice Management

**Architecture:** Monophonic, retriggerable

**Voice allocation:**
- Single voice only (no polyphony)
- New note-on retriggers voice immediately
- No voice stealing logic needed (only one voice)

**Retriggering behavior:**
- Phase reset: Reset oscillator phase to zero on note-on
- Envelope restart: Restart both pitch and amplitude envelopes
- No glide/portamento (instant frequency change to new note)

**JUCE classes:**
- `juce::Synthesiser` - Voice management framework (optional)
- `juce::SynthesiserVoice` - Voice base class (optional)
- Alternatively: Custom voice management (simpler for monophonic)

**Implementation choice:** Custom voice management (no juce::Synthesiser) for simplicity:
- Single voice state (active/inactive)
- Direct envelope triggering on note-on
- No voice stealing, no polyphony complexity

### State Persistence

**What state is saved:**
- APVTS parameters: sweep, time, attack, decay, drive (automatic via APVTS)
- No non-parameter state (no file paths, no UI state)

**Serialization format:**
- APVTS parameters: Automatic via `AudioProcessorValueTreeState`
- No custom state needed

**JUCE classes:**
- `juce::AudioProcessorValueTreeState` - Parameter persistence (automatic)

---

## Parameter Mapping

| Parameter ID | Type | Range | DSP Component | Usage |
|-------------|------|-------|---------------|-------|
| sweep | Float | 0-24 st | Pitch Envelope | Starting pitch offset (semitones above base) |
| time | Float | 5-500 ms | Pitch Envelope | Exponential decay time to base pitch |
| attack | Float | 0-50 ms | Amplitude Envelope | Attack time (rise to peak) |
| decay | Float | 50-2000 ms | Amplitude Envelope | Decay time (fall to zero) |
| drive | Float | 0-100% | Saturation | Waveshaping gain (1.0-10.0 linear) |

---

## Algorithm Details

### Pitch Envelope (Exponential Decay)

**Algorithm:** Exponential decay from sweep offset to base frequency

**Implementation notes:**
- Start value: sweep parameter (0-24 semitones)
- Target value: 0 semitones (base pitch)
- Decay shape: Exponential (fast initially, slows near target)
- Formula: `envelopeValue = startValue * exp(-decayRate * time)`
- Decay rate: `decayRate = -log(0.001) / decayTimeSeconds` (decay to 0.1% in decayTime)
- Frequency calculation: `freq = baseFreq * pow(2.0, envelopeValue / 12.0)`

**Phase continuity:**
- Oscillator phase must remain continuous during frequency changes
- juce::dsp::Oscillator handles phase continuity internally when setFrequency() called
- Update frequency every sample or every block (block update more efficient)

### Amplitude Envelope (AD)

**Algorithm:** Attack-Decay envelope with sustain=0

**Implementation notes:**
- Use juce::ADSR class configured with:
  - attack: Parameter value (0-50ms)
  - decay: Parameter value (50-2000ms)
  - sustain: 0.0 (fixed)
  - release: 0.0 (not needed)
- Call `adsr.noteOn()` on MIDI note-on
- Call `adsr.getNextSample()` per sample for envelope value
- Envelope runs to completion (decay to zero)
- No noteOff needed (sustain is zero)

### Saturation (Tanh Waveshaping)

**Algorithm:** Hyperbolic tangent waveshaping

**Implementation notes:**
- Transfer function: `output = std::tanh(gain * input)`
- Gain mapping: `gain = 1.0 + (driveNormalized * 9.0)` where driveNormalized is 0.0-1.0
- Drive 0% → gain 1.0 (unity, no saturation)
- Drive 100% → gain 10.0 (heavy saturation)
- Apply per-sample after amplitude envelope
- No oversampling (kick drum bandwidth limited, aliasing minimal)

**Harmonic characteristics:**
- Symmetric waveshaping → Odd harmonics only (3rd, 5th, 7th)
- Adds warmth and presence without harsh even harmonics

---

## Integration Points

### Feature Dependencies

- **Pitch Envelope → Sine Oscillator:** Pitch envelope output modulates oscillator frequency
- **Sine Oscillator → Amplitude Envelope:** Oscillator output is scaled by envelope
- **Amplitude Envelope → Saturation:** Envelope output feeds saturation stage
- **MIDI Input → All features:** MIDI note-on triggers all components

### Parameter Interactions

- **Sweep + Time:** Together define pitch drop character
  - High sweep + short time: Clicky, punchy kick (909-style)
  - Low sweep + long time: Laser kick, tonal (experimental)
  - Typical: 12 st sweep, 50ms time (808-style)

- **Attack + Decay:** Together define amplitude shape
  - Short attack + long decay: Slow-building kick (rare)
  - Short attack + short decay: Tight, punchy kick (common)
  - Typical: 5ms attack, 400ms decay

- **Drive:** Independent from envelopes
  - Low drive: Clean, subby tone
  - High drive: Warm, harmonic-rich tone
  - Typical: 20% drive (subtle warmth)

### Processing Order Requirements

**Sequential processing order (REQUIRED):**

1. **MIDI input received:** Process MIDI buffer in processBlock()
2. **Convert MIDI note → base frequency:** Calculate Hz from note number
3. **Trigger envelopes:** On note-on, start pitch envelope and amplitude envelope
4. **Update pitch envelope:** Calculate current pitch offset (sample-by-sample or block-by-block)
5. **Calculate modulated frequency:** baseFreq * pow(2.0, pitchEnvelope / 12.0)
6. **Set oscillator frequency:** osc.setFrequency(modulatedFreq)
7. **Generate sine sample:** osc.processSample(channel)
8. **Apply amplitude envelope:** sineOutput * amplitudeEnvelope.getNextSample()
9. **Apply saturation:** tanh(gain * envelopedOutput)
10. **Write to output buffer:** Write final sample to audio buffer

**Why order matters:**
- Pitch envelope must update before oscillator frequency set
- Oscillator generation before amplitude envelope application
- Amplitude envelope before saturation (saturation on final amplitude)
- All processing must complete for each sample before moving to next

### Thread Boundaries

**Audio thread:**
- All DSP processing (oscillator, envelopes, saturation)
- MIDI message processing
- Parameter reads via `APVTS::getRawParameterValue()->load()` (atomic)
- Sample-by-sample or block-by-block rendering in processBlock()

**Message thread:**
- Parameter updates from UI via APVTS (atomic writes)
- Preset loading/saving
- UI repaints

**No background thread needed:**
- No file I/O
- No long-running operations
- All processing is real-time compatible

**Communication:**
- APVTS parameters: Atomic reads (audio thread) / atomic writes (message thread)
- No custom thread communication needed (APVTS handles it)

---

## Implementation Risks

### Pitch Envelope (Custom Implementation)

**Complexity:** MEDIUM
- Exponential envelope math is straightforward
- Phase continuity requires careful frequency modulation
- No JUCE class exists (custom implementation needed)

**Risk Level:** MEDIUM

**Risk factors:**
1. Phase discontinuity if frequency changes too abruptly
   - Mitigation: juce::dsp::Oscillator handles continuous frequency changes
2. Envelope calculation performance (per-sample exponential)
   - Mitigation: Can calculate per-block instead of per-sample (trade accuracy for CPU)
3. Sweep parameter mapping to frequency modulation
   - Mitigation: Standard semitone formula well-documented

**Alternative approaches:**
1. **Linear decay envelope:**
   - Simpler math (no exponential)
   - Less authentic (808/909 use exponential)
   - Best for: Prototyping

2. **Lookup table:**
   - Pre-calculate envelope curve
   - Faster execution
   - Best for: CPU optimization if needed

**Fallback architecture:**
- **Primary:** Exponential decay (authentic 808/909)
- **Fallback:** Linear decay if exponential too complex or performance issues

**Mitigation strategy:**
1. Implement linear decay prototype first (validate concept)
2. Replace with exponential decay (authentic sound)
3. Benchmark CPU usage (optimize if needed)

### Monophonic Voice Management (Custom)

**Complexity:** LOW
- No voice stealing logic
- No polyphony complexity
- Single voice state machine

**Risk Level:** LOW

**Risk factors:**
1. Retriggering behavior (phase reset vs. continuous)
   - Decision: Phase reset for consistent attack (industry standard)
2. Envelope restart on retrigger
   - Decision: Hard restart (no envelope tail from previous note)

**Alternative approaches:**
1. **Use juce::Synthesiser framework:**
   - More complex (designed for polyphony)
   - Overkill for monophonic synth
   - Best for: Future polyphonic expansion

2. **Custom voice management:**
   - Simpler code
   - Direct control
   - Best for: Monophonic, no polyphony needed

**Fallback architecture:**
- **Primary:** Custom voice management (recommended for simplicity)
- **Fallback:** juce::Synthesiser if custom approach proves problematic

**Mitigation strategy:**
1. Start with custom voice management (simpler)
2. Use juce::Synthesiser only if polyphony added later

### Overall Project Risk

**Overall complexity:** MEDIUM
- Tier 4 synthesizer (moderate depth)
- 6 features: 4 DSP + 1 MIDI + 1 voice management
- Most complex: Pitch envelope (custom implementation)

**Highest risk component:** Pitch Envelope
- Represents ~40% of project risk
- Custom implementation (no JUCE class)
- Phase continuity critical for click-free sound

**Recommended approach:**
1. **Phase 1 - Foundation:** Implement oscillator + MIDI (2 hours)
2. **Phase 2 - Amplitude:** Add amplitude envelope (1 hour)
3. **Phase 3 - Pitch Envelope:** Implement linear decay first, then exponential (3 hours)
4. **Phase 4 - Saturation:** Add drive/waveshaping (1 hour)
5. **Phase 5 - Polish:** Tune parameters, test edge cases (1 hour)

**Total estimated time:** 8 hours (Tier 4, moderate complexity)

---

## Architecture Decisions

### Custom Pitch Envelope (Not ADSR)

**Decision:** Implement custom exponential envelope for pitch modulation

**Rationale:**
- ADSR is designed for amplitude, not pitch
- Pitch envelope needs different shape (exponential decay to zero offset)
- 808/909 use exponential pitch decay (industry standard)
- Simple math: `offset = startValue * exp(-rate * time)`

**Alternatives considered:**
1. **Use ADSR for pitch:**
   - Why rejected: ADSR sustain stage doesn't fit pitch envelope (need decay to zero)
   - When to reconsider: Never (wrong tool for job)

2. **Linear decay:**
   - Why rejected: Less authentic (808/909 use exponential)
   - When to reconsider: If exponential too complex

**Tradeoffs accepted:**
- **Custom code:** More implementation work vs. using built-in ADSR
  - Acceptable because: Pitch envelope is core feature, needs correct shape
- **No JUCE class:** Custom implementation vs. framework support
  - Acceptable because: Math is straightforward, well-documented pattern

**When to revisit:**
- If exponential math proves too complex (use linear decay)
- If CPU usage too high (use lookup table)

### Monophonic (Not Polyphonic)

**Decision:** Single voice, retriggerable (no polyphony)

**Rationale:**
- Kick drums are monophonic instruments (one kick at a time)
- Polyphony adds complexity without benefit
- Simpler voice management (no stealing, no allocation)
- Matches creative brief: "Monophonic, retriggerable"

**Alternatives considered:**
1. **Polyphonic (multiple voices):**
   - Why rejected: Kick drums don't need polyphony (one hit at a time)
   - When to reconsider: If user requests layering multiple kicks

**Tradeoffs accepted:**
- **No chord/layering:** Can't play multiple notes simultaneously
  - Acceptable because: Kick drums are monophonic by nature
- **Simpler code:** Less complexity vs. full synthesizer framework
  - Acceptable because: Simplicity aligns with "minimal" design philosophy

### No Oversampling for Saturation

**Decision:** Apply saturation without oversampling

**Rationale:**
- Kick drums are bandwidth-limited (mostly sub-200Hz)
- Aliasing from waveshaping affects high frequencies (>10kHz)
- Kick drum content doesn't extend to alias-prone range
- Oversampling adds 2-4x CPU cost for minimal benefit

**Alternatives considered:**
1. **2x or 4x oversampling:**
   - Why rejected: Adds CPU cost, no audible benefit for kick drums
   - When to reconsider: If aliasing audible in testing (unlikely)

**Tradeoffs accepted:**
- **Potential aliasing:** High-frequency aliases (inaudible for kick drums)
  - Acceptable because: Kick drum fundamental 30-80Hz, harmonics fall off quickly
- **Lower CPU usage:** No oversampling overhead
  - Acceptable because: Performance priority, aliasing not audible

**When to revisit:**
- If testing reveals audible aliasing (add 2x oversampling)
- If CPU budget allows (add optional quality mode with oversampling)

---

## Special Considerations

### Thread Safety
- All parameter reads use atomic `getRawParameterValue()->load()`
- Oscillator state is per-voice (no shared state)
- Envelope state is per-voice (no shared state)
- MIDI processing happens entirely in audio thread (processBlock)

### Performance
- Estimated CPU usage:
  - Oscillator: ~5% single core (wavetable lookup)
  - Pitch envelope: ~2% single core (exponential per-sample)
  - Amplitude envelope: ~1% single core (ADSR per-sample)
  - Saturation: ~3% single core (tanh per-sample)
  - **Total:** ~11% single core at 48kHz (very efficient)
- Optimization opportunities:
  - Calculate envelopes per-block (not per-sample) for lower CPU
  - Use lookup table for exponential envelope if needed

### Denormal Protection
- Use `juce::ScopedNoDenormals` in processBlock()
- juce::dsp::Oscillator handles denormals internally
- Envelope values won't go denormal (decay to zero then stop)

### Sample Rate Handling
- Oscillator reinitialized in prepareToPlay() with new sample rate
- Envelope decay rates recalculated based on sample rate
- Pitch envelope decay rate: `rate = -log(0.001) / (decayTimeSeconds * sampleRate)`
- Amplitude envelope: JUCE ADSR handles sample rate internally

### Latency
- Zero algorithmic latency (no lookahead, no FFT)
- Processing is sample-accurate
- No latency compensation needed

---

## Research References

### Professional Plugins

1. **Sonic Academy Kick 2**
   - Pure sine wave generator with pitch envelope
   - Bezier curve pitch envelope editor (visual Hz and note values)
   - Industry standard for EDM kick drum synthesis
   - Up to 8 additive partials (beyond basic sine)

2. **Roland TR-808**
   - Sine wave oscillator + low-pass filter + VCA
   - Pitch envelope: Fast exponential decay from high to low frequency
   - Smooth, round, boomy tone
   - Classic kick drum architecture

3. **Roland TR-909**
   - Triangle oscillator saturated into hexagonal wave, filtered to sine
   - Pitch envelope: Rapid pitch descent
   - Click/noise burst at start for attack
   - More aggressive, punchy than 808

### JUCE Documentation

- **juce::dsp::Oscillator:** Wavetable oscillator with sine wave initialization
  - Handles phase accumulation and continuity
  - setFrequency() for continuous pitch modulation
  - processSample() for sample generation
- **juce::ADSR:** Attack-Decay-Sustain-Release envelope
  - Configure with sustain=0 for AD-only envelope
  - noteOn() triggers, getNextSample() returns envelope value
- **juce::MidiMessage::getMidiNoteInHertz():** MIDI to Hz conversion
  - Standard equal temperament tuning (A4 = 440Hz)
- **juce::dsp::ProcessSpec:** Sample rate/block size configuration
  - Used in prepare() method for all juce::dsp components

### Technical Resources

- 808/909 kick drum synthesis architecture (analog circuits)
- Exponential envelope decay formulas (DSP textbooks)
- Tanh waveshaping for saturation (odd harmonic generation)
- Phase-continuous oscillator frequency modulation

---

## Notes

- Tier 4 synthesizer: 20-minute research depth (MODERATE)
- 6 features researched: Oscillator, Pitch Envelope, Amplitude Envelope, Saturation, MIDI, Voice Management
- Highest risk: Pitch envelope (custom implementation, phase continuity critical)
- Simplest voice management: Monophonic, no polyphony complexity
- Efficient design: ~11% CPU, zero latency, no oversampling needed
- Industry-standard architecture: Matches 808/909 and modern kick synths
