# DSP Architecture: AutoClip

**CRITICAL CONTRACT:** This specification is immutable during Stages 2-5 implementation. Stage 1 Planning cannot proceed without this file. Stage 4 (DSP) implements this exact architecture.

**Generated by:** Stage 0 Research (2025-11-13)
**Referenced by:** Stage 1 (Planning), Stage 4 (DSP Implementation)
**Purpose:** DSP specification defining processing components, signal flow, and JUCE module usage

---

## Core Components

### Hard Clipper

- **JUCE Class:** Custom implementation using `juce::jlimit()` or `std::clamp()`
- **Purpose:** Apply hard clipping (brick-wall limiting) at user-defined threshold
- **Parameters Affected:** `clipThreshold` (0-100%)
- **Configuration:**
  - Threshold maps from 0-100% to absolute amplitude (0.0-1.0)
  - Per-sample clamping: `sample = juce::jlimit(-threshold, threshold, sample)`
  - No soft-knee or saturation curve (hard transition)
  - Optional: Oversampling if aliasing is audible (not in initial implementation)

### Lookahead Buffer

- **JUCE Class:** `juce::dsp::DelayLine<float>`
- **Purpose:** Delay audio signal by 5ms to enable peak analysis before clipping
- **Parameters Affected:** None (fixed 5ms delay)
- **Configuration:**
  - Fixed delay: 5ms (240 samples @ 48kHz, 960 samples @ 192kHz)
  - Size calculation: `static_cast<int>(0.005 * sampleRate)`
  - Separate delay line per channel (stereo independence)
  - Initialized in prepareToPlay() with `setMaximumDelayInSamples()` and `prepare(spec)`

### Peak-Based Gain Matching

- **JUCE Class:** `juce::SmoothedValue<float>` for gain smoothing + custom peak detection
- **Purpose:** Automatically compensate output gain to match input peak level
- **Parameters Affected:** None (automatic, not user-controllable)
- **Configuration:**
  - Input peak detection: `max(abs(lookahead_buffer))` over 5ms window
  - Output peak detection: `max(abs(clipped_buffer))` over current block
  - Gain calculation: `gain = (output_peak > 0.001f) ? (input_peak / output_peak) : 1.0f`
  - Smoothing time: 50ms (prevents zipper noise and sudden gain jumps)
  - Edge cases: Silent input → gain = 1.0, no clipping → gain = 1.0

### Clip Solo (Delta Monitoring)

- **JUCE Class:** `juce::AudioParameterBool` for parameter + custom subtraction
- **Purpose:** Output only the clipped portion (difference signal) for monitoring
- **Parameters Affected:** `soloClipped` (boolean)
- **Configuration:**
  - Difference calculation: `diff = original_sample - clipped_sample`
  - When enabled: Output = difference signal
  - When disabled: Output = gain-compensated clipped signal
  - Useful for hearing clipping artifacts and sound design

---

## Processing Chain

```
Input (stereo)
  ↓
[Store original for clip solo]
  ↓
Lookahead Buffer (5ms delay) ← Fixed delay, enables peak anticipation
  ↓
[Analyze input peak from lookahead window]
  ↓
Hard Clipper ← clipThreshold parameter (0-100%)
  ↓
[Analyze output peak from clipped signal]
  ↓
Gain Compensation Calculator
  ↓
Smoothed Gain Application ← Prevents zipper noise
  ↓
[If soloClipped = true: Output = original - clipped]
[If soloClipped = false: Output = clipped with gain compensation]
  ↓
Output (stereo)
```

**Routing notes:**
- Linear signal path (no parallel processing or feedback loops)
- Peak detection runs once per buffer (not per sample) for efficiency
- Gain smoothing uses exponential smoothing (50ms time constant)
- Clip solo routing happens after gain compensation

---

## System Architecture

### File I/O System
Not applicable - AutoClip has no file I/O requirements.

### Multi-Output Routing
Not applicable - AutoClip uses standard stereo input/output (2 channels).

### MIDI Routing
Not applicable - AutoClip is an audio effect with no MIDI input.

### State Persistence

**What state is saved:**
- APVTS parameters: `clipThreshold` (0-100%), `soloClipped` (boolean)
- No custom state beyond APVTS (no folder paths, UI preferences, or non-parameter state)

**Serialization format:**
- APVTS parameters: Automatic via `AudioProcessorValueTreeState` (XML via ValueTree)

**JUCE classes:**
- `juce::AudioProcessorValueTreeState` - Parameter persistence (automatic)

**Save/restore methods:**
- `getStateInformation(MemoryBlock& destData)` - Serialize APVTS state
- `setStateInformation(const void* data, int sizeInBytes)` - Deserialize APVTS state

**Restore behavior:**
- APVTS handles all state restoration automatically
- Invalid data: APVTS uses default parameter values
- No version migration needed (simple parameter set)

---

## Parameter Mapping

| Parameter ID | Type | Range | DSP Component | Usage |
|-------------|------|-------|---------------|-------|
| clipThreshold | Float | 0-100% | Hard Clipper | Clipping threshold (0% = no clipping, 100% = max clipping) |
| soloClipped | Bool | Off/On | Clip Solo | Output routing (Off = clipped signal, On = difference signal) |

**Note:** Gain compensation is automatic and not exposed as a user parameter. It operates transparently based on input/output peak analysis.

---

## Algorithm Details

### Hard Clipping

**Algorithm:** Threshold-based clamping

**Implementation notes:**
- Threshold scaling: `threshold_abs = clipThreshold * 0.01f` (convert percentage to amplitude)
- Clamping: `output = juce::jlimit(-threshold_abs, threshold_abs, input)`
- Applies per-sample in processBlock loop
- Creates harmonic distortion and aliasing (typical for hard clipping)
- Optional oversampling (not in v1.0) would reduce aliasing if needed

### Peak-Based Gain Matching

**Algorithm:** Peak detection + ratio-based gain compensation

**Implementation notes:**
- Input peak detection: Iterate lookahead buffer, find max absolute value
  ```cpp
  float inputPeak = 0.0f;
  for (int i = 0; i < lookaheadBufferSize; ++i)
      inputPeak = std::max(inputPeak, std::abs(lookaheadBuffer[i]));
  ```
- Output peak detection: Iterate clipped buffer, find max absolute value
  ```cpp
  float outputPeak = 0.0f;
  for (int i = 0; i < numSamples; ++i)
      outputPeak = std::max(outputPeak, std::abs(clippedBuffer[i]));
  ```
- Gain calculation: `gain = (outputPeak > 0.001f) ? (inputPeak / outputPeak) : 1.0f`
- Smoothing: `smoothedGain.setTargetValue(gain)` using juce::SmoothedValue with 50ms ramp
- Epsilon (0.001f) prevents division by zero and handles near-silence

**Why peak-based (not RMS or LUFS):**
- Peak matching preserves transient levels (critical for drums)
- RMS/LUFS would smooth out transient impact
- Peak-based is simpler and faster than perceptual loudness measurement
- Appropriate for transient-focused material (target use case: drums)

### Lookahead Buffer

**Algorithm:** Fixed circular delay buffer

**Implementation notes:**
- Delay time: 5ms fixed (not user-adjustable)
- Sample count: `delayInSamples = static_cast<int>(0.005 * sampleRate)`
- Uses juce::dsp::DelayLine for circular buffer management
- Each channel has independent delay line (stereo)
- Provides time window for peak analysis before clipping occurs
- Latency reported to host via `getLatencySamples()` for automatic compensation

### Clip Solo (Delta Monitoring)

**Algorithm:** Signal subtraction

**Implementation notes:**
- Store original sample before clipping: `originalSample = input`
- Calculate difference after clipping: `difference = originalSample - clippedSample`
- Conditional output routing:
  ```cpp
  if (soloClipped)
      output = difference;  // Only clipped portion
  else
      output = clippedSample * gainCompensation;  // Normal mode
  ```
- When no clipping occurs (threshold high), difference signal is silent
- Useful for hearing clipping artifacts and for sound design

---

## Integration Points

### Feature Dependencies

- **Lookahead buffer → Peak-based gain matching:** Lookahead buffer provides input peak window for gain calculation
- **Hard clipping → Peak-based gain matching:** Clipping must complete before output peak can be analyzed
- **Peak-based gain matching → Clip solo:** Gain compensation applies before solo routing decision
- **All features → Processing order:** Linear dependencies require specific order (see Processing Order below)

### Parameter Interactions

- **clipThreshold affects gain compensation:**
  - At 0% (no clipping): No clipping occurs, output_peak ≈ input_peak, gain ≈ 1.0 (no compensation needed)
  - At 100% (maximum clipping): Heavy clipping reduces output peaks, gain increases to restore to input level
  - Threshold and gain are inversely related: Lower threshold → more clipping → higher compensating gain

- **soloClipped doesn't affect gain compensation:**
  - Solo routing is post-compensation (gain already applied)
  - Solo changes output routing but not DSP processing chain
  - Difference signal inherits gain compensation from clipped signal

### Processing Order Requirements

**Sequential processing order (REQUIRED):**

1. **Read input buffer:** Receive stereo audio from host
2. **Store original samples:** Copy for clip solo difference calculation
3. **Push to lookahead buffer:** Delay signal by 5ms
4. **Analyze input peak:** Find max absolute value in lookahead window
5. **Pop from lookahead buffer:** Retrieve delayed signal for processing
6. **Apply hard clipping:** Clamp delayed signal to threshold
7. **Analyze output peak:** Find max absolute value in clipped signal
8. **Calculate gain compensation:** `gain = input_peak / output_peak`
9. **Smooth gain changes:** Apply 50ms exponential smoothing
10. **Apply gain to clipped signal:** Multiply by smoothed gain
11. **Calculate difference signal:** `diff = original - (clipped * gain)`
12. **Route output:** Based on soloClipped parameter (clipped or difference)
13. **Write output buffer:** Send to host

**Why order matters:**
- Lookahead buffer must delay signal before clipping (enables peak anticipation)
- Input peak analysis before clipping (captures clean signal peaks)
- Output peak analysis after clipping (measures clipped signal peaks)
- Gain compensation after clipping (restores peak level)
- Solo routing last (chooses between compensated clipped or difference)

**Parallel processing:**
- None - All operations are sequential in single signal path

### Thread Boundaries

**Audio thread:**
- All DSP processing in processBlock() (clipping, peak detection, gain calculation, smoothing)
- Parameter reads via `APVTS::getRawParameterValue()->load()` (atomic)
- Lookahead buffer operations (push/pop)
- Sample-by-sample processing

**Message thread:**
- Parameter updates from UI via APVTS (atomic writes)
- Preset loading/saving
- UI repaints

**No background thread needed:**
- No file I/O
- No long-running operations
- All processing is real-time compatible

**Communication:**
- APVTS parameters: Atomic reads (audio thread) / atomic writes (message thread)
- No custom thread communication needed (APVTS handles synchronization)

---

## Implementation Risks

### Hard Clipping

**Complexity:** LOW - Basic threshold comparison and clamping

**Risk Level:** LOW

**Risk factors:**
- Aliasing from hard clipping (high-frequency harmonics fold back)
- Potential for harsh artifacts on non-drum material

**Alternative approaches:**
1. **Oversampling (2x or 4x):** Reduces aliasing, increases CPU cost (~2-4x)
2. **Soft clipping:** Smoother transition, but changes design intent (hard clipper)

**Fallback architecture:**
- If aliasing is unacceptable: Implement juce::dsp::Oversampling (straightforward JUCE class)
- Test on drums first (target use case) - aliasing may be acceptable/desirable

**Mitigation strategy:**
- Test on drum material (claps, hats, kicks) during implementation
- If aliasing is audible, add oversampling option as v1.1 feature
- Document that plugin is optimized for transient-rich material

---

### Peak-Based Gain Matching

**Complexity:** MEDIUM - Peak detection and ratio-based compensation with smoothing

**Risk Level:** MEDIUM

**Risk factors:**
1. **Peak-based matching may not sound natural:** Industry uses RMS/LUFS (perceived loudness), not peak
   - Peak matching preserves transient levels but may not maintain perceived loudness
2. **Smoothing time tuning:** 50ms is estimate, may need adjustment for musical feel
   - Too fast: Audible gain pumping
   - Too slow: Sluggish response, level jumps
3. **Edge case handling:** Silent input, extreme threshold settings

**Alternative approaches:**
1. **RMS-based gain matching:**
   - Complexity: MEDIUM (similar to peak detection)
   - Matches perceived loudness better than peak
   - Implementation: Calculate RMS instead of peak
   - Tradeoff: Smooths out transient impact (may not be desired for drums)

2. **LUFS-based gain matching:**
   - Complexity: HIGH (requires K-weighting filter + gating)
   - Most perceptually accurate
   - Tradeoff: Too complex for simple clipper, slower response

**Fallback architecture:**
- **Primary:** Peak-based matching (as specified in creative brief)
- **Fallback:** If peak matching feels unnatural in testing → Switch to RMS-based matching
  - Change: Replace peak detection with RMS calculation: `rms = sqrt(sum(samples^2) / count)`
  - Minimal code change (same smoothing and gain application logic)

**Mitigation strategy:**
1. Implement peak-based first (creative brief specifies this approach)
2. Test on drum material with various threshold settings
3. Tune smoothing time (50ms starting point, may need 20-100ms range)
4. If peak matching doesn't work musically, RMS fallback is straightforward

---

### Lookahead Buffer

**Complexity:** LOW - Fixed delay using JUCE DelayLine class

**Risk Level:** LOW

**Risk factors:**
1. **Latency reporting:** Must report 5ms latency via `getLatencySamples()` for host compensation
2. **Buffer sizing:** Must size for maximum sample rate (192kHz = 960 samples)

**Alternative approaches:**
None - Fixed delay is the simplest and most appropriate approach for gain anticipation.

**Fallback architecture:**
N/A - If DelayLine fails, fundamental JUCE issue exists (extremely unlikely)

**Mitigation strategy:**
- Check juce8-critical-patterns.md for DelayLine usage (prepare, reset patterns)
- Size buffer conservatively for max sample rate (192kHz)
- Test latency reporting in multiple DAWs (verify alignment)

---

### Clip Solo (Delta Monitoring)

**Complexity:** LOW - Signal subtraction and conditional routing

**Risk Level:** LOW

**Risk factors:**
None identified - Trivial arithmetic and boolean parameter

**Alternative approaches:**
None needed - This is the simplest implementation

**Fallback architecture:**
N/A - If this fails, fundamental problem exists

**Mitigation strategy:**
- Verify difference signal is silent when no clipping occurs (UX expectation)
- Test that solo doesn't affect gain compensation (solo is post-compensation)

---

### Overall Project Risk

**Overall complexity:** LOW-MEDIUM
- Simple hard clipping (LOW)
- Peak-based gain matching (MEDIUM - tuning required)
- Lookahead buffer (LOW)
- Clip solo (LOW)

**Highest risk component:** Peak-based gain matching
- Represents ~60% of project risk
- Requires tuning (smoothing time, musical feel)
- May need fallback to RMS-based approach
- Unknown: Will peak matching feel natural vs. RMS matching?

**Recommended approach:**
1. **Phase 1 - Foundation:** Implement hard clipping + lookahead + clip solo (LOW risk, 30-45 min)
2. **Phase 2 - Core innovation:** Implement peak-based gain matching (MEDIUM risk, 45-60 min)
3. **Phase 3 - Testing/tuning:** Test on drum material, tune smoothing time (30 min)
4. **Phase 4 - Fallback (if needed):** If peak matching doesn't work, switch to RMS (30 min)

**Total estimated time:** 1.5-2.5 hours depending on whether fallback is needed

---

## Architecture Decisions

### Peak-Based Gain Matching (Not RMS or LUFS)

**Decision:** Use peak-based gain matching for automatic level compensation

**Rationale:**
- Creative brief explicitly specifies "peak-based gain matching"
- Peak matching preserves transient levels (critical for target use case: drums)
- Simpler and faster than RMS or LUFS measurement
- Appropriate for transient-rich material (claps, hats, kicks)

**Alternatives considered:**
1. **RMS-based matching:**
   - Why considered: Industry standard for clippers (CLIPnosis, others)
   - Why not chosen: Smooths transient impact, creative brief specifies peak-based
   - When to reconsider: If peak matching doesn't feel natural in testing (fallback ready)

2. **LUFS-based matching:**
   - Why considered: Most perceptually accurate loudness measurement
   - Why not chosen: Overkill for simple clipper, too slow for transient material, high complexity
   - When to reconsider: Never for v1.0 (wrong tool for clipper application)

**Tradeoffs accepted:**
- **Peak vs. perceived loudness:** Peak matching maintains transient levels but may not match perceived loudness
  - Acceptable because: Target is drums (transient-focused), peak preservation is priority
- **Implementation risk:** Peak-based is less common than RMS in professional plugins
  - Acceptable because: RMS fallback is straightforward if needed, testing will validate approach

**When to revisit:**
- If testing reveals peak matching feels unnatural or inconsistent
- If users report unexpected loudness changes despite "matching"
- Fallback: Switch to RMS-based matching (minimal code change)

---

### Fixed 5ms Lookahead (Not Variable)

**Decision:** Fixed 5ms lookahead delay (not user-adjustable)

**Rationale:**
- 5ms is short enough to be imperceptible as latency (<10ms threshold)
- Long enough to smooth gain changes for typical drum transients
- Simplifies implementation (no parameter, no UI control)
- Matches professional clipper/limiter designs (fixed lookahead is standard)

**Alternatives considered:**
1. **No lookahead (0ms):**
   - Why considered: Zero latency
   - Why not chosen: Gain compensation would lag behind transients, causing pumping artifacts
   - When to reconsider: Never (lookahead is required for smooth gain anticipation)

2. **Variable lookahead (0-20ms):**
   - Why considered: User flexibility for different material
   - Why not chosen: Adds complexity, UI clutter, most users wouldn't adjust it
   - When to reconsider: If users request variable lookahead in feedback (unlikely for v1.0)

3. **Longer lookahead (10-20ms):**
   - Why considered: Smoother gain compensation
   - Why not chosen: More latency, diminishing returns beyond 5ms for drums
   - When to reconsider: If 5ms proves too short during testing

**Tradeoffs accepted:**
- **Latency:** 5ms fixed latency reported to host (acceptable for non-real-time tracking use)
- **Flexibility:** No user control over lookahead time (acceptable for simplicity)

**When to revisit:**
- If testing reveals 5ms is too short (gain pumping on fast transients)
- If testing reveals 5ms is too long (unnecessary latency)
- Adjustment: Change constant in code, no architecture change needed

---

### Hard Clipping (Not Soft Clipping)

**Decision:** Hard clipping algorithm (brick-wall limiting)

**Rationale:**
- Creative brief explicitly states "hard clipper"
- Plugin name "AutoClip" implies hard clipping
- Inspiration: StandardClip's "Hard Clip mode"
- Target use case: Aggressive drum processing (hard clipping creates desirable artifacts)

**Alternatives considered:**
1. **Soft clipping (saturation):**
   - Why considered: Smoother transition, less harsh artifacts
   - Why not chosen: Changes design intent, plugin is specifically "hard clipper"
   - When to reconsider: Never for AutoClip (would be different plugin)

2. **Multiple clipping modes (hard/soft/ratio):**
   - Why considered: Flexibility like StandardClip offers
   - Why not chosen: Scope creep, creative brief is single-mode hard clipper
   - When to reconsider: As v2.0 feature if users request (not v1.0)

**Tradeoffs accepted:**
- **Aliasing artifacts:** Hard clipping creates high-frequency harmonics that fold back as aliasing
  - Acceptable because: Target is drums (aliasing may be desirable), oversampling available if needed
- **Harshness:** Hard clipping can sound harsh on non-drum material
  - Acceptable because: Plugin is optimized for drums (documented in manual)

**When to revisit:**
- If aliasing is unacceptable: Add oversampling (juce::dsp::Oversampling)
- If users request soft clipping: Add as separate mode in v2.0 (not for v1.0)

---

## Special Considerations

### Thread Safety

- All parameter reads use atomic `getRawParameterValue()->load()` via APVTS
- Peak detection and gain calculation happen entirely in audio thread (no shared state)
- Lookahead buffer is per-channel (no inter-channel dependencies)
- SmoothedValue uses internal state (no cross-thread access)
- No locks, no allocations in processBlock()

### Performance

- Estimated CPU usage:
  - Hard clipping: <1% (trivial per-sample operation)
  - Peak detection: ~5% (two max-finding loops per buffer)
  - Lookahead buffer: ~2% (circular buffer operations)
  - Gain smoothing: ~1% (exponential smoothing per sample)
  - **Total estimated:** ~10% single core at 48kHz, 512 sample buffer
- Hot paths: Peak detection loops (optimize with SIMD if needed)
- Buffer size: Performance scales with buffer size (larger buffers = less overhead)

### Denormal Protection

- Use `juce::ScopedNoDenormals` in processBlock() (standard practice)
- Hard clipping naturally avoids denormals (output bounded by threshold)
- Gain smoothing uses juce::SmoothedValue (handles denormals internally)
- Epsilon in gain calculation (0.001f) prevents denormal divisions

### Sample Rate Handling

- Lookahead buffer sized dynamically in prepareToPlay():
  - `delayInSamples = static_cast<int>(0.005 * sampleRate)`
  - Recalculated on sample rate change
- SmoothedValue reset with new sample rate:
  - `smoothedGain.reset(sampleRate, 0.05)` (50ms time constant, sample-rate independent)
- Peak detection is sample-rate independent (operates on buffer size, not time)

### Latency

- Fixed latency: 5ms (lookahead buffer)
- Sample count: `getLatencySamples()` returns `static_cast<int>(0.005 * getSampleRate())`
- Host compensation: DAW automatically delays other tracks by reported latency
- Reported in plugin info for user awareness

---

## Research References

### Professional Plugins

1. **StandardClip by SIR Audio Tools**
   - Industry-standard hard clipper with multiple clipping modes
   - Hard Clip mode: Brick-wall limiting without soft saturation
   - Oversampling up to 256x (linear-phase and minimum-phase filters)
   - Input/output meters and waveform display
   - "Best for shaving signal off transient-heavy material" - confirms drum use case

2. **KClip 3 by Kazrog**
   - Features "Delta function" for listening to only altered (clipped) signal
   - Matches AutoClip's clip solo feature exactly
   - User feedback: Delta should be silent when no clipping occurs

3. **CLIPnosis by Alus Audio**
   - Intelligent RMS-based gain matching (not peak-based)
   - Auto-compensation maintains perceived loudness during drive changes
   - Contrasts with AutoClip's peak-based approach

4. **BT Clipper by Viator DSP**
   - Auto-gain compensation for A/B testing clean vs clipped
   - Matches AutoClip's use case: "dial in clipping without adjusting mix levels"

### JUCE Documentation

- **juce::dsp::DelayLine:** Circular delay buffer with `prepare()`, `pushSample()`, `popSample()`, `reset()`
  - Used for lookahead buffer implementation
  - Module: juce_dsp

- **juce::SmoothedValue:** Exponential smoothing with sample-rate independent time constants
  - Used for gain smoothing (prevents zipper noise)
  - Module: juce_audio_basics

- **juce::jlimit():** Clamping utility: `jlimit(min, max, value)`
  - Used for hard clipping implementation
  - Module: juce_core

- **juce::AudioParameterFloat / AudioParameterBool:** APVTS parameter types
  - Used for threshold (float) and solo (bool) parameters
  - Module: juce_audio_processors

- **juce::dsp::Oversampling:** (Optional for future) Upsampling/downsampling for aliasing reduction
  - Not in v1.0, but available if needed
  - Module: juce_dsp

### Technical Resources

- DAFX (Digital Audio Effects) - Clipping and limiting algorithms
- ITU-R BS.1770-4 - Loudness measurement standard (LUFS) for comparison with peak-based approach
- Professional clipper plugins research - Industry approaches to gain compensation (RMS vs peak vs LUFS)

---

## Notes

- **Peak vs. RMS decision:** Creative brief specifies peak-based, but RMS fallback is ready if testing reveals issues
- **Simplicity focus:** Single-mode hard clipper with automatic gain matching (no soft clipping, no multiband, no additional complexity)
- **Target use case:** Drums and transient-rich material (claps, hats, kicks) - optimized for this, not general-purpose
- **Clip solo naming:** Industry calls this "delta monitoring" - AutoClip uses "clip solo" for user-friendly terminology
- **Latency reporting:** Must implement getLatencySamples() for 5ms lookahead (host compensation)
- **Testing priority:** Focus on drum material during testing (target use case)
