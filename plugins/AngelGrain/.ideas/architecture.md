# DSP Architecture: AngelGrain

**CRITICAL CONTRACT:** This specification is immutable during Stages 1-4 implementation. Stage 1 Planning cannot proceed without this file. Stage 3 (DSP) implements this exact architecture.

**Generated by:** Stage 0 Research
**Referenced by:** Stage 1 (Planning), Stage 3 (DSP Implementation)
**Purpose:** DSP specification defining processing components, signal flow, and JUCE module usage

---

## Core Components

### Grain Buffer (Circular Delay Line)
- **JUCE Class:** `juce::dsp::DelayLine<float, juce::dsp::DelayLineInterpolationTypes::Lagrange3rd>`
- **Purpose:** Store incoming audio for grain reading with interpolated playback
- **Parameters Affected:** delayTime, tempoSync
- **Configuration:**
  - Buffer size: Maximum 2 seconds at sample rate (e.g., 96,000 samples at 48kHz)
  - Write continuously at current sample position (mono input)
  - Grains read from randomized positions within delay range
  - Lagrange3rd interpolation for smooth pitch-shifted playback
  - Tempo sync: When enabled, delayTime snaps to note divisions (1/16, 1/8, 1/4, 1/2, 1)

### Grain Voice Engine
- **JUCE Class:** Custom implementation (polyphonic voice management)
- **Purpose:** Manage multiple simultaneous grain playbacks with independent states
- **Parameters Affected:** grainSize, chaos, character, feedback
- **Configuration:**
  - Voice count: 32 maximum simultaneous grains (32 mono grains panned to stereo)
  - Voice structure per grain:
    - Read position in delay buffer (float for interpolation)
    - Window position (0.0-1.0 progress through grain envelope)
    - Pitch shift semitones (quantized to octaves/fifths: -12, -7, 0, +7, +12)
    - Pan position (0.0-1.0, randomized for stereo spread)
    - Envelope crossfade length (controlled by character)
    - Active flag
  - Voice allocation: Linear search for inactive voice, steal oldest if all busy
  - Container: `std::array<GrainVoice, 32>`

### Grain Scheduler
- **JUCE Class:** Custom implementation (sample-based timer)
- **Purpose:** Trigger new grains based on delayTime and character (density control)
- **Parameters Affected:** delayTime, character, chaos
- **Configuration:**
  - Base spawn interval: delayTime parameter (50ms - 2s)
  - Character density adjustment:
    - At 0% (glitchy): Spawn at base delayTime interval (sparse, rhythmic)
    - At 100% (smooth): Spawn faster for dense overlap (continuous pad texture)
    - Density multiplier: `baseDensity = 1.0 + (character * 3.0)` (1-4 grains per delay period)
  - Chaos randomizes spawn timing: `spawnInterval *= (1.0 + chaos * random(-0.5, 0.5))`
  - Sample counter incremented each processBlock, triggers grain when counter >= interval

### Window Function Generator
- **JUCE Class:** `juce::dsp::WindowingFunction<float>`
- **Purpose:** Apply smooth amplitude envelope to grains (crossfade control)
- **Parameters Affected:** grainSize, character
- **Configuration:**
  - Window type: Tukey window (cosine-tapered) for controllable crossfade
  - Tukey alpha parameter controlled by character:
    - At 0% (glitchy): alpha = 0.1 (short crossfades, abrupt edges)
    - At 100% (smooth): alpha = 1.0 (full Hann-like envelope, long crossfades)
    - Formula: `alpha = 0.1 + (character * 0.9)`
  - Alternative: Use Hann window and scale crossfade portion dynamically
  - Applied as multiplication: `grainOutput = bufferSample * window[windowPos]`

### Pitch Quantization System (Octaves and Fifths)
- **JUCE Class:** Custom implementation (lookup table + random selection)
- **Purpose:** Constrain pitch randomization to harmonically pure intervals (octaves and fifths)
- **Parameters Affected:** chaos
- **Configuration:**
  - Available pitch shifts (semitones): [-12, -7, 0, +7, +12]
    - -12: One octave down
    - -7: Perfect fifth down
    - 0: No pitch shift
    - +7: Perfect fifth up
    - +12: One octave up
  - Selection algorithm:
    1. Generate random value 0.0-1.0
    2. Scale by chaos: `randomAmount = random * (chaos / 100)`
    3. At low chaos: Mostly 0 (unison)
    4. At high chaos: Full range of pitch shifts
    5. Weighted selection toward 0 at low chaos, uniform at high chaos
  - Playback rate formula: `rate = pow(2.0f, semitones / 12.0f)`
    - Examples: +12 = 2.0x (double speed), -12 = 0.5x (half speed), +7 = ~1.498x

### Random Pan Generator
- **JUCE Class:** `juce::Random` (from `juce_core`)
- **Purpose:** Randomize stereo position per grain for spatial texture
- **Parameters Affected:** chaos
- **Configuration:**
  - Pan range: 0.0 (full left) to 1.0 (full right)
  - Pan randomization scaled by chaos:
    - At 0%: All grains centered (0.5)
    - At 100%: Full stereo spread (0.0-1.0)
    - Formula: `pan = 0.5 + (random - 0.5) * (chaos / 100)`
  - Applied per grain: `leftGain = cos(pan * PI/2)`, `rightGain = sin(pan * PI/2)` (equal-power pan)

### Position Randomization
- **JUCE Class:** Custom implementation
- **Purpose:** Randomize grain read position within delay buffer for variation
- **Parameters Affected:** chaos
- **Configuration:**
  - Base position: Delay time minus grain size (start of buffer region to read)
  - Position randomization scaled by chaos:
    - At 0%: Fixed position (rhythmic, regular)
    - At 100%: Full randomization within delay buffer
    - Formula: `position = basePosition * (1.0 + (random - 0.5) * (chaos / 100) * 0.5)`
  - Ensures grain stays within valid buffer range

### Feedback Loop
- **JUCE Class:** Custom implementation (manual buffer mixing)
- **Purpose:** Feed processed grain output back into delay buffer for evolving textures
- **Parameters Affected:** feedback
- **Configuration:**
  - Feedback gain: 0.0-0.95 (0-100% parameter mapped to prevent runaway)
  - Feedback signal is stereo (summed to mono for mono grain buffer input)
  - Formula: `inputSample = drySample + ((leftOutput + rightOutput) * 0.5f * feedbackGain)`
  - Apply soft saturation at high feedback: `tanh(feedbackSignal)` to prevent clipping/instability

### Dry/Wet Mixer
- **JUCE Class:** `juce::dsp::DryWetMixer<float>`
- **Purpose:** Blend unprocessed input with granular-processed output
- **Parameters Affected:** mix
- **Configuration:**
  - MIX (0-100%) maps to wet proportion (0.0-1.0)
  - Input is mono, output is stereo
  - Dry signal: Mono duplicated to both stereo channels
  - Wet signal: Stereo grain output
  - `pushDrySamples()` before processing, `mixWetSamples()` after

---

## Processing Chain

```
Input (Mono)
  |
Dry/Wet Mixer (capture dry) <- MIX
  |
Mix with Feedback Signal <- FEEDBACK
  |
Write to Grain Buffer <- delayTime
  |
Grain Scheduler (trigger new grains) <- delayTime, character, chaos
  |
For each active grain (up to 32 voices):
  |
  +-- Read from Grain Buffer (interpolated) <- Position randomization (chaos)
  +-- Apply Pitch Shift (playback rate) <- Pitch quantization (chaos)
  +-- Apply Window Envelope <- grainSize, character (crossfade)
  +-- Apply Pan Position <- Pan randomization (chaos)
  |
Sum all active grain outputs (Stereo)
  |
Apply Feedback Gain <- FEEDBACK
  |
Feed back to input (stereo summed to mono)
  |
Dry/Wet Mixer (blend) <- MIX
  |
Output (Stereo)
```

**Routing notes:**
- Mono input, stereo output (grain panning creates stereo field)
- Feedback loop: Stereo grain output -> summed to mono -> mixed with input -> grain buffer
- Parallel grain voices: All 32 voices process independently, outputs summed
- Character affects both grain density (spawn rate) AND crossfade envelope shape
- Chaos scales four randomization dimensions: position, pitch, pan, spawn timing

---

## System Architecture

### Tempo Sync System

**DAW integration:** Query host for tempo information

**JUCE classes:**
- `juce::AudioPlayHead` - Host transport state
- `juce::AudioPlayHead::getPosition()` - Get current tempo (BPM)

**Note division mapping (at 120 BPM):**
- 1/16 note: 125ms
- 1/8 note: 250ms
- 1/4 note: 500ms
- 1/2 note: 1000ms
- 1 (whole): 2000ms

**Implementation:**
- When tempoSync = true:
  - Query BPM from playhead
  - Quantize delayTime to nearest note division
  - Recalculate on tempo change or parameter change
- When tempoSync = false:
  - Use delayTime directly in ms (free-running)

**Error handling:**
- If playhead unavailable (offline bounce): Use default 120 BPM
- If tempo invalid (<20 or >300 BPM): Clamp to valid range

---

## Parameter Mapping

| Parameter ID | Type | Range | DSP Component | Usage |
|-------------|------|-------|---------------|-------|
| delayTime | Float | 50-2000ms | Grain Buffer, Grain Scheduler | Buffer read position, spawn interval base |
| tempoSync | Bool | On/Off | Grain Scheduler | Enable note division quantization |
| grainSize | Float | 5-500ms | Window Function | Window length, grain duration |
| feedback | Float | 0-100% | Feedback Loop | Feedback gain (0.0-0.95) |
| chaos | Float | 0-100% | All randomization systems | Master randomization amount |
| character | Float | 0-100% | Grain Scheduler, Window Function | Density (spawn rate) + crossfade (envelope shape) |
| mix | Float | 0-100% | Dry/Wet Mixer | Wet proportion (0.0-1.0) |

---

## Algorithm Details

### Chaos Master Randomization

**Algorithm:** Single parameter scales multiple randomization dimensions

**Implementation notes:**
- Chaos controls four dimensions simultaneously:
  1. **Position randomization:** Grain read position jitter in delay buffer
  2. **Pitch randomization:** Probability/amount of pitch shift selection
  3. **Pan randomization:** Stereo spread of grain positions
  4. **Timing randomization:** Spawn interval jitter
- Unified control makes plugin easier to use (one knob for "amount of chaos")
- Per-grain calculations:
  ```cpp
  float chaosAmount = chaos / 100.0f; // 0.0 - 1.0

  // Position jitter
  float positionJitter = chaosAmount * random(-0.5f, 0.5f) * 0.5f;
  float readPosition = basePosition * (1.0f + positionJitter);

  // Pitch selection probability
  int pitchShift = selectPitchShift(chaosAmount, random());

  // Pan spread
  float pan = 0.5f + (random(-0.5f, 0.5f) * chaosAmount);

  // Timing jitter
  float timingJitter = chaosAmount * random(-0.5f, 0.5f);
  int spawnInterval = baseInterval * (1.0f + timingJitter);
  ```

---

### Character Morphing (Glitchy to Smooth)

**Algorithm:** Single parameter controls both density and crossfade

**Implementation notes:**
- Character simultaneously adjusts:
  1. **Grain density:** Number of overlapping grains per delay period
  2. **Crossfade duration:** Tukey window alpha parameter
- At 0% (glitchy):
  - Low density: ~1 grain per delay period (sparse, rhythmic, "stuttering")
  - Short crossfade: alpha = 0.1 (abrupt attack/release, clicking texture)
- At 100% (smooth/angelic):
  - High density: ~4 grains per delay period (dense overlap)
  - Long crossfade: alpha = 1.0 (full Hann envelope, blurred texture)
- Implementation:
  ```cpp
  float characterAmount = character / 100.0f; // 0.0 - 1.0

  // Density multiplier (1.0 to 4.0)
  float densityMultiplier = 1.0f + (characterAmount * 3.0f);
  int spawnInterval = delayTimeSamples / densityMultiplier;

  // Crossfade alpha (0.1 to 1.0)
  float tukeyAlpha = 0.1f + (characterAmount * 0.9f);
  generateTukeyWindow(window, grainSizeSamples, tukeyAlpha);
  ```

---

### Pitch Quantization to Octaves and Fifths

**Algorithm:** Constrained random selection from harmonic intervals

**Implementation notes:**
- Available pitches: [-12, -7, 0, +7, +12] semitones
- Selection weighted by chaos amount:
  ```cpp
  float chaosAmount = chaos / 100.0f;
  float random = Random::getSystemRandom().nextFloat();

  if (chaosAmount < 0.01f) {
      // No chaos = unison only
      return 0;
  }

  // Weight toward unison at low chaos, uniform at high chaos
  float threshold = chaosAmount;
  if (random > threshold) {
      return 0; // Unison
  }

  // Select from pitch options (excluding unison)
  const int pitchOptions[] = {-12, -7, +7, +12};
  int index = (int)(random / threshold * 4) % 4;
  return pitchOptions[index];
  ```
- Playback rate: `rate = pow(2.0f, semitones / 12.0f)`
  - -12 semitones: 0.5x speed (octave down)
  - -7 semitones: ~0.667x speed (fifth down)
  - 0 semitones: 1.0x speed (unison)
  - +7 semitones: ~1.498x speed (fifth up)
  - +12 semitones: 2.0x speed (octave up)

---

### Grain Windowing (Tukey Window)

**Algorithm:** Cosine-tapered window with adjustable crossfade

**Implementation notes:**
- Tukey window formula:
  ```cpp
  void generateTukeyWindow(std::vector<float>& window, int size, float alpha) {
      for (int n = 0; n < size; ++n) {
          float x = (float)n / (size - 1);
          if (x < alpha / 2.0f) {
              // Cosine rise
              window[n] = 0.5f * (1.0f - cos(2.0f * PI * x / alpha));
          } else if (x < 1.0f - alpha / 2.0f) {
              // Flat top
              window[n] = 1.0f;
          } else {
              // Cosine fall
              window[n] = 0.5f * (1.0f - cos(2.0f * PI * (1.0f - x) / alpha));
          }
      }
  }
  ```
- Alpha = 0.1: Short rise/fall (10% of window on each side), long flat top
- Alpha = 1.0: No flat top (full Hann window), smooth rise/fall
- Applied per-sample: `output = bufferSample * window[windowPosition]`

---

## Integration Points

### Feature Dependencies

- **Grain scheduler -> Voice engine:** Scheduler triggers grain spawns, voice engine allocates voices
- **Voice engine -> Grain buffer:** Voices read from grain buffer at various positions
- **Chaos -> All randomization:** Chaos parameter scales position, pitch, pan, timing
- **Character -> Density + Window:** Character affects spawn rate AND window shape
- **Feedback -> Grain buffer input:** Feedback output mixed with dry input before buffer write
- **All grain voices -> Dry/wet mixer:** Summed stereo grain output blended with dry signal

---

### Parameter Interactions

- **Chaos affects multiple systems simultaneously:**
  - Position: Higher chaos = more grain position jitter
  - Pitch: Higher chaos = more pitch variation (octaves/fifths vs unison)
  - Pan: Higher chaos = wider stereo spread
  - Timing: Higher chaos = more irregular spawn timing
  - Interaction: At 0% chaos, output is rhythmic and centered; at 100%, output is chaotic and spread

- **Character affects density AND crossfade together:**
  - Low character (0%): Sparse + abrupt = glitchy/stuttering texture
  - High character (100%): Dense + smooth = pad-like/angelic texture
  - Interaction: They reinforce each other (sparse + smooth or dense + abrupt would be contradictory)

- **Feedback + Chaos create evolving textures:**
  - Feedback alone: Regular delays building up
  - Chaos alone: Random but decaying
  - Both together: Evolving, unpredictable clouds
  - Risk: High feedback + high chaos can quickly become cacophonous (intentional for "chaos" aesthetic)

- **GrainSize + DelayTime interaction:**
  - GrainSize > DelayTime: Grains overlap significantly (potential for artifacts)
  - GrainSize << DelayTime: Sparse grains with gaps
  - Balanced: GrainSize ~= DelayTime/2 to DelayTime for smooth overlap

---

### Processing Order Requirements

**Sequential processing order (REQUIRED):**

1. **Capture dry signal:** Store mono input in DryWetMixer
   - Must happen first to preserve clean input

2. **Mix feedback with input:** Combine dry mono input with feedback signal
   - Feedback from previous cycle (stereo summed to mono)

3. **Write to grain buffer:** Store (dry + feedback) signal in delay buffer
   - Grains will read from this buffer

4. **Grain scheduler tick:** Check if new grain should spawn
   - Based on delayTime, character density, chaos timing jitter
   - Sample counter incremented, trigger when counter >= interval

5. **Spawn new grain (if triggered):** Allocate voice, randomize parameters
   - Randomize: Position, pitch (quantize to octaves/fifths), pan
   - Calculate playback rate from pitch shift
   - Generate Tukey window with character-controlled alpha

6. **Process all active grains:** Read from buffer, apply window, pan to stereo
   - Each grain reads at its own position with playback rate
   - Apply window envelope (anti-click, crossfade)
   - Apply pan (stereo positioning with equal-power pan law)
   - Sum all grain outputs to stereo

7. **Apply feedback gain:** Scale grain output for feedback loop
   - Sum stereo to mono for feedback signal
   - Apply soft saturation at high feedback

8. **Blend with dry signal:** Mix stereo grain output with mono dry
   - DryWetMixer combines based on mix parameter
   - Dry signal duplicated to both channels

**Why order matters:**
- Dry capture first: Prevents feedback-contaminated dry signal
- Feedback before write: Feedback must mix with input before buffer write
- Grain spawn after write: Grains read from buffer with latest input + feedback
- Feedback gain after grain sum: Total output controls feedback amount

---

### Thread Boundaries

**Threads:**
- **Audio thread:** All DSP processing in `processBlock()`
- **Message thread:** UI interactions, parameter updates
- **No background thread needed:** All processing is real-time

**Audio thread:**
- Grain processing (voice management, window application, buffer reads)
- Grain buffer write/read
- Feedback mixing
- Parameter reads via `APVTS::getRawParameterValue()->load()` (atomic)

**Message thread:**
- Parameter updates from UI via APVTS (atomic writes)
- Preset loading/saving
- UI repaints

**Communication:**
- APVTS parameters: Atomic reads (audio thread) / atomic writes (message thread)
- No custom thread communication needed (APVTS handles it)

**Safety guarantees:**
- Audio thread NEVER allocates memory (pre-allocated voice array)
- Audio thread NEVER waits on locks
- Window tables can be pre-calculated (avoid per-grain allocation)

---

## Implementation Risks

### Granular Synthesis Engine

**Complexity:** HIGH
- Polyphonic voice management (32 voices)
- Real-time grain scheduling
- Per-grain window envelope with variable alpha
- Complex state management

**Risk Level:** MEDIUM

**Risk factors:**
1. CPU usage with 32 simultaneous grains at high density
   - Each grain: Buffer read (interpolated), window multiplication, pan calculation
   - Estimated: ~30-50% CPU at 32 voices, 48kHz
2. Voice allocation logic must be efficient (linear search per grain spawn)
3. Tukey window calculation per grain (can't pre-calculate due to variable alpha)

**Alternative approaches:**
1. **Fixed lower voice count (16 voices):**
   - Complexity: Same
   - CPU: ~15-25% (lower)
   - Quality: Less dense textures at high character

2. **Pre-calculated window tables (discrete alpha levels):**
   - Pre-calculate windows for alpha = 0.1, 0.3, 0.5, 0.7, 1.0
   - Select nearest table at grain spawn
   - Lower CPU, slight quality loss

**Fallback architecture:**
- **Primary:** 32 polyphonic grain voices with per-grain Tukey window
- **Fallback 1:** Reduce to 16 voices if CPU exceeds 60% single core
- **Fallback 2:** Use pre-calculated window tables (5 alpha levels)

**Mitigation strategy:**
1. Pre-calculate window lookup tables (at least for common alpha values)
2. Profile voice processing loop early (Stage 3)
3. Test with extreme parameters (100% character = 4x density, 5ms grain size)
4. Consider SIMD optimization if needed (juce::FloatVectorOperations)

---

### Pitch Quantization to Octaves/Fifths

**Complexity:** LOW
- Simple lookup table (5 values)
- Weighted random selection

**Risk Level:** LOW

**Risk factors:**
1. Playback rate at ±12 semitones doubles/halves grain length
2. Extreme pitch shifts may cause grain to exceed buffer bounds

**Alternative approaches:**
- Limit to ±7 semitones (fifths only) if octave shifts cause issues

**Fallback architecture:**
- Primary approach is simple, no fallback needed

**Mitigation:**
- Ensure grain read position + pitch-adjusted length stays within buffer
- Clamp read position to valid range

---

### Character Morphing System

**Complexity:** MEDIUM
- Dual control (density + crossfade) from single parameter
- Non-linear mapping for perceptual smoothness

**Risk Level:** LOW

**Risk factors:**
1. Finding good mapping curves for density and alpha
2. Perceptual balance between glitchy and smooth extremes

**Fallback architecture:**
- If mapping doesn't feel right, separate into two parameters (post-1.0 improvement)

**Mitigation:**
- Test extensively with audio material
- Reference Mutable Instruments Beads for similar "texture" control

---

### Chaos Master Randomization

**Complexity:** MEDIUM
- Single parameter controls four dimensions
- Requires balanced scaling per dimension

**Risk Level:** LOW

**Risk factors:**
1. Scaling factors for each dimension must be balanced
2. At 100% chaos, output may be too chaotic for some users

**Alternative approaches:**
- Expose individual randomization controls (complex but flexible)
- Add "chaos character" switch (position-focused vs pitch-focused)

**Fallback architecture:**
- Primary unified chaos is good design; no fallback needed
- Individual controls could be added in v1.1 if users request

**Mitigation:**
- Test with various audio material (pads, drums, vocals)
- Tune scaling factors for each dimension empirically

---

### Overall Project Risk

**Overall complexity:** MEDIUM-HIGH
- Granular engine (HIGH) + character morphing (MEDIUM) + chaos system (MEDIUM)
- Multiple complex features but simpler than full scale quantization

**Highest risk component:** Granular Synthesis Engine
- Represents ~50% of project risk
- Most CPU-intensive
- Complex voice management

**Recommended approach:**
1. **Phase 1 - Core engine:** Implement grain voices, scheduler, basic playback
2. **Phase 2 - Windowing + character:** Add Tukey window with character control
3. **Phase 3 - Pitch + chaos:** Add pitch quantization and chaos system
4. **Phase 4 - Feedback + mixing:** Add feedback loop, dry/wet, final integration

---

## Architecture Decisions

### Playback Rate Pitch Shifting (vs Phase Vocoder)

**Decision:** Use playback rate adjustment for pitch shifting (time-domain)

**Rationale:**
- Standard approach for granular synthesis (Clouds, Beads, Portal)
- Lower CPU usage (~10-15% per grain vs ~40% for phase vocoder)
- Lower latency (no FFT window delay)
- Simpler implementation (single formula: `rate = 2^(semitones/12)`)
- Artifacts acceptable for granular textures

**Alternatives considered:**
1. **Phase vocoder:**
   - Why rejected: Overkill for granular grains, high CPU cost
   - When to reconsider: Not anticipated (playback rate is standard)

**Tradeoffs accepted:**
- **Timbral change at extreme pitch shifts:** Formants shift with pitch
  - Acceptable because: Granular synthesis is textural/abstract
- **Grain duration changes with pitch:** Higher pitch = shorter playback
  - Acceptable because: Window envelope compensates

---

### Octaves and Fifths Only (vs Full Scale Quantization)

**Decision:** Constrain pitch shifts to octaves (+/-12) and fifths (+/-7) only

**Rationale:**
- Creative brief specifies "celestial rather than atonal"
- Octaves and fifths are the most consonant intervals
- Simpler than full scale quantization (no scale/root parameters)
- Matches inspiration from harmonic series (pure intervals)
- Reduces parameter count (no scale type, no root note)

**Alternatives considered:**
1. **Full scale quantization (like Scatter):**
   - Why rejected: Adds complexity (2 more parameters), creative brief wants simplicity
   - When to reconsider: If users request melodic scale options

2. **No quantization (continuous pitch):**
   - Why rejected: Can sound atonal/dissonant, against "angelic" vision
   - When to reconsider: Not anticipated

**Tradeoffs accepted:**
- **Limited harmonic vocabulary:** Only 5 pitch options
  - Acceptable because: Octaves/fifths are always harmonious
- **Less melodic complexity:** Can't match specific scales
  - Acceptable because: Plugin targets "ethereal texture" not "melodic harmony"

---

### Chaos as Master Randomization (vs Individual Controls)

**Decision:** Single chaos parameter scales all randomization dimensions

**Rationale:**
- Creative brief specifies "single chaos knob scales all randomization"
- Simplifies UI (7 parameters instead of 10+)
- Easier to use (one knob for "unpredictability")
- Matches professional plugin design (Clouds/Beads have similar unified controls)

**Alternatives considered:**
1. **Individual randomization controls:**
   - Why rejected: Adds 3-4 parameters, contradicts creative brief
   - When to reconsider: If users strongly request separate controls (v1.1)

**Tradeoffs accepted:**
- **Coupled randomization:** Can't have high pitch variance with low pan variance
  - Acceptable because: Unified chaos is the design vision
- **Less fine-grained control:** Advanced users may want more control
  - Acceptable because: Core target is simplicity; can add later

---

### Character as Dual Control (vs Separate Density/Crossfade)

**Decision:** Single character parameter controls both density and crossfade

**Rationale:**
- Creative brief describes glitchy-to-smooth morphing as unified concept
- "Glitchy" = sparse + abrupt; "Smooth" = dense + blurred
- These naturally go together (separating them would be confusing)
- Simplifies UI and mental model

**Alternatives considered:**
1. **Separate density and crossfade parameters:**
   - Why rejected: Would create contradictory states (sparse + smooth?)
   - When to reconsider: Not anticipated

**Tradeoffs accepted:**
- **Coupled control:** Can't have dense + abrupt or sparse + smooth
  - Acceptable because: Those combinations don't match the vision

---

### 32 Grain Voices (vs 64)

**Decision:** Use 32 grain voices maximum

**Rationale:**
- AngelGrain is simpler than Scatter (no scale quantization, no visualization)
- 32 voices sufficient for dense textures at 4x density multiplier
- Lower CPU usage than 64 voices
- Mono input simplifies (no stereo voice doubling)

**Alternatives considered:**
1. **64 voices (like Scatter):**
   - Why rejected: Higher CPU, not needed for this design
   - When to reconsider: If density at 100% character sounds thin

**Tradeoffs accepted:**
- **Lower maximum density:** May not achieve as dense clouds as Scatter
  - Acceptable because: 32 voices at 4x density = effectively 128 overlapping at extreme settings

---

## Special Considerations

### Thread Safety
- All parameter reads use atomic `getRawParameterValue()->load()` (APVTS)
- Voice array pre-allocated in `prepareToPlay()` (no allocations in `processBlock()`)
- Grain scheduler uses sample counter (no time-based operations in audio thread)
- Window generation should be done efficiently (pre-calculate if possible)

### Performance
- **Estimated CPU usage:**
  - Granular engine (32 voices): ~30-45% single core
  - Pitch shifting (playback rate): ~5%
  - Window application: ~5%
  - Total: ~40-55% single core at 48kHz, 512 sample buffer
- **Optimization opportunities:**
  - Pre-calculate window tables for common alpha values
  - Use SIMD for grain summing (`juce::FloatVectorOperations::add`)
  - Early-exit inactive voices
- **Buffer size sensitivity:**
  - Smaller buffers (64 samples) -> more overhead
  - Larger buffers (2048 samples) -> better efficiency

### Denormal Protection
- Use `juce::ScopedNoDenormals` in `processBlock()`
- Grain voices may produce denormals near window end (fade to zero)
- Feedback loop may accumulate denormals at high feedback
- DelayLine and DryWetMixer handle denormals internally

### Sample Rate Handling
- Grain buffer resized in `prepareToPlay()` based on sample rate
- Maximum 2 seconds at any sample rate (e.g., 384,000 samples at 192kHz)
- Grain scheduler recalculates spawn interval on sample rate change
- Playback rate calculation is sample-rate-independent

**Sample rate scaling:**
- 44.1kHz: delayTime 1000ms = ~44,100 samples
- 48kHz: delayTime 1000ms = ~48,000 samples
- 96kHz: delayTime 1000ms = ~96,000 samples

### Latency
- **Processing latency sources:**
  - Grain buffer read: 50-2000ms (user-controlled via delayTime)
  - No FFT latency (time-domain pitch shifting)
  - No lookahead
- **Host compensation:**
  - Granular delay is creative effect, not precision time-alignment
  - Could report delayTime as latency, but varies with parameter
  - Recommendation: Don't report latency (like most granular plugins)

---

## Research References

### Professional Plugins

1. **Mutable Instruments Clouds/Beads**
   - Real-time granular synthesis with delay paradigm
   - Parameters: SIZE (grain size), DENSITY (overlap), TEXTURE (character), PITCH, BLEND (dry/wet)
   - Observed: TEXTURE control for "glitchy to smooth" morphing is key inspiration
   - Beads adds built-in reverb, seed/attenuation for grain spawning
   - Internal processing: 32kHz 32-bit floating point, 16-bit recording buffer

2. **Arturia Efx Fragments**
   - Granular effects processor with Classic/Texture/Rhythmic modes
   - Captures audio in buffer, plays back grains
   - Spray and randomization for evolving soundscapes
   - Observed: Texture mode creates "grain clouds" similar to high-character AngelGrain

3. **Output Portal**
   - Granular delay with pitch shifting, scale quantization
   - Parameters: DENSITY, GRAIN SIZE, PITCH, REVERSE, FEEDBACK, PAN
   - Observed: Professional reference for granular delay architecture

4. **Red Panda Particle**
   - Hardware granular delay pedal
   - Pitch quantization to octaves, octaves & fifths, semitones
   - Observed: Confirms octaves & fifths quantization is established approach

### JUCE Documentation

- **juce::dsp::DelayLine:** Variable delay with interpolation (Linear, Lagrange3rd)
  - Lagrange3rd recommended for pitch modulation
  - Prepare with ProcessSpec, process with AudioBlock
- **juce::dsp::WindowingFunction:** Window table generation (Hann, Blackman, rectangular)
  - Note: Tukey window not built-in, needs custom implementation
  - Alternative: Use Hann and scale crossfade portion
- **juce::dsp::DryWetMixer:** Latency-compensated dry/wet mixing
  - `pushDrySamples()` -> process -> `mixWetSamples()`
- **juce::Random:** Thread-safe random number generation
  - `getSystemRandom().nextFloat()` for 0.0-1.0 range
- **juce::AudioPlayHead:** Host transport state for tempo sync
  - `getPosition()` to get BPM

### Technical Resources

- **Granular Synthesis Basics (Sound on Sound):** Grain durations 10-50ms typical, density hundreds to thousands per second
- **Window Functions (michaelkrzyzaniak.com):** Hann window as "raised cosine," reaches zero at endpoints
- **Equal Power Crossfade (DSP Stack Exchange):** `leftGain = cos(pan * PI/2)`, `rightGain = sin(pan * PI/2)`
- **Mutable Instruments Documentation:** Clouds/Beads parameters and signal flow
- **Tukey Window (Wikipedia):** Cosine-tapered window, alpha parameter for crossfade amount

---

## Notes

- Pitch quantization to octaves/fifths is simpler than Scatter's scale system but equally effective for "celestial" harmony
- Character morphing (glitchy <-> smooth) is unique dual-control innovation
- Chaos master randomization reduces cognitive load vs individual controls
- Mono input -> stereo output is efficient and matches use case (processing mono sources into stereo textures)
- 32 grain voices should be sufficient; can increase if density feels thin
- Tukey window alpha control is elegant solution for crossfade variation; if implementation is complex, can fall back to Hann with scaled attack/release portions
- Tempo sync is straightforward JUCE pattern using AudioPlayHead
- No visualization planned for v1.0.0 (can add grain activity display in v1.1 if desired)
