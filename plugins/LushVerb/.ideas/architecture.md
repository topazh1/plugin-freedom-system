# DSP Architecture: LushVerb

**CRITICAL CONTRACT:** This specification is immutable during Stages 2-5 implementation. Stage 1 Planning cannot proceed without this file. Stage 4 (DSP) implements this exact architecture.

**Generated by:** Stage 0 Research
**Referenced by:** Stage 1 (Planning), Stage 4 (DSP Implementation)
**Purpose:** DSP specification defining processing components, signal flow, and JUCE module usage

---

## Core Components

### Reverb Engine
- **JUCE Class:** `juce::dsp::Reverb`
- **Purpose:** Generate lush algorithmic reverb based on FreeVerb algorithm
- **Parameters Affected:** SIZE, DAMPING
- **Configuration:**
  - SIZE (0.5s-20s) maps to roomSize parameter via formula: `roomSize = 0.1 + (sizeSeconds / 20.0) * 0.9` (0.1-1.0 range)
  - DAMPING (0-100%) maps directly to damping parameter (0.0-1.0 range, high-frequency rolloff)
  - Width fixed at 1.0 (full stereo width for lush character)
  - wetLevel and dryLevel controlled via DryWetMixer (not Reverb internal)
  - freezeMode disabled (not part of design)

### Shimmer Pitch Shifter
- **JUCE Class:** Custom implementation using `juce::dsp::FFT`
- **Purpose:** Create +1 octave pitch-shifted signal for ethereal shimmer effect
- **Parameters Affected:** SHIMMER
- **Configuration:**
  - FFT size: 2048 samples (tradeoff: latency ~46ms @ 44.1kHz vs quality)
  - Overlap: 4x (75% overlap, standard for phase vocoder)
  - Algorithm: Phase vocoder (STFT → frequency domain pitch shift → ISTFT)
  - Pitch shift factor: 2.0 (exactly +1 octave)
  - SHIMMER (0-100%) controls wet amount mixed into reverb input
  - At 0%, shimmer is bypassed entirely (no CPU cost)
  - Window function: Hann window for smooth overlap-add

### Modulation System
- **JUCE Class:** Custom implementation using `juce::dsp::DelayLine` with Lagrange3rd interpolation
- **Purpose:** Built-in subtle modulation for depth and movement (not user-controlled)
- **Parameters Affected:** None (automatic, always active)
- **Configuration:**
  - Dual LFO system (two independent LFOs for complexity):
    - LFO 1: 0.3Hz (slow, wide movement)
    - LFO 2: 0.5Hz (faster, adds texture)
  - Modulation depth: ±3ms delay variation (subtle, not obvious pitch wobble)
  - Delay line: 10ms max delay (20ms total buffer)
  - Interpolation: Lagrange3rd (smooth, low artifacts for pitch modulation)
  - Applied to reverb output (post-reverb, pre-dry/wet mix)

### Dry/Wet Mixer
- **JUCE Class:** `juce::dsp::DryWetMixer<float>`
- **Purpose:** Latency-compensated dry/wet blending
- **Parameters Affected:** MIX
- **Configuration:**
  - MIX (0-100%) maps to wet proportion (0.0-1.0)
  - Mixing rule: Linear (`dsp::DryWetMixingRule::linear`)
  - Latency compensation: Handles shimmer FFT latency (~46ms @ 44.1kHz)
  - Dry signal captured before any processing to preserve clean input

---

## Processing Chain

```
Input (Stereo)
  ↓
Dry/Wet Mixer (capture dry) ← MIX parameter
  ↓
Shimmer Pitch Shifter (+1 octave) ← SHIMMER parameter
  ↓
[Shimmer blended with input based on SHIMMER amount]
  ↓
Reverb Engine ← SIZE, DAMPING parameters
  ↓
Dual LFO Modulation (automatic, ±3ms)
  ↓
Dry/Wet Mixer (blend with latency-compensated dry) ← MIX parameter
  ↓
Output (Stereo)
```

**Routing notes:**
- Shimmer is applied BEFORE reverb (creates pitch-shifted reverb tail, not transposed reverb)
- Shimmer at 0% bypasses FFT processing entirely (CPU optimization)
- Modulation is always active (built-in lush character)
- Dry signal is captured before shimmer to preserve clean input (no latency corruption)
- All processing is stereo (dual-mono with cross-channel modulation for width)

---

## Parameter Mapping

| Parameter ID | Type | Range | DSP Component | Usage |
|-------------|------|-------|---------------|-------|
| SIZE | Float | 0.5-20.0s | Reverb Engine | Maps to roomSize via formula: `0.1 + (sizeSeconds / 20.0) * 0.9` (0.1-1.0) |
| DAMPING | Float | 0-100% | Reverb Engine | Maps to damping parameter (0.0-1.0, high-frequency rolloff) |
| SHIMMER | Float | 0-100% | Shimmer Pitch Shifter | Wet amount of +1 octave signal (0% = bypass, higher = more shimmer) |
| MIX | Float | 0-100% | Dry/Wet Mixer | Wet proportion (0.0-1.0, 0% = fully dry, 100% = fully wet) |

---

## Algorithm Details

### Shimmer Pitch Shifter (Phase Vocoder)

**Algorithm:** FFT-based phase vocoder for pitch shifting

**Implementation notes:**
- **Analysis:** 2048-point FFT with Hann window, 75% overlap (hop size = 512 samples)
- **Spectral manipulation:** Frequency bins resampled by factor of 2.0 (double frequency = +1 octave)
  - Bin mapping: `outputBin[i] = inputBin[i / 2.0]` with interpolation for fractional indices
  - Phase correction: Adjust phase based on frequency shift to maintain coherence
- **Synthesis:** Inverse FFT (IFFT) with overlap-add reconstruction
- **Latency:** 2048 samples (~46ms @ 44.1kHz, ~42ms @ 48kHz)
- **Window compensation:** Gain normalization for Hann window overlap-add (factor of 1.5 for 75% overlap)
- **Edge case handling:** Bins above Nyquist/2 are zeroed (no aliasing from pitch shift)

**Reference:**
- Stanford CCRMA paper: "Shimmer Audio Effect - A Harmonic Reverberator"
- Phase vocoder technique based on Laroche & Dolson (1999) real-time pitch shifting

### Modulation System (Dual LFO)

**Algorithm:** Dual sine-wave LFOs modulating delay time

**Implementation notes:**
- **LFO 1:** `phase1 += (0.3Hz * 2π) / sampleRate` per sample
- **LFO 2:** `phase2 += (0.5Hz * 2π) / sampleRate` per sample
- **Combined modulation:** `delayTime = baseDelay + (sin(phase1) + sin(phase2)) * depth`
  - baseDelay = 5ms (center point)
  - depth = 3ms (±3ms variation, total range 2-8ms)
- **Interpolation:** Lagrange3rd for smooth fractional delay (reduces zipper noise)
- **Phase wrapping:** `if (phase > 2π) phase -= 2π` to avoid floating-point drift
- **Stereo:** LFO2 phase offset by 90° for right channel (creates stereo width)

### Reverb Engine

**Algorithm:** JUCE dsp::Reverb (FreeVerb-based algorithm)

**Implementation notes:**
- **SIZE mapping:** `roomSize = 0.1 + (sizeSeconds / 20.0) * 0.9`
  - 0.5s → roomSize = 0.125 (small room)
  - 2.5s → roomSize = 0.212 (default, medium room)
  - 20.0s → roomSize = 1.0 (infinite, maximum lushness)
- **DAMPING mapping:** Direct linear mapping `damping = dampingPercent / 100.0`
  - 0% → damping = 0.0 (bright, airy, crystalline)
  - 30% → damping = 0.3 (default, balanced)
  - 100% → damping = 1.0 (dark, warm, diffuse)
- **Fixed parameters:**
  - width = 1.0 (full stereo width)
  - wetLevel = 1.0 (Dry/Wet handled by DryWetMixer, not internal Reverb)
  - dryLevel = 0.0 (Dry signal handled externally)
  - freezeMode = 0.0 (disabled, not part of design)

---

## Integration Points

### Feature Dependencies

- Shimmer → Reverb engine: Pitch-shifted signal must be mixed with input before reverb processing
- Reverb engine → Modulation: Reverb output feeds modulation delay line
- Modulation → Dry/wet mixer: Modulated signal is the "wet" input for final blend
- All features → Processing order: Sequential dependencies require specific order (see Processing Order below)

---

### Parameter Interactions

- SIZE affects perceived lushness independently of SHIMMER:
  - Short SIZE (0.5-2s) with high SHIMMER → Tight, shimmering ambience
  - Long SIZE (10-20s) with high SHIMMER → Infinite, ethereal pad textures
  - SIZE and SHIMMER are orthogonal (no interaction)

- DAMPING affects shimmer brightness:
  - Low DAMPING (0-30%) with SHIMMER → Bright, crystalline shimmer
  - High DAMPING (70-100%) with SHIMMER → Dark, warm shimmer
  - DAMPING filters reverb output, which includes shimmer harmonics

- MIX affects perceived shimmer intensity:
  - Low MIX (0-30%) → Subtle shimmer layer
  - High MIX (70-100%) → Dominant shimmer effect
  - MIX does NOT affect internal shimmer processing (shimmer always +1 octave)

- Modulation is always active (not user-controlled):
  - Adds lushness automatically regardless of parameter settings
  - No interaction with user parameters (independent processing)

---

### Processing Order Requirements

**Sequential processing order (REQUIRED):**

1. **Capture dry signal:** Store unprocessed input for later mixing
   - Must happen first to preserve clean input before any processing

2. **Apply shimmer pitch shift:** FFT-based phase vocoder (+1 octave)
   - Happens before reverb to create pitch-shifted reverb tail
   - Shimmer amount (0-100%) controls blend with input

3. **Process through reverb:** Apply algorithmic reverb to shimmer + input mix
   - Reverb processes the combined signal (input + pitch-shifted harmonics)

4. **Apply modulation:** Dual LFO modulation to reverb output
   - Adds depth and movement automatically (built-in lush character)

5. **Blend with dry signal:** Mix modulated reverb with captured dry signal
   - Dry/Wet mixer handles latency compensation (shimmer FFT latency)
   - Final output is dry/wet blend controlled by MIX parameter

**Why order matters:**
- Shimmer before reverb: Creates shimmering reverb tail (pitch-shifted harmonics in reverb)
- Shimmer after reverb: Would NOT create shimmer effect (just transposed reverb output)
- Dry capture first: Prevents latency-corrupted dry signal in dry/wet mix
- Modulation after reverb: Adds movement to reverb tail (not to dry signal)

---

### Thread Boundaries

**Audio thread:**
- All DSP processing (shimmer FFT, reverb, modulation, dry/wet mix)
- Parameter reads via `APVTS::getRawParameterValue()->load()` (atomic)
- Sample-by-sample processing in processBlock()
- NO allocations, NO locks, NO file I/O

**Message thread:**
- Parameter updates from UI via APVTS (atomic writes)
- Preset loading/saving
- UI repaints

**No background thread needed:**
- No file I/O
- No long-running operations
- All processing is real-time compatible

**Communication:**
- APVTS parameters: Atomic reads (audio thread) / atomic writes (message thread)
- No custom thread communication needed (APVTS handles it)

---

## Implementation Risks

### Shimmer Pitch Shifter (Phase Vocoder)

**Complexity:** HIGH
- Requires FFT → phase adjustment → IFFT pipeline
- Overlapping FFT windows (75% overlap typical)
- Phase correction for bin resampling
- Buffer management for overlap-add synthesis

**Risk Level:** HIGH

**Risk factors:**
1. Phase vocoder is non-trivial to implement correctly
   - Phase unwrapping and adjustment requires expertise
   - Artifacts (phasiness, metallic sound) if done incorrectly
2. No existing JUCE phase vocoder class (custom implementation required)
3. High CPU cost (~40-60% single core for good quality)
4. Latency (FFT size = 2048 samples = ~42ms @ 48kHz)

**Alternative approaches:**
1. **Granular synthesis:**
   - Complexity: MEDIUM
   - Quality: Lower than phase vocoder (graininess artifacts)
   - CPU: ~20-30% single core
   - Latency: Lower (~10-20ms)
   - Best for: Less critical pitch shift quality

2. **Delay-based pitch shift:**
   - Complexity: LOW
   - Quality: Lowest (only works for small shifts, audible artifacts)
   - CPU: ~5% single core
   - Latency: Minimal (~1-2ms)
   - Best for: Prototyping, reduced-scope version

**Fallback architecture:**
- **Primary:** Phase vocoder (highest quality)
- **Fallback 1:** If phase vocoder artifacts unacceptable → Granular synthesis
- **Fallback 2:** If granular fails → Simple delay-based pitch shift + reverb
- **Fallback 3:** If all pitch shifting fails → Standard reverb with modulation (no shimmer, reduced scope)

**Mitigation strategy:**
1. Start with delay-based prototype to validate concept
2. Research open-source phase vocoder implementations (Rubber Band Library, DIRAC)
3. Implement phase vocoder in isolation, test with unit tests before integration
4. Benchmark CPU usage early (may need quality vs. performance modes)
5. Consider using third-party DSP library if custom implementation too complex

---

### Overall Project Risk

**Overall complexity:** HIGH
- Phase vocoder (HIGH) + reverb (MEDIUM) + modulation (LOW) + dry/wet (LOW)
- 1 high-risk feature (shimmer) with 3 medium/low-risk features

**Highest risk component:** Phase Vocoder
- Represents ~70% of project risk
- Most algorithmically complex
- No JUCE class (custom implementation)
- Highest CPU cost and artifact risk

**Recommended approach:**
1. **Phase 1 - Validate concept:** Implement delay-based pitch shift + reverb (LOW risk, 1-2 hours)
2. **Phase 2 - Build foundation:** Implement modulation and dry/wet mixing (LOW risk, 2-3 hours)
3. **Phase 3 - Core reverb:** Integrate juce::dsp::Reverb with SIZE and DAMPING (MEDIUM risk, 2-3 hours)
4. **Phase 4 - High-risk implementation:** Replace delay-based with phase vocoder (HIGH risk, 8-12 hours)
5. **Phase 5 - Fallback testing:** If phase vocoder fails, implement granular synthesis (MEDIUM risk, 4-6 hours)
6. **Phase 6 - Polish:** Optimize CPU, tune parameters, reduce artifacts (2-4 hours)

**Total estimated time:** 19-30 hours with fallbacks, 15-22 hours if phase vocoder succeeds on first attempt

---

## Architecture Decisions

### Pitch Shifting Algorithm Choice

**Decision:** Use phase vocoder (FFT-based) for shimmer pitch shifting

**Rationale:**
- Industry standard approach (Strymon BigSky, Valhalla Shimmer, Eventide)
- Highest quality pitch shifting with minimal artifacts
- JUCE has FFT support (`juce::dsp::FFT`) reducing implementation complexity
- Phase vocoder is well-documented in DSP literature

**Alternatives considered:**
1. **Granular synthesis:**
   - Why rejected: Lower quality (graininess artifacts), professional plugins don't use this approach
   - When to reconsider: If phase vocoder CPU cost proves too high OR implementation too complex

2. **Delay-based pitch shift:**
   - Why rejected: Lowest quality (only works for small shifts, obvious artifacts), not professional-grade
   - When to reconsider: For initial prototype only (not production)

3. **Third-party library (Rubber Band Library):**
   - Why rejected: Adds external dependency, licensing complexity, doesn't use JUCE ecosystem
   - When to reconsider: If custom phase vocoder implementation fails or takes too long

**Tradeoffs accepted:**
- **Higher CPU usage:** Phase vocoder uses ~40-60% single core vs ~20-30% for granular or ~5% for delay-based
  - Acceptable because: Shimmer reverb is inherently CPU-intensive, target is studio use (not real-time performance)
- **Higher implementation complexity:** Phase vocoder is algorithmically complex vs simple granular or delay
  - Acceptable because: Research phase validated feasibility, fallback options documented, quality is priority
- **Latency:** FFT size of 2048 samples = ~46ms latency @ 44.1kHz
  - Acceptable because: Reverb already adds latency, shimmer is typically post-processing effect not real-time tracking

**When to revisit:**
- If CPU usage exceeds 80% single core (implement quality vs. performance modes)
- If implementation takes >16 hours (consider granular synthesis fallback)
- If artifacts are unacceptable despite tuning (consider Rubber Band Library)

---

### Modulation System Design

**Decision:** Built-in dual LFO modulation (not user-controlled)

**Rationale:**
- Creative brief specifies "built-in subtle modulation" as core feature
- Professional plugins (Valhalla, Strymon) include automatic modulation for lushness
- Simplifies UI (4 parameters total, not 6-7 with modulation controls)
- Always sounds good (no user error from poor modulation settings)

**Alternatives considered:**
1. **User-controlled modulation (depth + rate parameters):**
   - Why rejected: Adds UI complexity, violates "simple controls" brief goal
   - When to reconsider: If users request modulation control in feedback

2. **No modulation:**
   - Why rejected: Reverb would sound static and less lush
   - When to reconsider: Never (modulation is core to "lush" character)

**Tradeoffs accepted:**
- **Less user control:** Users cannot disable or adjust modulation
  - Acceptable because: Brief specifies automatic modulation, simplicity is goal
- **Always active CPU cost:** Modulation runs even when not desired
  - Acceptable because: CPU cost is low (~5%), lushness is always desirable

---

## Special Considerations

### Thread Safety
- All parameter reads use atomic `getRawParameterValue()->load()`
- Filter coefficient updates happen in audio thread (no allocations)
- LFO phase state is per-channel (no shared state between channels)
- JUCE dsp::Reverb and dsp::DryWetMixer handle thread safety internally

### Performance
- Shimmer FFT: ~40-60% CPU (most expensive component)
- Reverb: ~15-25% CPU (juce::dsp::Reverb is optimized)
- Modulation: ~5% CPU (simple sine LFOs + delay line)
- Total estimated: ~60-90% single core at 48kHz (CPU-intensive, as expected for shimmer reverb)

### Denormal Protection
- Use `juce::ScopedNoDenormals` in processBlock()
- All JUCE DSP components handle denormals internally
- Custom LFO uses phase wrapping to avoid denormals (phase never approaches zero)

### Sample Rate Handling
- Reverb reinitialized in prepareToPlay() with new sample rate
- Modulation delay line buffer sized for 20ms at maximum expected rate (192kHz)
- LFO phase increments recalculated: `(frequency * 2π) / sampleRate`
- FFT size fixed at 2048 samples (latency varies with sample rate: ~46ms @ 44.1kHz, ~42ms @ 48kHz)

### Latency
- Shimmer FFT: 2048 samples (~46ms @ 44.1kHz, ~42ms @ 48kHz)
- Reverb: ~5-10ms internal latency (algorithm-dependent)
- Modulation: ~5ms base delay
- Total estimated: ~55-65ms @ 44.1kHz
- Report via `getLatencySamples()` for host compensation
- DryWetMixer handles latency compensation automatically

---

## Research References

### Professional Plugins

1. **Strymon BigSky**
   - Industry reference for shimmer reverb
   - Shimmer algorithm uses pitch-shifted feedback into reverb
   - Size control ranges from small rooms to infinite spaces
   - Observed: Damping control is separate from decay time (matches our DAMPING design)

2. **Valhalla VintageVerb**
   - Lush algorithmic reverb with built-in modulation
   - Decay time ranges from 0.2s to 70s (we use 0.5s-20s)
   - Damping controls high-frequency rolloff independently
   - Noted: Subtle modulation is always active (not user-controlled)

3. **Eventide Blackhole**
   - Infinite reverb with gravity control (normal/inverse decay)
   - Size control affects decay length
   - Feedback control extends decay bounds
   - Observed: Large parameter ranges enable creative extremes (matches our 0.5s-20s range)

### JUCE Documentation

- **juce::dsp::Reverb**: Built-in reverb based on FreeVerb algorithm
  - Parameters: roomSize (0-1.0), damping (0-1.0), width (0-1.0), wetLevel, dryLevel, freezeMode
  - FreeVerb tunings provide smooth, musical reverb character
- **juce::dsp::FFT**: Fast Fourier Transform for phase vocoder
  - Supports power-of-2 sizes (we use 2048)
  - Provides forward and inverse transforms for STFT processing
- **juce::dsp::DelayLine**: Variable delay with multiple interpolation types
  - Lagrange3rd recommended for pitch modulation (smooth, low artifacts)
- **juce::dsp::DryWetMixer**: Handles latency-compensated dry/wet mixing
  - Automatically compensates for processing latency (shimmer FFT)
  - Supports linear and balanced mixing rules

### Technical Resources

- **Stanford CCRMA paper:** "Shimmer Audio Effect - A Harmonic Reverberator" (Jingjiez, 2018)
  - Phase vocoder implementation for shimmer reverb
  - Feedback delay network (FDN) reverberator integration
- **Phase Vocoder Tutorial** (CMU)
  - STFT-based pitch shifting techniques
  - Phase unwrapping and adjustment methods
- **DAFX (Digital Audio Effects)** - Reverb chapter
  - Algorithm understanding for reverb design
- **FreeVerb algorithm** - Open-source reference
  - Understanding juce::dsp::Reverb parameter behavior

---

## Notes

- Chose Lagrange3rd interpolation over Linear for smoother pitch modulation (reduces zipper noise)
- FFT size 2048 is tradeoff: larger = better quality but higher latency, smaller = lower latency but more artifacts
- Decided against oversampling for reverb (FreeVerb already band-limits, CPU cost not justified)
- SHIMMER parameter at 0% bypasses FFT processing entirely (CPU optimization for traditional reverb use case)
- Modulation depth ±3ms is subtle enough to avoid obvious pitch wobble but strong enough for lushness
- SIZE parameter uses non-linear mapping to roomSize (0.1-1.0 range instead of 0.0-1.0) to avoid zero-size room artifacts
