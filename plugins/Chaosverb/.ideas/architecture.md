# DSP Architecture: Chaosverb

**CRITICAL CONTRACT:** This specification is immutable during Stages 1-4 implementation. Stage 1 Planning cannot proceed without this file. Stage 3 (DSP) implements this exact architecture.

**Generated by:** Stage 0 Research (research-planning-agent)
**Date:** 2026-02-27
**Referenced by:** Stage 1 (Planning), Stage 3 (DSP Implementation)
**Purpose:** DSP specification defining processing components, signal flow, and JUCE module usage

---

## Core Components

### Pre-Delay Line
- **JUCE Class:** `juce::dsp::DelayLine<float, juce::dsp::DelayLineInterpolationTypes::None>`
- **Purpose:** Simple fixed-length delay before FDN input for reverb onset control
- **Parameters Affected:** preDelay
- **Configuration:**
  - Range: 0 to 250ms
  - Buffer size: ceil(0.250 * sampleRate) samples
  - No interpolation needed (non-modulated fixed delay)
  - Initialized at prepareToPlay with sampleRate

### FDN Core Engine (Custom - Dual Instance)
- **JUCE Class:** Custom implementation — no JUCE class covers FDN with impossible topology
- **Purpose:** Feedback Delay Network with 8 delay lines, configurable feedback matrix, and per-band independent decay. Two instances (FDN-A and FDN-B) run in parallel to support the mutation crossfade system.
- **Parameters Affected:** topology, decay, density, spectralTilt, resonance, modRate, modDepth
- **Configuration:**
  - **8 delay lines** with mutually-prime lengths distributed exponentially (e.g., 1447, 1621, 1873, 2143, 2311, 2677, 2963, 3191 samples at 48kHz — co-prime numbers prevent comb filter resonances)
  - **Hadamard 8x8 feedback matrix** as baseline (O(N log N) fast Hadamard transform for efficiency)
  - **topology parameter** morphs between matrix configurations by blending feedback coefficients — affects cross-coupling coefficients from physically impossible topological states
  - **decay parameter** maps to global feedback gain scalar: `feedbackGain = exp(-6.91 / (decayTime * sampleRate))` per delay line (T60 formula)
  - **density parameter** controls allpass diffuser chain length before FDN input (0 = 1 allpass, 100 = 4 allpass stages)
  - Two instances (FDN-A, FDN-B) instantiated at construction; only one active during normal operation

### Allpass Diffuser Chain (inside FDN Engine)
- **JUCE Class:** Custom implementation — `juce::dsp::DelayLine<float>` for each allpass stage
- **Purpose:** Pre-diffusion network that controls echo density (density parameter). Classic Schroeder allpass arrangement.
- **Parameters Affected:** density
- **Configuration:**
  - 4 allpass stages in series, each with fixed delay lengths (prime numbers: 347, 557, 743, 1013 samples)
  - Allpass coefficient: 0.7 (fixed — standard diffuser value)
  - density (0-100%) maps to how many stages are active (0% = 1 stage, 100% = 4 stages)
  - Alternative interpretation: density scales allpass coefficient from 0.5 to 0.9

### Spectral Tilt Filter Bank (inside FDN Engine)
- **JUCE Class:** `juce::dsp::ProcessorDuplicator<juce::dsp::IIR::Filter<float>, juce::dsp::IIR::Coefficients<float>>` — two instances (low shelf, high shelf)
- **Purpose:** Per-band independent feedback gain modifiers. High shelf and low shelf filters applied individually in the FDN feedback path to create frequency-dependent decay. spectralTilt at +100 makes highs decay slower than lows — physically impossible.
- **Parameters Affected:** spectralTilt
- **Configuration:**
  - **Low-shelf feedback modifier:** Scales feedback coefficient for frequencies below 800Hz
  - **High-shelf feedback modifier:** Scales feedback coefficient for frequencies above 800Hz
  - spectralTilt = 0: both shelves unity (neutral decay)
  - spectralTilt = +100: high-shelf scalar > 1.0 (highs persist longer) + low-shelf scalar < 1.0 (lows decay faster) — impossible
  - spectralTilt = -100: low-shelf scalar > 1.0 (lows persist longer) + high-shelf scalar < 1.0 — physical analog
  - Implementation: Per-band feedback gain baked into per-delay-line allpass/LP filters in feedback path
  - Stability: feedback scalars hard-clipped at max 0.9999 per band to prevent runaway

### Resonance Injector (inside FDN Engine)
- **JUCE Class:** Custom — narrow bandpass IIR filters (`juce::dsp::IIR::Coefficients<float>::makeBandPass()`)
- **Purpose:** Injects narrow resonant feedback peaks inside the reverb tail, creating sustained pitched content
- **Parameters Affected:** resonance
- **Configuration:**
  - 3 narrow bandpass filters at musically-related frequencies (330Hz, 880Hz, 2200Hz — approximate harmonic series)
  - Q = 50 (very narrow — resonant peaks)
  - Feedback gain through each bandpass filter scales with resonance parameter (0% = bypassed, 100% = maximum)
  - Hard stability limiter: resonance feedback gain clipped at 0.999 × (1 / Q) to prevent runaway oscillation
  - Applied in FDN feedback path, after main feedback matrix

### LFO Modulation Engine (inside FDN Engine)
- **JUCE Class:** Custom — manual phase accumulation (sine LFO per delay line)
- **Purpose:** Modulates delay line lengths independently per delay line to create pitch warping in the reverb tail
- **Parameters Affected:** modRate, modDepth
- **Configuration:**
  - 8 independent LFOs (one per delay line) with slightly different frequencies to avoid modal coherence
  - Frequency spread: modRate ± 15% stagger (e.g., if modRate=1Hz, LFOs run at 0.85, 0.88, 0.92, 0.96, 1.0, 1.04, 1.08, 1.12 Hz)
  - Phase offset: Each LFO starts at a different phase (i * π/4 for 8 LFOs)
  - Waveform: Sine
  - modDepth (0-100%) maps to delay modulation depth: 0% = 0 samples, 100% = ±8 samples (roughly ±0.2ms at 48kHz)
  - Interpolation: Lagrange3rd required for smooth pitch modulation without clicks
  - Phase increment per sample: `(freqHz / sampleRate) * 2π`

### Non-Linear Saturation (inside FDN Feedback Path)
- **JUCE Class:** Custom — soft-clip waveshaper (tanh)
- **Purpose:** Non-linear saturation in the FDN feedback path. Creates harmonic content that grows inside the reverb tail. Driven by topology parameter (topology determines base saturation character; resonance drives saturation depth).
- **Parameters Affected:** topology (indirectly — topology controls feedback matrix which drives saturation input level)
- **Configuration:**
  - Transfer function: `output = tanh(gain * input)`
  - Gain: 1.0 (clean) to 3.0 (heavily saturated), driven by topology value at high settings
  - Applied per delay line output before feedback matrix multiplication
  - Prevents runaway by bounding output to [-1, +1]
  - No oversampling needed (FDN already band-limits content)

### Pre-Delay Line (Output Stage)
- **JUCE Class:** Already covered above (single pre-delay line before FDN input)

### Stereo Width Processor
- **JUCE Class:** Custom — Mid-Side matrix (no dedicated JUCE class)
- **Purpose:** Stereo spread control beyond normal stereo (0-200%). Implements M/S matrix to scale side channel independently.
- **Parameters Affected:** width
- **Configuration:**
  - Encoding: `mid = (L + R) * 0.5; side = (L - R) * 0.5`
  - Decoding: `outL = mid + side * widthGain; outR = mid - side * widthGain`
  - width = 0%: widthGain = 0 (mono wet)
  - width = 100%: widthGain = 1.0 (normal stereo)
  - width = 200%: widthGain = 2.0 (exaggerated side)
  - Level compensation: Apply `* 0.5` during encode to prevent clipping at >100%
  - Applied to wet signal only (not dry path)

### Wet Signal Crossfader (Mutation System)
- **JUCE Class:** Custom — linear ramp crossfade gain pair
- **Purpose:** During mutation, crossfades wet output from FDN-A to FDN-B over crossfadeSpeed ms. Equal-power crossfade to avoid -3dB notch (wet signals are decorrelated).
- **Parameters Affected:** crossfadeSpeed (indirectly — duration of crossfade)
- **Configuration:**
  - Gain ramp from FDN-A: starts 1.0, ramps to 0.0 over crossfadeSpeed samples
  - Gain ramp from FDN-B: starts 0.0, ramps to 1.0 over crossfadeSpeed samples
  - Equal-power law: `gainA = cos(phase * π/2); gainB = sin(phase * π/2)` where phase ramps 0→1
  - crossfadeSpeed = 0ms: instant switch (no crossfade)
  - crossfadeSpeed = 500ms: 24000 samples at 48kHz, smoothest transition
  - After crossfade complete: FDN-B becomes active, FDN-A goes idle (does not process audio)

### Mutation Timer
- **JUCE Class:** `juce::Timer` (message thread) — NOT `HighResolutionTimer` (see gotchas)
- **Purpose:** Fires the global randomization event on the user-defined interval
- **Parameters Affected:** mutationInterval, crossfadeSpeed
- **Configuration:**
  - Interval: 5s to 600s (user-defined via mutationInterval parameter)
  - On timer callback: generate new random values for all unlocked parameters → apply to FDN-B → start crossfade
  - Timer precision: juce::Timer has ~10-20ms precision, sufficient for mutation intervals in seconds range
  - Timer runs on message thread; parameter writes use APVTS on message thread (thread-safe by design)
  - Countdown display: UI polls `getRemainingTime()` method on message thread

### Dry/Wet Mixer
- **JUCE Class:** `juce::dsp::DryWetMixer<float>`
- **Purpose:** Final dry/wet blend between unprocessed input and FDN wet output
- **Parameters Affected:** mix
- **Configuration:**
  - mix (0-100%) maps to wet proportion (0.0-1.0)
  - `pushDrySamples()` called before FDN processing
  - `setWetMixProportion()` for blend
  - `mixDrySamples()` after full wet chain processing
  - Latency compensation: DryWetMixer handles dry path delay compensation for pre-delay

---

## Processing Chain

```
Input (Stereo)
  |
  +--- [Dry/Wet Mixer: capture dry] <-- mix
  |
  V
Pre-Delay Line (0-250ms) <-- preDelay
  |
  V
Allpass Diffuser Chain (1-4 stages) <-- density
  |
  +---> FDN-A (Active Engine)                FDN-B (Idle / Mutating Engine)
  |     |                                    |
  |     +-- Delay Lines (8, mutually prime)  +-- Delay Lines (8, mutually prime)
  |     |   LFO modulation per line          |   LFO modulation per line
  |     |   <-- modRate, modDepth            |   <-- modRate, modDepth (new random values)
  |     |                                    |
  |     +-- Hadamard Matrix Multiply         +-- Hadamard Matrix Multiply
  |     |   <-- topology (morph matrix)      |   <-- topology (new random value)
  |     |                                    |
  |     +-- Per-Band Spectral Decay          +-- Per-Band Spectral Decay
  |     |   [Low shelf + High shelf]         |   [Low shelf + High shelf]
  |     |   <-- decay, spectralTilt          |   <-- decay, spectralTilt (new)
  |     |                                    |
  |     +-- Resonance Injection              +-- Resonance Injection
  |     |   (3x narrow BP filters)           |   (3x narrow BP filters)
  |     |   <-- resonance                    |   <-- resonance (new)
  |     |                                    |
  |     +-- Non-Linear Saturation (tanh)     +-- Non-Linear Saturation (tanh)
  |     |   <-- topology (drive level)       |   <-- topology (drive level)
  |     |                                    |
  |     +-- Feedback loop (back to top)      +-- Feedback loop (back to top)
  |     |                                    |
  |     V                                    V
  |    FDN-A Wet Output               FDN-B Wet Output
  |         \                              /
  |          Equal-Power Crossfader <-- mutationInterval, crossfadeSpeed
  |              |  (A->B on mutation)
  |              V
  |         Blended Wet Output
  |              |
  |              V
  |         Stereo Width Processor <-- width
  |         (M/S matrix, 0-200%)
  |              |
  V              V
Dry/Wet Mixer (blend dry + wet) <-- mix
  |
  V
Output (Stereo)

=== Mutation Event (fires every mutationInterval seconds) ===
1. Mutation Timer fires (juce::Timer, message thread)
2. Generate new values for all UNLOCKED parameters (uniform random)
3. Apply new values to FDN-B
4. Start equal-power crossfade: gain(A) 1->0, gain(B) 0->1 over crossfadeSpeed ms
5. After crossfade: FDN-A goes idle. FDN-B becomes FDN-A for next mutation.
6. Reset timer countdown.
```

**Routing notes:**
- FDN-A and FDN-B always consume audio input (pre-delay → diffuser output is fed to both)
- During idle: inactive FDN still processes internally but its wet output gets zero gain (no CPU saving — both instances run continuously for click-free transitions)
- Width and mix applied to blended wet output only
- Dry signal is captured before pre-delay (no modulation on dry path)

---

## System Architecture

### Mutation System

**What it does:** On a user-defined interval, generates new random parameter values for all unlocked parameters simultaneously and crossfades between two FDN instances.

**Implementation:**
- `juce::Timer` subclass (`MutationTimer`) owned by `PluginProcessor`
- `mutationInterval` parameter controls `startTimer(intervalMs)`
- Timer callback on message thread calls `PluginProcessor::triggerMutation()`
- `triggerMutation()` reads lock states for all parameters, generates uniform random values for unlocked ones via `juce::Random`, writes new values to APVTS
- Crossfade engine starts ramp on next `processBlock()` call via atomic flag `mutationPending`

**Lock System:**
- 10 boolean parameters (one per lockable parameter) — see parameter spec
- Lock states read on message thread during timer callback
- Lock state UI binding: `getToggleState()` (not `getSliderState()`) — see juce8-critical-patterns.md Pattern 19

**Countdown Display:**
- `getRemainingTimeMs()` method returns `(nextMutationTimeMs - currentTimeMs)`
- UI polls via timer at 100ms intervals for countdown display
- Countdown resets after each mutation event

**Thread safety:**
- All parameter writes happen on message thread via APVTS (thread-safe by design)
- Audio thread reads parameter values via `getRawParameterValue()->load()` (atomic)
- Crossfade start signaled via `std::atomic<bool> mutationPending` flag

### State Persistence

**What state is saved:**
- All APVTS parameters: 12 floats + 10 booleans (lock states) — automatic via APVTS
- No custom non-parameter state required

**Serialization format:**
- APVTS parameters: XML via ValueTree (automatic)
- Lock states are APVTS boolean parameters — automatically persisted with presets

**JUCE classes:**
- `juce::AudioProcessorValueTreeState` — all state (parameters + lock booleans)

**Restore behavior:**
- All parameters restore from saved state
- Timer resets to full interval on load (does not resume mid-interval)

---

## Parameter Mapping

| Parameter ID | Type | Range | DSP Component | Usage |
|---|---|---|---|---|
| topology | Float | 0-100 | FDN Core Engine | Morphs feedback matrix cross-coupling coefficients; drives non-linear saturation gain indirectly |
| decay | Float | 0.1-60s | FDN Core Engine (Spectral Decay) | Global feedback gain scalar via T60 formula: `g = exp(-6.91 / (T * Fs))` |
| preDelay | Float | 0-250ms | Pre-Delay Line | Fixed delay before FDN input, size = ceil(0.250 * sampleRate) |
| density | Float | 0-100% | Allpass Diffuser Chain | Controls number of active allpass stages (1-4) |
| spectralTilt | Float | -100 to +100 | Spectral Tilt Filter Bank | Per-band feedback gain modifier; positive = highs persist longer (impossible) |
| resonance | Float | 0-100% | Resonance Injector | Gain through 3 narrow bandpass feedback loops in FDN |
| modRate | Float | 0.01-10Hz | LFO Modulation Engine | Frequency of LFOs modulating delay line lengths; ±15% stagger across 8 LFOs |
| modDepth | Float | 0-100% | LFO Modulation Engine | Amplitude of delay line length modulation (0-±8 samples) |
| width | Float | 0-200% | Stereo Width Processor | Side channel gain scalar: 0=mono, 1.0=normal, 2.0=double-wide |
| mix | Float | 0-100% | Dry/Wet Mixer | Wet proportion for final dry/wet blend |
| mutationInterval | Float | 5-600s | Mutation Timer | Timer interval, passed to juce::Timer::startTimer() |
| crossfadeSpeed | Float | 0-500ms | Wet Signal Crossfader | Duration of equal-power crossfade between FDN-A and FDN-B |
| topologyLock | Bool | false/true | Mutation System | Excludes topology from randomization when true |
| decayLock | Bool | false/true | Mutation System | Excludes decay from randomization when true |
| preDelayLock | Bool | false/true | Mutation System | Excludes preDelay from randomization when true |
| densityLock | Bool | false/true | Mutation System | Excludes density from randomization when true |
| spectralTiltLock | Bool | false/true | Mutation System | Excludes spectralTilt from randomization when true |
| resonanceLock | Bool | false/true | Mutation System | Excludes resonance from randomization when true |
| modRateLock | Bool | false/true | Mutation System | Excludes modRate from randomization when true |
| modDepthLock | Bool | false/true | Mutation System | Excludes modDepth from randomization when true |
| widthLock | Bool | false/true | Mutation System | Excludes width from randomization when true |
| mixLock | Bool | false/true | Mutation System | Excludes mix from randomization when true |

---

## Algorithm Details

### FDN Core Engine

**Algorithm:** 8x8 Feedback Delay Network with Hadamard feedback matrix

**Mathematical formulation:**
```
For each sample:
1. x_n = input sample (after pre-delay + diffusion)
2. y[i] = delayLine[i].popSample()      // read from each delay line
3. x_sat[i] = tanh(topology_gain * y[i])  // non-linear saturation per line
4. m[i] = HadamardMatrix * x_sat[i]     // Hadamard transform (feedback mixing)
5. spectral[i] = lowShelfGain[i] * m[i] + highShelfGain[i] * m[i]  // per-band decay
6. resonant[i] = spectral[i] + resonanceFilter[i].process(spectral[i])  // add peaks
7. out[i] = spectral[i] + resonant_gain * resonant[i]
8. delayLine[i].pushSample(x_n + out[i])  // write input + feedback
9. lfoPhase[i] += lfoFreq[i] / sampleRate  // advance LFO
10. delayLen[i] = baseLen[i] + depth * sin(lfoPhase[i])  // modulate length
```

**Hadamard Transform (fast, O(N log N)):**
```
For N=8, the fast Hadamard transform uses butterfly operations:
Level 1: x[0]+=x[1]; x[1]=x[0]-2*x[1]; (repeat for pairs)
Level 2: x[0]+=x[2]; ... (repeat for groups of 4)
Level 3: x[0]+=x[4]; ... (full pass)
Scale by 1/sqrt(8) for normalization
```

**Topology morphing:**
- topology=0: Diagonal matrix (no cross-coupling, individual comb filters — thin sound)
- topology=50: Full Hadamard (maximum diffusion — dense wash)
- topology=100: "Impossible" topology — cross-coupling coefficients exceed physical bounds, some off-diagonal elements > 1.0 (only stable with saturation limiting)
- Implementation: Linear interpolation between stored matrix states (3 presets, morphed continuously)

**Delay line lengths (at 48kHz, mutually prime):**
- Line 0: 1447 samples (30.1ms)
- Line 1: 1621 samples (33.8ms)
- Line 2: 1873 samples (39.0ms)
- Line 3: 2143 samples (44.6ms)
- Line 4: 2311 samples (48.1ms)
- Line 5: 2677 samples (55.8ms)
- Line 6: 2963 samples (61.7ms)
- Line 7: 3191 samples (66.5ms)
- All are prime numbers — guarantees no common factors, prevents periodic resonances

**Feedback gain formula (T60 control):**
```
baseGain = exp(-6.91 / (decaySeconds * sampleRate))  // per-sample decay for T60
```

### Spectral Tilt — Per-Band Decay

**Algorithm:** Frequency-dependent feedback gain modifiers applied in FDN feedback path

**Implementation:**
- Two biquad shelf filters applied to the delay line outputs before feedback:
  - Low-shelf at 800Hz: gain = `1.0 - (spectralTilt / 100.0) * 0.3` (0.7 to 1.3 range)
  - High-shelf at 800Hz: gain = `1.0 + (spectralTilt / 100.0) * 0.3` (0.7 to 1.3 range)
- spectralTilt = 0: both shelves unity, neutral decay
- spectralTilt = +100: high-shelf gain = 1.3 (highs persist 30% longer per cycle), low-shelf = 0.7 (lows decay 30% faster) — physically impossible
- spectralTilt = -100: low-shelf gain = 1.3, high-shelf = 0.7 — physically plausible (high-frequency absorption)
- Hard safety limit: effective per-band feedback gain never exceeds 0.9999

### Resonance Injection

**Algorithm:** Narrow bandpass IIR filters in feedback path

**Implementation:**
- 3 bandpass filters at 330Hz, 880Hz, 2200Hz (approximate harmonic series)
- Q = 50 (very narrow — creates pitched resonant peaks)
- Each filter's output is scaled by `resonanceGain` and added back to signal in feedback path
- `resonanceGain` = resonance / 100.0 * 0.9 (max 90% to guarantee stability)
- Stability guardrail: hard clip resonanceGain below 1.0 / Q for each filter
- Filter implementation: `juce::dsp::IIR::Coefficients::makeBandPass(sampleRate, freq, Q)`

### Stereo Width Processor

**Algorithm:** M/S matrix with variable side gain

**Implementation:**
```cpp
// Encode
mid = (L + R) * 0.5f;
side = (L - R) * 0.5f;

// Scale
float widthGain = width / 100.0f;  // 0.0 to 2.0
side *= widthGain;

// Decode
outL = mid + side;
outR = mid - side;
```

**Level compensation:** The `* 0.5f` in encoding prevents full-width signals from clipping when side is boosted beyond 1.0.

### Wet Signal Crossfader

**Algorithm:** Equal-power crossfade using sine/cosine law

**Implementation:**
```cpp
// phase ramps from 0.0 to 1.0 over crossfadeSpeed samples
gainA = cos(phase * juce::MathConstants<float>::halfPi);
gainB = sin(phase * juce::MathConstants<float>::halfPi);

wetOut = gainA * fdnA.process(input) + gainB * fdnB.process(input);

phase += 1.0f / crossfadeSamples;
if (phase >= 1.0f) {
    phase = 1.0f;
    // crossfade complete — swap A/B roles
}
```

### Allpass Diffuser Chain

**Algorithm:** Series Schroeder allpass sections

**Implementation:**
```cpp
// Per allpass section (4 in series):
y[n] = -g * x[n] + x[n-D] + g * y[n-D]
// g = 0.7 (allpass coefficient), D = delay length (prime samples)
```

Each stage uses a `juce::dsp::DelayLine<float>` with the push/pop pattern.

---

## Integration Points

### Feature Dependencies

- **Pre-delay** feeds into **Allpass Diffuser Chain** which feeds both **FDN-A** and **FDN-B**: Pre-delay must complete before diffusion
- **FDN-A and FDN-B** both feed into **Wet Crossfader**: Both engines must be computed before blending
- **Wet Crossfader** output feeds **Stereo Width Processor**: Width applied after blend, not per-FDN
- **Stereo Width** feeds **Dry/Wet Mixer**: Width only on wet signal; mixer combines with dry
- **Mutation Timer** (message thread) triggers **FDN-B parameter update** + **crossfade start**: Timer must not access audio-thread state directly — uses atomic flag
- **Lock parameters** gate the **Mutation Timer randomization logic**: Lock states read on message thread during mutation callback (same thread as timer)
- **Resonance Injector** depends on **FDN delay lines**: resonance filters are inside the feedback path, not post-processing

### Parameter Interactions

- **decay + spectralTilt interaction:** High decay + extreme spectralTilt (±100) creates very long sustained bands. At decay=60s + spectralTilt=+100, the high frequency decay can approach infinite sustain in certain bands. Monitor combined effective feedback gain per band.
- **resonance + decay interaction:** High resonance at long decay creates very prominent sustained pitched peaks. Acceptable by design — this is Chaosverb's core "impossible" character.
- **topology + saturation interaction:** At high topology values, the feedback matrix produces high-amplitude signals that drive the tanh saturation harder. This is intentional — topology is the "impossibility dial."
- **modDepth + crossfadeSpeed interaction:** During crossfade, modulation is active in both FDN-A and FDN-B. The two FDNs will have different LFO phases, creating a complex blended modulation character during transition. This is a feature, not a bug.
- **mutationInterval + crossfadeSpeed interaction:** crossfadeSpeed must be less than mutationInterval to prevent overlapping crossfades. Implementation should ignore a new mutation trigger if a crossfade is still in progress.

### Processing Order Requirements

1. **Capture dry signal** (Dry/Wet Mixer pushDrySamples): FIRST — preserves unmodified input before any processing
2. **Pre-delay** (DelayLine): Before FDN — onset delay
3. **Allpass Diffuser Chain**: After pre-delay, before FDN — builds initial echo density
4. **FDN-A processing** (delay lines, Hadamard, spectral, resonance, saturation): Core reverb generation
5. **FDN-B processing** (same chain, separate state): Must run in parallel with FDN-A every block
6. **Wet Crossfader** (gainA * A + gainB * B): After both FDN outputs available
7. **Stereo Width** (M/S matrix): After crossfade, before dry/wet mix
8. **Dry/Wet Mixer** (blend): LAST — final output mix

**Why FDN-B always runs:** Both instances must process continuously (not just during crossfade) to avoid clicks. If FDN-B only starts processing at mutation time, it would start from silence, creating an audible fade-in artifact even with equal-power crossfade.

### Thread Boundaries

**Audio thread (processBlock):**
- All FDN-A and FDN-B DSP processing
- Crossfade gain ramp application
- Pre-delay, diffuser, width, and dry/wet processing
- Parameter reads via `getRawParameterValue()->load()` (atomic)
- Reads `std::atomic<bool> mutationPending` flag
- If `mutationPending` is true: retrieves pre-computed new parameter snapshot from lock-free queue, starts crossfade, clears flag

**Message thread:**
- `juce::Timer::timerCallback()`: Mutation trigger
- Reads lock states for all 10 boolean parameters
- Generates new random values for unlocked parameters using `juce::Random`
- Writes new values to APVTS (thread-safe)
- Sets `std::atomic<bool> mutationPending = true`
- UI countdown display polling

**Communication:**
- APVTS parameters: Atomic reads (audio thread) / writes (message thread) — built into JUCE APVTS
- Mutation pending signal: `std::atomic<bool> mutationPending`
- No custom background thread needed (all operations are fast enough for message thread)

---

## Implementation Risks

### FDN Custom Implementation

**Complexity:** HIGH

**Risk Level:** HIGH

**Risk factors:**
1. No `juce::dsp::FDN` class exists — full custom implementation of 8-delay-line network with Hadamard matrix
2. Delay line mutual-prime selection must be tuned carefully to avoid modal clustering
3. Stability management with impossible topologies — feedback coefficients can exceed 1.0, requires non-linear limiting to prevent explosion
4. Two parallel instances (FDN-A + FDN-B) doubles CPU and code complexity
5. Long decay times (up to 60s) require very careful feedback gain formula to avoid denormals and accumulation errors

**Alternative approaches:**
1. **Use juce::dsp::Reverb as base, extend with spectral filters:**
   - Complexity: LOW-MEDIUM
   - Quality: Lower (Freeverb-based plate sound, not true FDN)
   - Tradeoff: Faster implementation but cannot achieve true impossible topologies
   - Use if: Custom FDN proves too time-consuming
2. **4-line FDN instead of 8-line:**
   - Complexity: MEDIUM
   - Quality: Slightly less dense, fewer modal shapes
   - Tradeoff: ~50% CPU reduction, simpler implementation
   - Use if: CPU budget exceeded with 8-line FDN

**Fallback architecture:**
- Primary: 8-line FDN with full Hadamard + spectral tilt + resonance (full spec)
- Fallback 1: 4-line FDN with simplified Hadamard (4x4 matrix) — same concept, less computation
- Fallback 2: juce::dsp::Reverb with external spectral tilt filters and mutation system — reduced impossible-space character but mutation system intact

**Mitigation strategy:**
1. Reference: jatinchowdhury18/Feedback-Delay-Networks (GitHub) — open-source FDN with nonlinear elements
2. Reference: ninuxi/MAI_verb (GitHub) — professional 8x8 FDN implementation in JUCE
3. Build FDN in isolation first, test stability with extreme parameters before adding dual-instance system
4. Add hard stability limiter (clip output to ±1) as safety net during development

### Spectral Tilt (Physically Impossible Decay)

**Complexity:** MEDIUM

**Risk Level:** MEDIUM

**Risk factors:**
1. Per-band feedback gain > 1.0 creates instability risk — high-band feedback could runaway
2. Biquad shelf filters in feedback path interact with overall FDN stability
3. At extreme spectralTilt (+100) + long decay (60s): effective high-band feedback could exceed 0.9999 threshold requiring hard limiting that causes distortion

**Alternative approaches:**
1. **Post-FDN spectral shelf EQ instead of in-path feedback modification:**
   - Complexity: LOW
   - Result: Spectral shaping of output, but NOT true per-band independent decay
   - Tradeoff: Sonically similar for mild tilt, fails at extreme values (highs don't actually persist longer)

**Fallback architecture:**
- Primary: Per-band feedback gain modifiers inside FDN path
- Fallback: Post-FDN EQ with asymmetric filter (approximates the effect at mild settings)
- Hard stability limit on all effective per-band feedback: never exceed 0.9998

### Dual FDN Crossfade System

**Complexity:** HIGH

**Risk Level:** HIGH

**Risk factors:**
1. Both FDN instances must run continuously — doubles CPU at all times, not just during crossfade
2. Synchronizing crossfade state between audio thread and message thread without locks
3. Handling FDN-B parameter updates mid-crossfade (if user triggers mutation again before previous completes)
4. Click prevention at instant crossfade (crossfadeSpeed = 0ms)

**Alternative approaches:**
1. **Single FDN with parameter morphing instead of dual instance:**
   - Complexity: MEDIUM
   - Limitation: Parameter changes while reverb tail is ringing cause audible artifacts (comb filtering)
   - Tradeoff: Lower CPU, but mutation causes artifacts instead of seamless crossfade
   - Use if: CPU budget makes dual FDN infeasible

**Fallback architecture:**
- Primary: Dual FDN with equal-power crossfade
- Fallback: Single FDN with slow parameter smoothing (crossfadeSpeed controls smoothing rate) — audible mutation artifacts accepted as creative feature

### Resonance Injection (Stability Risk)

**Complexity:** MEDIUM

**Risk Level:** MEDIUM

**Risk factors:**
1. Narrow bandpass filters (Q=50) in feedback path are close to oscillation by design
2. At resonance=100%: filters approach sustained oscillation, which is the feature but requires hard stability limit
3. If feedback gain + resonance gain combined exceeds 1.0 per frequency, runaway oscillation
4. Mutation could jump resonance from 0 to 100 instantaneously — requires parameter smoothing before applying to FDN

**Fallback architecture:**
- Primary: 3 bandpass filters in FDN feedback path with hard gain limiting
- Fallback: 1 bandpass filter (simpler, less resonance character)
- Hard limit: resonance contribution to feedback path capped at 0.5 (very conservative) to guarantee stability

### Mutation Timer System

**Complexity:** MEDIUM

**Risk Level:** LOW-MEDIUM

**Risk factors:**
1. juce::Timer precision is only ~10-20ms — acceptable for 5-600s intervals, but timer may drift slightly
2. Lock state reading on message thread during timer callback must not block audio thread
3. If user changes mutationInterval while timer is running, must restart timer cleanly

**Alternative approaches:**
- `juce::HighResolutionTimer`: More precise but uses a dedicated thread — overkill for second-scale intervals and adds thread safety complexity. NOT recommended (see juce8-critical-patterns.md on thread safety)

**Fallback architecture:**
- Timer falls back gracefully: if message thread is busy, timer fires late — acceptable for aesthetic feature
- Mutation can be manually triggered via UI button (bypass timer entirely)

### Overall Project Risk

**Overall complexity:** HIGH
- Custom 8-line FDN (HIGH) + dual-instance crossfade system (HIGH) + spectral tilt (MEDIUM) + resonance injection (MEDIUM) + mutation timer (MEDIUM)

**Highest risk component:** Dual FDN custom implementation
- Represents ~70% of project risk
- No JUCE class available; must be implemented from scratch
- Two parallel instances doubles all risks

**Recommended approach:**
1. **Phase 1:** Build single FDN with basic Hadamard matrix — verify basic reverb behavior
2. **Phase 2:** Add spectral tilt, resonance injection, LFO modulation, saturation — verify stability
3. **Phase 3:** Add second FDN instance and crossfade system — verify seamless mutation
4. **Phase 4:** Add mutation timer, lock system — verify parameter randomization workflow
5. **Phase 5:** Verify extreme parameters don't cause instability (topology=100, decay=60, spectralTilt=±100, resonance=100)

---

## Architecture Decisions

### Custom FDN Over juce::dsp::Reverb

**Decision:** Implement custom 8-line FDN rather than using juce::dsp::Reverb (Freeverb-based)

**Rationale:**
- juce::dsp::Reverb uses Freeverb (Schroeder-Moorer plate reverb) with a fixed 8-comb + 4-allpass topology — no way to morph feedback matrix or achieve impossible spectral decay
- Custom FDN is required to implement the Hadamard matrix morphing (topology parameter) and per-band feedback gain control (spectralTilt parameter)
- Freeverb has no concept of frequency-dependent decay independent of overall damping

**Alternatives considered:**
1. juce::dsp::Reverb extended with post-processing: Rejected — cannot achieve true per-band independent feedback control
2. RAVE/convolutional approach: Rejected — file-based, not real-time reconfigurable, can't achieve mutation

**Tradeoffs accepted:**
- Higher implementation complexity
- Higher CPU usage than juce::dsp::Reverb
- Risk of stability issues with extreme feedback configurations

### Dual FDN Instances for Crossfade

**Decision:** Run two complete FDN instances simultaneously (FDN-A and FDN-B), always processing, never sleeping

**Rationale:**
- Only way to achieve click-free crossfade between completely different reverb states
- FDN-B must be "warmed up" (reverberating) before becoming audible — if it starts from silence during crossfade, the equal-power blend sounds like a volume swell, not a crossfade
- Industry approach: Valhalla, Eventide, and other professional reverbs use parallel instance crossfade for preset changes

**Alternatives considered:**
1. Single FDN with parameter smoothing: Rejected — parameter changes while tail is active cause comb-filtering artifacts. Acceptable for subtle changes, unacceptable for full randomization.
2. FDN-B starts only when mutation fires: Rejected — introduces swell artifact as FDN-B builds up during crossfade

**Tradeoffs accepted:**
- Double CPU cost at all times (both FDN instances always running)
- Increased memory usage (double delay line buffers)
- Both instances must receive audio input continuously (no way to "warm up" silently)

**CPU estimate:** 8-line custom FDN at 48kHz: ~15-25% per instance. Dual instance: ~30-50% total. Plus allpass diffusers, spectral filters, resonance: ~40-60% total estimated.

### juce::Timer for Mutation Timing

**Decision:** Use `juce::Timer` (message thread) rather than `juce::HighResolutionTimer` for mutation intervals

**Rationale:**
- Mutation intervals are measured in seconds (5-600s minimum). A ±20ms precision error is irrelevant at this timescale.
- `juce::Timer` is lightweight and integrates cleanly with the message thread where APVTS writes happen
- `juce::HighResolutionTimer` runs on a dedicated thread, requiring lock-free communication for parameter writes — adds complexity with no benefit

**Tradeoffs accepted:**
- Timer precision: ±10-20ms per callback. Acceptable for second-scale intervals.
- Message thread blocking could delay timer: acceptable — mutation is an aesthetic feature, not a precision transport event

### Equal-Power Crossfade for Wet Signal Blend

**Decision:** Equal-power (sin/cos) crossfade for FDN-A → FDN-B blend

**Rationale:**
- FDN wet outputs are decorrelated (different delay line lengths, different state) — for decorrelated signals, equal-power crossfade avoids the -3dB notch at midpoint that linear crossfade would produce
- Industry standard for reverb wet signal blending
- JUCE forum confirmed: "reverbs and that sort of thing are better served with an equal power fade"

**Alternatives considered:**
1. Linear crossfade: Rejected — creates -3dB volume dip at midpoint for decorrelated signals
2. DryWetMixer for crossfade: Cannot use for two FDN instances blending (DryWetMixer is for dry/wet, not wet/wet)

---

## Special Considerations

### Thread Safety

- All parameter reads in processBlock use `getRawParameterValue()->load()` (atomic)
- Mutation timer fires on message thread; APVTS writes are thread-safe by design
- Crossfade start signal: `std::atomic<bool> mutationPending` — set by message thread, cleared by audio thread
- No mutex or lock in audio thread path — zero blocking
- Lock state parameters (booleans) read on message thread during mutation callback, not in audio thread

### Performance

- **FDN-A + FDN-B (8-line each):** ~30-50% CPU estimated (most expensive component)
- **Allpass Diffuser Chain (4 stages):** ~5% CPU
- **Spectral Tilt (biquad shelf filters):** ~5% CPU
- **Resonance Injection (3 bandpass filters):** ~3% CPU
- **LFO Modulation (8 sine LFOs):** ~2% CPU (lightweight phase accumulation)
- **Stereo Width (M/S matrix):** ~1% CPU
- **Dry/Wet Mixer:** ~1% CPU
- **Total estimated:** ~47-67% single core at 48kHz with default parameters
- **Optimization opportunity:** Fast Hadamard Transform (butterfly algorithm) rather than naive matrix multiply — reduces Hadamard from O(N²) to O(N log N)
- **Optimization note:** LFO update rate can be reduced to every 4-8 samples (subsample modulation) without audible quality loss

### Denormal Protection

- `juce::ScopedNoDenormals` at top of `processBlock()` — protects all processing
- FDN feedback loops are most vulnerable to denormals at long decay times (very small numbers circulating)
- DC offset injection: add tiny DC offset (1e-9f) to delay line inputs to prevent denormals in inactive feedback paths
- All JUCE DSP components handle denormals internally

### Sample Rate Handling

- FDN delay line lengths in samples — must be recalculated in `prepareToPlay()` based on current sample rate
- LFO phase increment: `(freqHz / sampleRate) * 2π` — recalculated on sample rate change
- Biquad filter coefficients: recalculated in `prepareToPlay()` via `IIR::Coefficients::makeHighShelf(sampleRate, ...)`
- Pre-delay buffer size: `ceil(0.250 * sampleRate)` — must accommodate maximum sample rate (192kHz)
- All state (delay line buffers) cleared and reinitialised in `prepareToPlay()` for both FDN-A and FDN-B

### Latency

- Pre-delay contributes 0-250ms reported latency (user-controlled)
- FDN itself: no additional algorithmic latency (causal processing)
- Report via `getLatencySamples()`: `static_cast<int>(preDelaySeconds * sampleRate)`
- DryWetMixer latency compensation: `DryWetMixer.prepare()` handles dry path compensation for pre-delay

### Stability at Extreme Parameters

- **decay=60s + spectralTilt=+100:** Highest stability risk. Effective per-band feedback gain for highs could approach 0.9999. Hard limit enforced.
- **resonance=100% + decay=60s:** Bandpass filters near oscillation. Hard gain limit prevents runaway.
- **topology=100:** Off-diagonal feedback matrix elements exceed 1.0 — only safe because tanh saturation bounds all delay line outputs to ±1. Without saturation, this topology would be unstable.
- **Safety guarantee:** Regardless of parameter combination, `tanh()` bounds all feedback values to (-1, +1). This is the ultimate stability guarantee for the impossible topologies.

---

## Research References

### Professional Plugins

1. **Valhalla Supermassive** (Valhalla DSP, Sean Costello)
   - FDN-based "untamed" reverb algorithms — intentionally impossible/unphysical
   - Each delay line up to 2 seconds; feedforward + feedback combinations
   - Philosophy: Algorithms that "couldn't be tamed" into physical realism
   - Key insight: Named algorithms after celestial objects because they don't fit room/hall categories
   - Source: valhalladsp.com/2020/05/06/the-philosophy-of-valhallasupermassive/

2. **Eventide Blackhole**
   - Origins in DSP4000 hardware; "breaks the rules by allowing virtual spaces that could never exist"
   - Harmonic tail character from nonlinear feedback processing
   - Internal modulation built into reverb structure (not post-processing)
   - Gravity control: allows negative values for inverse/reverse reverb character
   - Key insight: Nonlinear processing embedded in feedback path creates harmonic tail signature

3. **AriesVerb** (Ariescode)
   - Highly flexible FDN with non-linear saturation in feedback path for chaotic limit cycles
   - Modulation depth and speed with FM-like effects at extreme values
   - Key insight: "Chaotic limit cycles" from saturation in feedback path — directly relevant to Chaosverb concept

4. **Strymon BigSky — Bloom mode**
   - Slowly building reverb bloom feeding into reverb tank with feedback parameter
   - Physics-defying shapes (Gate, Ramp, Reverse, Swoosh) built into reverb engine
   - Randomization built into Chorale mode (pitch/timbre randomization)
   - Key insight: Non-linear tail envelopes (swell, bloom) are an established plugin feature

5. **MAI_verb** (ninuxi/MAI_verb on GitHub)
   - Open-source professional 8x8 FDN algorithmic reverb in JUCE
   - Direct reference for implementation approach (same N=8, JUCE-based)
   - Key insight: 8x8 FDN is implementable in JUCE without external DSP libraries

### JUCE Documentation

- **juce::dsp::DelayLine:** Used for pre-delay, allpass stages, and FDN delay lines. Supports Lagrange3rd interpolation for modulated delay lines.
  - Template: `juce::dsp::DelayLine<float, juce::dsp::DelayLineInterpolationTypes::Lagrange3rd>`
  - Module: `juce_dsp`

- **juce::dsp::IIR::Filter + Coefficients:** Used for allpass, shelf, and bandpass filters throughout FDN
  - `IIR::Coefficients::makeLowShelf()`, `makeHighShelf()`, `makeBandPass()`
  - Module: `juce_dsp`

- **juce::dsp::DryWetMixer:** Final dry/wet blend with latency compensation
  - Module: `juce_dsp`

- **juce::Timer:** Mutation interval timer (message thread)
  - Module: `juce_events`
  - Precision: ~10-20ms (sufficient for second-scale mutation intervals)

- **juce::Random:** For generating uniform random values during mutation
  - Module: `juce_core`
  - Method: `juce::Random::global()` or local instance

- **juce::dsp::ProcessSpec:** Required for prepareToPlay across all juce::dsp components
  - Pattern from juce8-critical-patterns.md Pattern 17

### Technical Resources

- CCRMA (Julius O. Smith): "FDN Reverberation" — Physical Audio Signal Processing textbook, https://ccrma.stanford.edu/~jos/pasp/FDN_Reverberation.html — foundational FDN theory
- jatinchowdhury18/Feedback-Delay-Networks (GitHub): Time-varying, nonlinear FDN research implementation with JUCE plugins — direct code reference
- Jean-Marc Jot: "Digital Delay Networks For Designing Artificial Reverberators" — per-band independent decay methodology (graphical EQ approach for T60 per band)
- KVR Audio DSP Forum: "Feedback Delay Network Reverb" thread — practical implementation discussion, Hadamard matrix, delay line tuning
- JUCE Forum: "Equal Power Crossfading of Reverb" — confirmed equal-power crossfade is correct for decorrelated wet signals

### JUCE Modules Required

- `juce_audio_processors` — AudioProcessor, APVTS, parameters
- `juce_dsp` — DelayLine, IIR filters, DryWetMixer, ProcessSpec, AudioBlock
- `juce_events` — Timer (mutation system)
- `juce_core` — Random (mutation randomization)
- `juce_gui_extra` — WebBrowserComponent (UI)
- `juce_gui_basics` — Component, Window management

---

## Notes

- The dual FDN approach (FDN-A always active, FDN-B receiving mutations) means both instances are always running. This is intentionally wasteful for CPU but necessary for click-free mutation.
- Topology parameter (0-100) is the most complex — it controls three things simultaneously: feedback matrix cross-coupling, tanh saturation drive, and an undefined "impossible" quality that must be tuned during DSP phase.
- The `tanh()` saturation on each delay line is the architectural safety net that makes impossible topologies stable. Without it, topology > 50 would be unstable.
- resonance parameter requires special smoothing before applying to FDN — jumping from 0 to 100% instantly could cause clicks. Smooth over 50ms minimum.
- spectralTilt at +100 will produce a sustained high-frequency wash that gets brighter over time (physically impossible). This is the defining "impossible" feature.
- At crossfadeSpeed = 0ms, implement as a hard switch with a 1-sample linear fade to prevent clicks.
- Lock boolean parameters should use `juce::AudioParameterBool` in APVTS, not floats. Use `getToggleState()` in JavaScript, not `getSliderState()` — see juce8-critical-patterns.md Pattern 19.
