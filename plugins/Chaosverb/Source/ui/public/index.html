<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Chaosverb</title>
  <script type="module" src="js/juce/index.js"></script>
  <style>
    /* ─── WEBVIEW FOUNDATION ─── */
    html,
    body {
      height: 100%;
      margin: 0;
      padding: 0;
    }

    *,
    *::before,
    *::after {
      box-sizing: border-box;
    }

    body {
      user-select: none;
      -webkit-user-select: none;
      cursor: default;
      overflow: hidden;
      background: #141414;
      color: #e0e0e0;
      font-family: 'Inter', 'Helvetica Neue', Arial, sans-serif;
      font-size: 11px;
    }

    /* ─── PLUGIN SHELL ─── */
    .plugin-shell {
      width: 900px;
      height: 380px;
      background: #141414;
      position: relative;
      display: flex;
      flex-direction: column;
      transform-origin: top left;
    }

    /* ─── HEADER ─── */
    .header {
      width: 100%;
      height: 54px;
      background: #0e0e0e;
      border-bottom: 1px solid #2a2a2a;
      display: flex;
      align-items: center;
      padding: 0 20px;
      flex-shrink: 0;
      position: relative;
    }

    .header-left {
      display: flex;
      flex-direction: column;
      justify-content: center;
      gap: 2px;
    }

    .plugin-title {
      font-size: 16px;
      font-weight: 700;
      letter-spacing: 0.25em;
      text-transform: uppercase;
      color: #ffffff;
      line-height: 1;
    }

    .plugin-tagline {
      font-size: 9px;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: #777777;
      line-height: 1;
    }

    .header-center {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      pointer-events: none;
    }

    .header-center>* {
      pointer-events: auto;
    }

    .mutate-btn {
      background: transparent;
      border: 1px solid #333333;
      color: #888888;
      font-family: inherit;
      font-size: 9px;
      font-weight: 600;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      padding: 6px 16px;
      border-radius: 20px;
      cursor: pointer;
      transition: all 0.15s ease;
      position: relative;
      overflow: hidden;
    }

    .mutate-btn:hover {
      border-color: #00d4ff;
      color: #00d4ff;
      box-shadow: 0 0 10px rgba(0, 212, 255, 0.2);
    }

    .mutate-btn:active {
      background: rgba(0, 212, 255, 0.08);
    }

    .mutate-btn.firing {
      border-color: #ffffff;
      color: #ffffff;
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.4);
    }

    .header-right {
      margin-left: auto;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 1px;
      position: relative;
      z-index: 15;
    }

    .countdown-label {
      font-size: 7px;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      color: #444444;
      line-height: 1;
    }

    .countdown {
      font-family: 'JetBrains Mono', 'Courier New', monospace;
      font-size: 28px;
      font-weight: 700;
      letter-spacing: 0.05em;
      color: #00d4ff;
      line-height: 1;
      transition: color 0.3s ease;
      text-shadow: 0 0 12px rgba(0, 212, 255, 0.6);
      width: 100px;
      text-align: right;
    }

    .countdown.stopped {
      color: #ff3333;
      text-shadow: 0 0 12px rgba(255, 51, 51, 0.4);
    }

    .timer-toggle {
      background: transparent;
      border: 1px solid #333333;
      color: #666666;
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 0.08em;
      border-radius: 3px;
      cursor: pointer;
      transition: all 0.15s ease;
      position: relative;
      z-index: 20;
      width: 66px;
      padding: 8px 0;
      font-family: inherit;
      text-align: center;
      line-height: 1;
      user-select: none;
      -webkit-user-select: none;
      display: block;
    }

    .timer-toggle::after {
      content: '';
      position: absolute;
      inset: 0;
      z-index: 1;
    }

    .timer-toggle:hover {
      border-color: #888888;
      color: #aaaaaa;
    }

    .timer-toggle.is-stopped {
      border-color: #bbbbbb;
      color: #dddddd;
      box-shadow: 0 0 8px rgba(255, 255, 255, 0.15);
      background: rgba(255, 255, 255, 0.05);
    }

    .timer-toggle.is-stopped:hover {
      border-color: #ffffff;
      color: #ffffff;
      box-shadow: 0 0 12px rgba(255, 255, 255, 0.3);
      background: rgba(255, 255, 255, 0.1);
    }

    .countdown.warning {
      color: #ff3333;
      text-shadow: 0 0 12px rgba(255, 51, 51, 0.7);
      animation: pulse-warning 0.8s ease-in-out infinite alternate;
    }

    @keyframes pulse-warning {
      from {
        opacity: 1;
      }

      to {
        opacity: 0.65;
      }
    }

    /* ─── BODY ─── */
    .body {
      flex: 1;
      display: flex;
      flex-direction: row;
      padding: 0;
      position: relative;
    }

    /* ─── SECTION COLUMNS ─── */
    .section-col {
      display: flex;
      flex-direction: column;
      padding: 10px 0 10px 0;
      position: relative;
    }

    .section-label {
      font-size: 9px;
      font-weight: 700;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: #444444;
      padding: 6px 0 8px 0;
      text-align: center;
      width: 100%;
    }

    /* ─── SECTIONS ─── */
    .section-space {
      width: 194px;
      padding: 10px 20px 10px 20px;
      border-right: 1px solid #222222;
    }

    .section-spectral {
      width: 96px;
      padding: 10px 14px 10px 14px;
      border-right: 1px solid #222222;
    }

    .section-tone {
      width: 96px;
      padding: 10px 14px 10px 14px;
      border-right: 1px solid #222222;
    }

    .section-motion {
      width: 96px;
      padding: 10px 14px 10px 14px;
      border-right: 1px solid #222222;
    }

    .section-flutter {
      width: 86px;
      padding: 10px 14px 10px 14px;
      border-right: 1px solid #222222;
    }

    .section-mutation-output {
      flex: 1;
      padding: 10px 14px 10px 14px;
    }

    /* ─── KNOB GRID ─── */
    .knob-grid-2x2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px 14px;
      margin-top: 2px;
    }

    .knob-col {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 2px;
    }

    .output-knob-row {
      display: flex;
      flex-direction: row;
      gap: 10px;
      justify-content: center;
      margin-top: 2px;
    }

    /* ─── KNOB COMPONENT ─── */
    .knob-wrap {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 5px;
      cursor: ns-resize;
    }

    .knob-body {
      width: 56px;
      height: 56px;
      position: relative;
      flex-shrink: 0;
    }

    .knob-body canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 56px;
      height: 56px;
    }

    .knob-face {
      position: absolute;
      top: 8px;
      left: 8px;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: radial-gradient(circle at 40% 35%, #3a3a3a 0%, #252525 50%, #1a1a1a 100%);
      border: 1px solid #444444;
      box-shadow:
        0 2px 4px rgba(0, 0, 0, 0.5),
        inset 0 1px 1px rgba(255, 255, 255, 0.06);
      z-index: 2;
    }

    .knob-indicator {
      position: absolute;
      top: 3px;
      left: 50%;
      width: 5px;
      height: 5px;
      margin-left: -2.5px;
      border-radius: 50%;
      transform-origin: 50% 17px;
      z-index: 3;
      transition: background 0.2s;
    }

    .knob-label {
      font-size: 8px;
      font-weight: 600;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: #666666;
      text-align: center;
      line-height: 1;
    }

    .knob-value {
      font-size: 8px;
      letter-spacing: 0.04em;
      color: #888888;
      text-align: center;
      line-height: 1;
      font-variant-numeric: tabular-nums;
    }

    .knob-body.locked .knob-face {
      border-color: transparent;
    }

    /* ─── HORIZONTAL SLIDER ─── */
    .hslider-wrap {
      display: flex;
      flex-direction: column;
      gap: 5px;
      width: 100%;
    }

    .hslider-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
    }

    .hslider-label {
      font-size: 8px;
      font-weight: 600;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: #666666;
    }

    .hslider-value {
      font-size: 8px;
      color: #888888;
      font-variant-numeric: tabular-nums;
    }

    .hslider-track {
      width: 100%;
      height: 28px;
      background: #0e0e0e;
      border: 1px solid #2a2a2a;
      border-radius: 4px;
      position: relative;
      cursor: ew-resize;
      overflow: hidden;
    }

    .hslider-fill {
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      background: linear-gradient(90deg, #2a2a2a, #3a3a3a);
      border-radius: 4px 0 0 4px;
    }

    .hslider-thumb {
      position: absolute;
      top: 50%;
      width: 2px;
      height: 16px;
      background: #888888;
      border-radius: 1px;
      transform: translateY(-50%) translateX(-1px);
      transition: background 0.2s;
    }

    .hslider-track:hover .hslider-thumb {
      background: #aaaaaa;
    }

    /* ─── MUTATION FLASH OVERLAY ─── */
    .mutation-flash {
      position: absolute;
      inset: 0;
      background: rgba(255, 255, 255, 0.12);
      pointer-events: none;
      opacity: 0;
      z-index: 100;
    }

    .mutation-flash.active {
      animation: flash-burst 0.4s ease-out forwards;
    }

    @keyframes flash-burst {
      0% {
        opacity: 0.15;
      }

      20% {
        opacity: 0.08;
      }

      100% {
        opacity: 0;
      }
    }

    /* ─── FLUTTER TOGGLE BUTTON ─── */
    .flutter-toggle {
      background: transparent;
      border: 1px solid #333333;
      color: #666666;
      font-family: inherit;
      font-size: 9px;
      font-weight: 600;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      padding: 5px 10px;
      border-radius: 3px;
      cursor: pointer;
      transition: all 0.15s ease;
      line-height: 1;
      width: 100%;
      text-align: center;
    }

    .flutter-toggle:hover {
      border-color: #888888;
      color: #aaaaaa;
    }

    .flutter-toggle.active {
      border-color: #e67e22;
      color: #e67e22;
      box-shadow: 0 0 8px rgba(230, 126, 34, 0.3);
    }

    .flutter-toggle.active:hover {
      border-color: #f39c12;
      color: #f39c12;
    }

    /* ─── BYPASS BUTTON ─── */
    .bypass-btn {
      background: transparent;
      border: 1px solid #333333;
      color: #666666;
      font-family: inherit;
      font-size: 9px;
      font-weight: 600;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      padding: 5px 14px;
      border-radius: 3px;
      cursor: pointer;
      transition: all 0.15s ease;
      line-height: 1;
      text-align: center;
    }

    .bypass-btn:hover {
      border-color: #888888;
      color: #aaaaaa;
    }

    .bypass-btn.active {
      border-color: #ff3333;
      color: #ff3333;
      box-shadow: 0 0 8px rgba(255, 51, 51, 0.3);
    }

    .bypass-btn.active:hover {
      border-color: #ff5555;
      color: #ff5555;
    }

    /* ─── SECTION LABEL COLORS ─── */
    .section-space .section-label {
      color: #2a8fa0;
    }

    .section-spectral .section-label {
      color: #2a8fa0;
    }

    .section-tone .section-label {
      color: #2a9a6a;
    }

    .section-motion .section-label {
      color: #8a50a8;
    }

    .section-flutter .section-label {
      color: #c07828;
    }

    .section-mutation-output .section-label {
      color: #777777;
    }
  </style>
</head>

<body>
  <div class="plugin-shell" id="pluginShell">

    <!-- MUTATION FLASH OVERLAY -->
    <div class="mutation-flash" id="mutationFlash"></div>

    <!-- HEADER -->
    <div class="header">
      <div class="header-left">
        <div class="plugin-title">Chaosverb</div>
        <div class="plugin-tagline">impossible space reverb</div>
      </div>

      <div class="header-center">
        <button class="mutate-btn" id="mutateBtn">Mutate Now</button>
      </div>

      <div class="header-right">
        <div class="countdown-label">Next Mutation</div>
        <div
          style="display: flex; align-items: center; justify-content: flex-end; gap: 8px; width: 174px; min-width: 174px; flex-shrink: 0;">
          <button class="timer-toggle" id="timerToggle">STOP</button>
          <div class="countdown" id="countdown">00:30</div>
        </div>
      </div>
    </div>

    <!-- BODY -->
    <div class="body">

      <!-- SPACE SECTION -->
      <div class="section-col section-space">
        <div class="section-label">Space</div>
        <div class="knob-grid-2x2">
          <div id="knob_topology"></div>
          <div id="knob_decay"></div>
          <div id="knob_preDelay"></div>
          <div id="knob_density"></div>
        </div>
      </div>

      <!-- SPECTRAL SECTION -->
      <div class="section-col section-spectral">
        <div class="section-label">Spectral</div>
        <div class="knob-col">
          <div id="knob_spectralTilt"></div>
          <div id="knob_resonance"></div>
        </div>
      </div>

      <!-- TONE SECTION -->
      <div class="section-col section-tone">
        <div class="section-label">Tone</div>
        <div class="knob-col">
          <div id="knob_lowCut"></div>
          <div id="knob_tilt"></div>
          <div id="knob_highCut"></div>
        </div>
      </div>

      <!-- MOTION SECTION -->
      <div class="section-col section-motion">
        <div class="section-label">Motion</div>
        <div class="knob-col">
          <div id="knob_modRate"></div>
          <div id="knob_modDepth"></div>
        </div>
      </div>

      <!-- FLUTTER SECTION -->
      <div class="section-col section-flutter">
        <div class="section-label">Flutter</div>
        <div class="knob-col">
          <div id="knob_wowFlutterAmount"></div>
          <button class="flutter-toggle" id="flutterToggle">OFF</button>
        </div>
        <div class="section-label" style="margin-top:8px;">Duck</div>
        <div class="knob-col">
          <div id="knob_duckingAmount"></div>
        </div>
      </div>

      <!-- MUTATION + OUTPUT COMBINED SECTION -->
      <div class="section-col section-mutation-output">
        <div class="section-label">Mutation</div>
        <div style="display:flex; flex-direction:column; gap:14px; margin-top:4px;">
          <div id="hslider_mutationInterval"></div>
          <div id="hslider_crossfadeSpeed"></div>
        </div>
        <div class="section-label" style="margin-top:12px;">Output</div>
        <div class="output-knob-row">
          <div id="knob_width"></div>
          <div style="display:flex; flex-direction:column; align-items:center; gap:6px;">
            <div id="knob_mix"></div>
            <button class="bypass-btn" id="bypassBtn">Bypass</button>
          </div>
          <div id="knob_outputLevel"></div>
        </div>
      </div>

    </div>
  </div>

  <script type="module">
    "use strict";

    import { getSliderState, getToggleState, getNativeFunction } from './js/juce/index.js';

    // ─── NATIVE FUNCTIONS (JS → C++) ─────────────────────────────────────────────
    const mutateNowFn = getNativeFunction("mutateNow");
    const toggleMutationTimerFn = getNativeFunction("toggleMutationTimer");
    const getMutationStateFn = getNativeFunction("getMutationState");

    // ─── DISABLE CONTEXT MENU ─────────────────────────────────────────────────────
    document.addEventListener("contextmenu", (e) => {
      e.preventDefault();
      return false;
    });

    // ─── JUCE PARAMETER STATES ────────────────────────────────────────────────────
    // Float parameters — getSliderState (Pattern 21 + Pattern 19)
    const topologyState = getSliderState("topology");
    const decayState = getSliderState("decay");
    const preDelayState = getSliderState("preDelay");
    const densityState = getSliderState("density");
    const spectralTiltState = getSliderState("spectralTilt");
    const resonanceState = getSliderState("resonance");
    const modRateState = getSliderState("modRate");
    const modDepthState = getSliderState("modDepth");
    const mutationIntervalState = getSliderState("mutationInterval");
    const crossfadeSpeedState = getSliderState("crossfadeSpeed");
    const widthState = getSliderState("width");
    const mixState = getSliderState("mix");
    const lowCutState = getSliderState("lowCut");
    const highCutState = getSliderState("highCut");
    const tiltState = getSliderState("tilt");
    const wowFlutterAmountState = getSliderState("wowFlutterAmount");
    const outputLevelState = getSliderState("outputLevel");
    const duckingAmountState = getSliderState("duckingAmount");

    // Bool parameters — getToggleState (Pattern 19)
    const topologyLockState = getToggleState("topologyLock");
    const decayLockState = getToggleState("decayLock");
    const preDelayLockState = getToggleState("preDelayLock");
    const densityLockState = getToggleState("densityLock");
    const spectralTiltLockState = getToggleState("spectralTiltLock");
    const resonanceLockState = getToggleState("resonanceLock");
    const modRateLockState = getToggleState("modRateLock");
    const modDepthLockState = getToggleState("modDepthLock");
    const widthLockState = getToggleState("widthLock");
    const mixLockState = getToggleState("mixLock");
    const lowCutLockState = getToggleState("lowCutLock");
    const highCutLockState = getToggleState("highCutLock");
    const tiltLockState = getToggleState("tiltLock");
    const wowFlutterAmountLockState = getToggleState("wowFlutterAmountLock");
    const wowFlutterEnabledState = getToggleState("wowFlutterEnabled");
    const outputLevelLockState = getToggleState("outputLevelLock");
    const duckingAmountLockState = getToggleState("duckingAmountLock");
    const bypassState = getToggleState("bypass");

    // ─── PARAMETER META TABLE ─────────────────────────────────────────────────────
    // Used by knob/slider builders for formatting and rendering
    const KNOB_PARAMS = {
      topology: { label: "Topology", unit: "", min: 0, max: 100, section: "space", state: topologyState, lockState: topologyLockState, defaultNorm: 0.5 },
      decay: { label: "Decay", unit: "s", min: 0.1, max: 60, section: "space", state: decayState, lockState: decayLockState, defaultNorm: 0.384 },
      preDelay: { label: "Pre-Delay", unit: "bipolar-pd", min: -500, max: 500, section: "space", state: preDelayState, lockState: preDelayLockState, defaultNorm: 0.5 },
      density: { label: "Density", unit: "%", min: 0, max: 100, section: "space", state: densityState, lockState: densityLockState, defaultNorm: 0.6 },
      spectralTilt: { label: "Sp.Tilt", unit: "", min: -100, max: 100, section: "spectral", state: spectralTiltState, lockState: spectralTiltLockState, defaultNorm: 0.5 },
      resonance: { label: "Resonance", unit: "%", min: 0, max: 100, section: "spectral", state: resonanceState, lockState: resonanceLockState, defaultNorm: 0.0 },
      modRate: { label: "Mod Rate", unit: "Hz", min: 0.01, max: 10, section: "motion", state: modRateState, lockState: modRateLockState, defaultNorm: 0.348 },
      modDepth: { label: "Mod Depth", unit: "%", min: 0, max: 100, section: "motion", state: modDepthState, lockState: modDepthLockState, defaultNorm: 0.4 },
      width: { label: "Width", unit: "%", min: 0, max: 400, section: "output", state: widthState, lockState: widthLockState, defaultNorm: 0.5 },
      mix: { label: "Mix", unit: "%", min: 0, max: 100, section: "output", state: mixState, lockState: mixLockState, defaultNorm: 0.5 },
      lowCut: { label: "Low Cut", unit: "Hz", min: 20, max: 500, section: "tone", state: lowCutState, lockState: lowCutLockState, defaultNorm: 0.483 },
      highCut: { label: "High Cut", unit: "Hz", min: 1000, max: 20000, section: "tone", state: highCutState, lockState: highCutLockState, defaultNorm: 0.770 },
      tilt: { label: "Tilt", unit: "", min: -100, max: 100, section: "tone", state: tiltState, lockState: tiltLockState, defaultNorm: 0.45 },
      wowFlutterAmount: { label: "Amount", unit: "%", min: 0, max: 100, section: "flutter", state: wowFlutterAmountState, lockState: wowFlutterAmountLockState, defaultNorm: 0.0 },
      outputLevel: { label: "Level", unit: "dB", min: -12, max: 12, section: "output", state: outputLevelState, lockState: outputLevelLockState, defaultNorm: 0.5 },
      duckingAmount: { label: "Ducking", unit: "%", min: 0, max: 100, section: "duck", state: duckingAmountState, lockState: duckingAmountLockState, defaultNorm: 0.0 },
    };

    const HSLIDER_PARAMS = {
      mutationInterval: {
        label: "Interval", min: -1000, max: 1000, bipolar: true, accentColor: "#00d4ff", state: mutationIntervalState, formatFn: (n) => {
          // Bipolar: norm 0..0.5 = left side (BPM sync), 0.5 = center, 0.5..1 = right side (ms)
          const val = -1000 + n * 2000; // map norm 0..1 to -1000..+1000
          if (val >= 0) return Math.round(val) + "ms";
          // Left side: snap values map to note divisions
          const t = -val / 1000; // 0..1
          if (t >= 0.975) return "4 BAR";
          if (t >= 0.95) return "3 BAR";
          if (t >= 0.925) return "2 BAR";
          if (t >= 0.9) return "1/1";
          if (t >= 0.8) return "1/2";
          if (t >= 0.7) return "1/4d";
          if (t >= 0.6) return "1/4";
          if (t >= 0.5) return "1/8d";
          if (t >= 0.4) return "1/8";
          if (t >= 0.3) return "1/16d";
          if (t >= 0.2) return "1/16";
          if (t >= 0.1) return "1/32";
          return "0ms";
        }
      },
      crossfadeSpeed: {
        label: "Crossfade", min: 0, max: 500, accentColor: "#888888", state: crossfadeSpeedState, formatFn: (n) => {
          return Math.round(n * 500) + "ms";
        }
      },
    };

    const SECTION_COLORS = {
      space: "#00d4ff",
      spectral: "#00d4ff",
      tone: "#2ecc71",
      motion: "#9b59b6",
      flutter: "#e67e22",
      duck: "#e67e22",
      output: "#888888",
      "mutation-output": "#888888",
    };

    // ─── TIMER STATE ─────────────────────────────────────────────────────────────
    let timerRunning = false;

    // ─── KNOB RENDERING ──────────────────────────────────────────────────────────
    const KNOB_SIZE = 56;
    const ARC_RADIUS = 24;
    const ARC_START = 135;   // degrees
    const ARC_END = 405;   // 135 + 270

    function degToRad(d) { return d * Math.PI / 180; }

    function drawKnob(canvas, normValue, accentColor, locked) {
      const ctx = canvas.getContext("2d");
      const cx = KNOB_SIZE / 2;
      const cy = KNOB_SIZE / 2;
      const r = ARC_RADIUS;

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (locked) {
        // Bold radial glow — bright core fading outward
        const glowGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
        glowGrad.addColorStop(0, accentColor + "70");
        glowGrad.addColorStop(0.4, accentColor + "40");
        glowGrad.addColorStop(0.7, accentColor + "20");
        glowGrad.addColorStop(1, accentColor + "08");
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI * 2);
        ctx.fillStyle = glowGrad;
        ctx.fill();

        // Bold ring at arc track
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI * 2);
        ctx.strokeStyle = accentColor;
        ctx.lineWidth = 2.5;
        ctx.stroke();
      } else {
        const startRad = degToRad(ARC_START);
        const endRad = degToRad(ARC_END);

        // Arc track (dim)
        ctx.beginPath();
        ctx.arc(cx, cy, r, startRad, endRad);
        ctx.strokeStyle = "#2a2a2a";
        ctx.lineWidth = 3;
        ctx.lineCap = "round";
        ctx.stroke();

        // Arc fill
        if (normValue > 0.001) {
          const fillEnd = degToRad(ARC_START + normValue * 270);

          // Glow
          ctx.beginPath();
          ctx.arc(cx, cy, r, startRad, fillEnd);
          ctx.strokeStyle = accentColor + "50";
          ctx.lineWidth = 6;
          ctx.lineCap = "round";
          ctx.stroke();

          // Sharp arc
          ctx.beginPath();
          ctx.arc(cx, cy, r, startRad, fillEnd);
          ctx.strokeStyle = accentColor;
          ctx.lineWidth = 3;
          ctx.lineCap = "round";
          ctx.stroke();
        }
      }

      // Value dot on arc track
      const dotAngle = degToRad(ARC_START + normValue * 270);
      const dotX = cx + r * Math.cos(dotAngle);
      const dotY = cy + r * Math.sin(dotAngle);
      ctx.beginPath();
      ctx.arc(dotX, dotY, 3.5, 0, Math.PI * 2);
      ctx.fillStyle = locked ? accentColor + "80" : accentColor;
      ctx.fill();
    }

    // ─── KNOB VALUE FORMATTING ────────────────────────────────────────────────────
    function formatKnobValue(paramId, normValue) {
      const p = KNOB_PARAMS[paramId];
      const v = p.min + normValue * (p.max - p.min);

      // Bipolar pre-delay: left=BPM sync divisions, right=free time in ms
      if (p.unit === "bipolar-pd") {
        if (v >= 0) return Math.round(v) + "ms";
        const t = -v / 500; // 0..1
        if (t > 0.9) return "1/1";
        else if (t > 0.8) return "1/2";
        else if (t > 0.7) return "1/4d";
        else if (t > 0.6) return "1/4";
        else if (t > 0.5) return "1/8d";
        else if (t > 0.4) return "1/8";
        else if (t > 0.3) return "1/16d";
        else if (t > 0.2) return "1/16";
        else if (t > 0.1) return "1/32";
        return "0ms";
      }

      if (p.unit === "s") return v.toFixed(1) + "s";
      if (p.unit === "ms") return Math.round(v) + "ms";
      if (p.unit === "Hz") {
        if (v >= 1000) return (v / 1000).toFixed(1) + "kHz";
        if (v < 1) return v.toFixed(2) + "Hz";
        return Math.round(v) + "Hz";
      }
      if (p.unit === "%") return Math.round(v) + "%";
      if (p.unit === "dB") {
        const rounded = Math.round(v * 10) / 10;
        if (rounded > 0) return "+" + rounded.toFixed(1) + "dB";
        return rounded.toFixed(1) + "dB";
      }
      // For bipolar (spectralTilt) or unitless
      const rounded = Math.round(v);
      return rounded > 0 ? "+" + rounded : String(rounded);
    }

    // ─── KNOB COMPONENT FACTORY ───────────────────────────────────────────────────
    function buildKnob(containerId, paramId) {
      const p = KNOB_PARAMS[paramId];
      const accentColor = SECTION_COLORS[p.section] || "#888888";
      const container = document.getElementById(containerId);
      if (!container) return;

      const wrap = document.createElement("div");
      wrap.className = "knob-wrap";
      wrap.setAttribute("data-param", paramId);

      const bodyEl = document.createElement("div");
      bodyEl.className = "knob-body";
      bodyEl.id = "knobBody_" + paramId;

      const canvas = document.createElement("canvas");
      canvas.width = KNOB_SIZE;
      canvas.height = KNOB_SIZE;
      canvas.style.cssText = "position:absolute;top:0;left:0;width:56px;height:56px;";
      bodyEl.appendChild(canvas);

      const face = document.createElement("div");
      face.className = "knob-face";

      const indicator = document.createElement("div");
      indicator.className = "knob-indicator";
      indicator.id = "knobInd_" + paramId;
      indicator.style.background = accentColor;
      face.appendChild(indicator);
      bodyEl.appendChild(face);

      const labelEl = document.createElement("div");
      labelEl.className = "knob-label";
      labelEl.textContent = p.label;

      const valueEl = document.createElement("div");
      valueEl.className = "knob-value";
      valueEl.id = "knobVal_" + paramId;

      wrap.appendChild(bodyEl);
      wrap.appendChild(labelEl);
      wrap.appendChild(valueEl);
      container.appendChild(wrap);

      // Refresh from JUCE state
      function refresh() {
        const norm = p.state.getNormalisedValue();
        const locked = p.lockState ? p.lockState.getValue() : false;
        const canvas = bodyEl.querySelector("canvas");

        drawKnob(canvas, norm, accentColor, locked);

        const rot = -135 + norm * 270;
        indicator.style.transform = `rotate(${rot}deg)`;
        indicator.style.opacity = locked ? "0.5" : "1";

        if (locked) bodyEl.classList.add("locked");
        else bodyEl.classList.remove("locked");

        valueEl.textContent = formatKnobValue(paramId, norm);
        valueEl.style.color = locked ? accentColor + "cc" : "#666666";
      }

      // JUCE value change listeners (Pattern 15: no callback params)
      p.state.valueChangedEvent.addListener(() => refresh());
      if (p.lockState) p.lockState.valueChangedEvent.addListener(() => refresh());

      // Initial render
      refresh();

      // Drag interaction (Pattern 16: relative drag)
      let lastY = null;
      let currentNorm = () => p.state.getNormalisedValue();

      wrap.addEventListener("mousedown", (e) => {
        // Cmd+click or Ctrl+click: reset to default
        if (e.metaKey || e.ctrlKey) {
          e.preventDefault();
          e.stopPropagation();
          p.state.setNormalisedValue(p.defaultNorm);
          return;
        }

        e.preventDefault();
        lastY = e.clientY;
        document.body.style.cursor = "ns-resize";

        const onMove = (me) => {
          const deltaY = lastY - me.clientY;
          lastY = me.clientY;
          const sensitivity = 0.005; // normalized per pixel
          const newNorm = Math.max(0, Math.min(1, currentNorm() + deltaY * sensitivity));
          p.state.setNormalisedValue(newNorm);
        };

        const onUp = () => {
          document.body.style.cursor = "default";
          lastY = null;
          document.removeEventListener("mousemove", onMove);
          document.removeEventListener("mouseup", onUp);
        };

        document.addEventListener("mousemove", onMove);
        document.addEventListener("mouseup", onUp);
      });

      // Double-click: reset to default value
      wrap.addEventListener("dblclick", (e) => {
        e.preventDefault();
        p.state.setNormalisedValue(p.defaultNorm);
      });

      // Right-click: toggle lock (only for lockable params)
      if (p.lockState) {
        wrap.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          p.lockState.setValue(!p.lockState.getValue());
          return false;
        });
      }
    }

    // ─── HORIZONTAL SLIDER FACTORY ────────────────────────────────────────────────
    function buildHSlider(containerId, paramId) {
      const p = HSLIDER_PARAMS[paramId];
      const container = document.getElementById(containerId);
      if (!container) return;

      const wrap = document.createElement("div");
      wrap.className = "hslider-wrap";

      const header = document.createElement("div");
      header.className = "hslider-header";

      const labelEl = document.createElement("span");
      labelEl.className = "hslider-label";
      labelEl.textContent = p.label;

      const valEl = document.createElement("span");
      valEl.className = "hslider-value";
      valEl.id = "hsliderVal_" + paramId;

      header.appendChild(labelEl);
      header.appendChild(valEl);

      const track = document.createElement("div");
      track.className = "hslider-track";
      track.id = "hsliderTrack_" + paramId;

      const fill = document.createElement("div");
      fill.className = "hslider-fill";
      fill.id = "hsliderFill_" + paramId;

      const thumb = document.createElement("div");
      thumb.className = "hslider-thumb";
      thumb.id = "hsliderThumb_" + paramId;

      track.appendChild(fill);
      track.appendChild(thumb);

      // Bipolar center line indicator
      if (p.bipolar) {
        const centerLine = document.createElement("div");
        centerLine.style.cssText = "position:absolute;left:50%;top:4px;width:1px;height:20px;background:#555555;transform:translateX(-0.5px);pointer-events:none;z-index:1;";
        track.appendChild(centerLine);
      }

      wrap.appendChild(header);
      wrap.appendChild(track);
      container.appendChild(wrap);

      function refresh() {
        const norm = p.state.getNormalisedValue();
        const trackW = track.offsetWidth || 140;

        if (p.bipolar) {
          // Bipolar: fill from center (norm=0.5) outward in either direction
          const center = 0.5;
          if (norm >= center) {
            // Right of center: fill from 50% rightward
            fill.style.left = (center * 100) + "%";
            fill.style.width = ((norm - center) * 100) + "%";
            fill.style.borderRadius = "0 4px 4px 0";
          } else {
            // Left of center: fill from norm leftward to 50%
            fill.style.left = (norm * 100) + "%";
            fill.style.width = ((center - norm) * 100) + "%";
            fill.style.borderRadius = "4px 0 0 4px";
          }
        } else {
          fill.style.left = "0";
          fill.style.width = (norm * 100) + "%";
        }

        // Dynamic brightness: fill glows toward accent color when farther from center
        const dist = p.bipolar ? Math.abs(norm - 0.5) * 2 : norm;
        const accent = p.accentColor || "#00d4ff";
        const ar = parseInt(accent.slice(1, 3), 16);
        const ag = parseInt(accent.slice(3, 5), 16);
        const ab = parseInt(accent.slice(5, 7), 16);
        const br = Math.round(58 + dist * (ar - 58));
        const bg = Math.round(58 + dist * (ag - 58));
        const bb = Math.round(58 + dist * (ab - 58));
        fill.style.background = `linear-gradient(90deg, #2a2a2a, rgb(${br},${bg},${bb}))`;

        thumb.style.left = (norm * trackW) + "px";
        valEl.textContent = p.formatFn(norm);
      }

      p.state.valueChangedEvent.addListener(() => refresh());
      refresh();

      // Drag
      let startX = null;
      let startNorm = null;

      track.addEventListener("mousedown", (e) => {
        e.preventDefault();
        startX = e.clientX;
        startNorm = p.state.getNormalisedValue();
        document.body.style.cursor = "ew-resize";

        const onMove = (me) => {
          const trackW = track.offsetWidth || 140;
          const delta = (me.clientX - startX) / trackW;
          const newNorm = Math.max(0, Math.min(1, startNorm + delta));
          p.state.setNormalisedValue(newNorm);
        };

        const onUp = () => {
          document.body.style.cursor = "default";
          document.removeEventListener("mousemove", onMove);
          document.removeEventListener("mouseup", onUp);
        };

        document.addEventListener("mousemove", onMove);
        document.addEventListener("mouseup", onUp);
      });
    }

    // ─── COUNTDOWN DISPLAY (synced from C++ via native function) ─────────────────
    const countdownEl = document.getElementById("countdown");
    const timerToggleBtn = document.getElementById("timerToggle");

    let lastKnownRunning = null;

    function updateCountdownDisplay(remainingMs, running) {
      timerRunning = running;

      // Only update button DOM when state actually changes
      // (avoids destroying/recreating text node every 66ms poll cycle,
      // which breaks click events in JUCE WebView)
      if (lastKnownRunning !== running) {
        lastKnownRunning = running;
        if (running) {
          timerToggleBtn.textContent = "STOP";
          timerToggleBtn.classList.remove("is-stopped");
        } else {
          timerToggleBtn.textContent = "START";
          timerToggleBtn.classList.add("is-stopped");
        }
      }

      // Format time — use sub-second display for fast intervals
      let timeStr;
      if (remainingMs < 1000) {
        // Sub-second: show milliseconds
        const ms = Math.max(0, Math.ceil(remainingMs));
        timeStr = ms + "ms";
      } else {
        const secs = Math.max(0, Math.ceil(remainingMs / 1000));
        const m = Math.floor(secs / 60);
        const s = secs % 60;
        timeStr = String(m).padStart(2, "0") + ":" + String(s).padStart(2, "0");
      }

      if (!running || remainingMs < 0) {
        countdownEl.classList.add("stopped");
        countdownEl.classList.remove("warning");
        // Keep the frozen time (or default 00:00) when stopped, don't change text
        if (remainingMs > 0) {
          countdownEl.textContent = timeStr;
        }
        return;
      }

      countdownEl.classList.remove("stopped");
      countdownEl.textContent = timeStr;

      if (secs <= 5) {
        countdownEl.classList.add("warning");
      } else {
        countdownEl.classList.remove("warning");
      }
    }

    // Poll C++ mutation state at ~15Hz (enough for smooth countdown)
    function pollMutationState() {
      getMutationStateFn().then(state => {
        if (state && typeof state === "object") {
          updateCountdownDisplay(state.remainingMs, state.running);
        }
      }).catch(() => { });
      setTimeout(pollMutationState, 66);
    }

    // ─── MUTATE NOW BUTTON ────────────────────────────────────────────────────────
    document.getElementById("mutateBtn").addEventListener("click", () => {
      const btn = document.getElementById("mutateBtn");
      btn.classList.add("firing");
      setTimeout(() => btn.classList.remove("firing"), 350);

      // Flash overlay
      const flash = document.getElementById("mutationFlash");
      flash.classList.remove("active");
      void flash.offsetWidth;
      flash.classList.add("active");

      // Call C++ triggerMutation() via native function
      mutateNowFn().catch(() => { });
    });

    // ─── TIMER STOP/START BUTTON ─────────────────────────────────────────────────
    // Use mousedown instead of click — more reliable in JUCE WebView
    // (click requires mousedown+mouseup on same target, which can fail
    // if the DOM is being updated between the two events)
    document.getElementById("timerToggle").addEventListener("mousedown", (e) => {
      e.preventDefault();
      lastKnownRunning = null; // force UI refresh on next poll
      toggleMutationTimerFn().catch(() => { });
    });

    // ─── FLUTTER TOGGLE BUTTON ──────────────────────────────────────────────────
    const flutterToggleBtn = document.getElementById("flutterToggle");

    function updateFlutterToggle() {
      const enabled = wowFlutterEnabledState.getValue();
      flutterToggleBtn.textContent = enabled ? "ON" : "OFF";
      if (enabled) flutterToggleBtn.classList.add("active");
      else flutterToggleBtn.classList.remove("active");
    }

    wowFlutterEnabledState.valueChangedEvent.addListener(updateFlutterToggle);
    updateFlutterToggle();

    flutterToggleBtn.addEventListener("click", () => {
      wowFlutterEnabledState.setValue(!wowFlutterEnabledState.getValue());
    });

    // ─── BYPASS BUTTON ──────────────────────────────────────────────────────────
    const bypassBtn = document.getElementById("bypassBtn");

    function updateBypassBtn() {
      const bypassed = bypassState.getValue();
      if (bypassed) bypassBtn.classList.add("active");
      else bypassBtn.classList.remove("active");
    }

    bypassState.valueChangedEvent.addListener(updateBypassBtn);
    updateBypassBtn();

    bypassBtn.addEventListener("click", () => {
      bypassState.setValue(!bypassState.getValue());
    });

    // ─── RESIZABLE GUI (CSS transform scaling) ──────────────────────────────────
    const DESIGN_W = 900;
    const DESIGN_H = 380;

    function updateScale() {
      const scaleX = window.innerWidth / DESIGN_W;
      const scaleY = window.innerHeight / DESIGN_H;
      const scale = Math.min(scaleX, scaleY);
      const shell = document.getElementById("pluginShell");
      shell.style.transform = "scale(" + scale + ")";
    }

    window.addEventListener("resize", updateScale);

    // ─── INITIALISE ──────────────────────────────────────────────────────────────
    function init() {
      // SPACE
      buildKnob("knob_topology", "topology");
      buildKnob("knob_decay", "decay");
      buildKnob("knob_preDelay", "preDelay");
      buildKnob("knob_density", "density");

      // SPECTRAL
      buildKnob("knob_spectralTilt", "spectralTilt");
      buildKnob("knob_resonance", "resonance");

      // TONE
      buildKnob("knob_lowCut", "lowCut");
      buildKnob("knob_tilt", "tilt");
      buildKnob("knob_highCut", "highCut");

      // MOTION
      buildKnob("knob_modRate", "modRate");
      buildKnob("knob_modDepth", "modDepth");

      // FLUTTER
      buildKnob("knob_wowFlutterAmount", "wowFlutterAmount");

      // DUCK
      buildKnob("knob_duckingAmount", "duckingAmount");

      // MUTATION
      buildHSlider("hslider_mutationInterval", "mutationInterval");
      buildHSlider("hslider_crossfadeSpeed", "crossfadeSpeed");

      // OUTPUT
      buildKnob("knob_width", "width");
      buildKnob("knob_mix", "mix");
      buildKnob("knob_outputLevel", "outputLevel");

      // Start polling C++ mutation state for countdown display
      pollMutationState();

      // Initial scale for resizable GUI
      updateScale();
    }

    document.addEventListener("DOMContentLoaded", init);
  </script>
</body>

</html>